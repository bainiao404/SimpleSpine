var vE=Object.defineProperty,AE=Object.defineProperties;var ME=Object.getOwnPropertyDescriptors;var px=Object.getOwnPropertySymbols;var TE=Object.prototype.hasOwnProperty,EE=Object.prototype.propertyIsEnumerable;var Mf=(St,V,Et)=>V in St?vE(St,V,{enumerable:!0,configurable:!0,writable:!0,value:Et}):St[V]=Et,Tf=(St,V)=>{for(var Et in V||(V={}))TE.call(V,Et)&&Mf(St,Et,V[Et]);if(px)for(var Et of px(V))EE.call(V,Et)&&Mf(St,Et,V[Et]);return St},Ef=(St,V)=>AE(St,ME(V));var T=(St,V,Et)=>Mf(St,typeof V!="symbol"?V+"":V,Et);/*!
 * pixi-spine - v4.0.4
 * Compiled Sat, 21 Jun 2025 17:29:38 UTC
 *
 * pixi-spine is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2025, Ivan Igorevich Popelyshev <ivan.popelyshev@gmail.com>, All Rights Reserved
 */this.PIXI=this.PIXI||{},this.PIXI.spine=function(St,V,Et,le,Xi,$i,Se,eh,IE,mb){"use strict";var Ks,Re,Mr,ho,Si,co,uo,nn,Ci,_t,Zs,vi,Ht;var gb=Object.defineProperty,pb=(f,t,e)=>t in f?gb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,En=(f,t,e)=>pb(f,typeof t!="symbol"?t+"":t,e);const Yr=class xx{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new xx().setFromString(t)}};En(Yr,"WHITE",new Yr(1,1,1,1)),En(Yr,"RED",new Yr(1,0,0,1)),En(Yr,"GREEN",new Yr(0,1,0,1)),En(Yr,"BLUE",new Yr(0,0,1,1)),En(Yr,"MAGENTA",new Yr(1,0,1,1));const hn=class Ol{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Ol.degRad)}static sinDeg(t){return Math.sin(t*Ol.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Ol.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Ol.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};En(hn,"PI",3.1415927),En(hn,"PI2",hn.PI*2),En(hn,"invPI2",1/hn.PI2),En(hn,"radiansToDegrees",180/hn.PI),En(hn,"radDeg",hn.radiansToDegrees),En(hn,"degreesToRadians",hn.PI/180),En(hn,"degRad",hn.degreesToRadians);let xb=hn;En(class Fo{static arrayCopy(t,e,s,n,r){for(let l=e,h=n;l<e+r;l++,h++)s[h]=t[l]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Fo.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Fo.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Fo.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Fo.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Fo.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}},"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");var bb=Object.defineProperty,wb=(f,t,e)=>t in f?bb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Wo=(f,t,e)=>wb(f,typeof t!="symbol"?t+"":t,e);function $f(f){switch(f.toLowerCase()){case"nearest":return 9728;case"linear":return 9729;case"mipmap":return 9987;case"mipmapnearestnearest":return 9984;case"mipmaplinearnearest":return 9985;case"mipmapnearestlinear":return 9986;case"mipmaplinearlinear":return 9987;default:throw new Error(`Unknown texture filter ${f}`)}}var pa=(f=>(f[f.Nearest=9728]="Nearest",f[f.Linear=9729]="Linear",f[f.MipMap=9987]="MipMap",f[f.MipMapNearestNearest=9984]="MipMapNearestNearest",f[f.MipMapLinearNearest=9985]="MipMapLinearNearest",f[f.MipMapNearestLinear=9986]="MipMapNearestLinear",f[f.MipMapLinearLinear=9987]="MipMapLinearLinear",f))(pa||{}),xa=(f=>(f[f.MirroredRepeat=33648]="MirroredRepeat",f[f.ClampToEdge=33071]="ClampToEdge",f[f.Repeat=10497]="Repeat",f))(xa||{});let Oh=class{constructor(){Wo(this,"texture"),Wo(this,"size",null),Wo(this,"names",null),Wo(this,"values",null),Wo(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var yb=Object.defineProperty,Sb=(f,t,e)=>t in f?yb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ge=(f,t,e)=>Sb(f,typeof t!="symbol"?t+"":t,e);let Cb=class{constructor(){ge(this,"x",0),ge(this,"y",0),ge(this,"width",0),ge(this,"height",0),ge(this,"offsetX",0),ge(this,"offsetY",0),ge(this,"originalWidth",0),ge(this,"originalHeight",0),ge(this,"rotate",0),ge(this,"index",0)}},Wh=class{constructor(t,e,s){ge(this,"pages",new Array),ge(this,"regions",new Array),t&&this.addSpineAtlas(t,e,s)}addTexture(t,e){const s=this.pages;let n=null;for(let l=0;l<s.length;l++)if(s[l].baseTexture===e.baseTexture){n=s[l];break}if(n===null){n=new Nf,n.name="texturePage";const l=e.baseTexture;n.width=l.realWidth,n.height=l.realHeight,n.baseTexture=l,n.minFilter=n.magFilter=pa.Nearest,n.uWrap=xa.ClampToEdge,n.vWrap=xa.ClampToEdge,s.push(n)}const r=new Vf;return r.name=t,r.page=n,r.texture=e,r.index=-1,this.regions.push(r),r}addTextureHash(t,e){for(const s in t)t.hasOwnProperty(s)&&this.addTexture(e&&s.indexOf(".")!==-1?s.substr(0,s.lastIndexOf(".")):s,t[s])}addSpineAtlas(t,e,s){return this.load(t,e,s)}load(t,e,s){if(e==null)throw new Error("textureLoader cannot be null.");const n=new vb(t),r=new Array(4);let l=null;const h={};let i=null;h.size=()=>{l.width=parseInt(r[1]),l.height=parseInt(r[2])},h.format=()=>{},h.filter=()=>{l.minFilter=$f(r[1]),l.magFilter=$f(r[2])},h.repeat=()=>{r[1].indexOf("x")!=-1&&(l.uWrap=xa.Repeat),r[1].indexOf("y")!=-1&&(l.vWrap=xa.Repeat)},h.pma=()=>{l.pma=r[1]=="true"};const a={};a.xy=()=>{i.x=parseInt(r[1]),i.y=parseInt(r[2])},a.size=()=>{i.width=parseInt(r[1]),i.height=parseInt(r[2])},a.bounds=()=>{i.x=parseInt(r[1]),i.y=parseInt(r[2]),i.width=parseInt(r[3]),i.height=parseInt(r[4])},a.offset=()=>{i.offsetX=parseInt(r[1]),i.offsetY=parseInt(r[2])},a.orig=()=>{i.originalWidth=parseInt(r[1]),i.originalHeight=parseInt(r[2])},a.offsets=()=>{i.offsetX=parseInt(r[1]),i.offsetY=parseInt(r[2]),i.originalWidth=parseInt(r[3]),i.originalHeight=parseInt(r[4])},a.rotate=()=>{const u=r[1];let m=0;u.toLocaleLowerCase()=="true"?m=6:u.toLocaleLowerCase()=="false"?m=0:m=(720-parseFloat(u))%360/45,i.rotate=m},a.index=()=>{i.index=parseInt(r[1])};let o=n.readLine();for(;o!=null&&o.trim().length==0;)o=n.readLine();for(;!(o==null||o.trim().length==0||n.readEntry(r,o)==0);)o=n.readLine();const d=()=>{for(;;){if(o==null)return s&&s(this);if(o.trim().length==0)l=null,o=n.readLine();else if(l===null){for(l=new Nf,l.name=o.trim();n.readEntry(r,o=n.readLine())!=0;){const u=h[r[0]];u&&u()}this.pages.push(l),e(l.name,u=>{if(u===null)return this.pages.splice(this.pages.indexOf(l),1),s&&s(null);l.baseTexture=u,l.pma&&(u.alphaMode=V.ALPHA_MODES.PMA),u.valid||u.setSize(l.width,l.height),l.setFilters(),(!l.width||!l.height)&&(l.width=u.realWidth,l.height=u.realHeight,(!l.width||!l.height)&&console.log(`ERROR spine atlas page ${l.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),d()});break}else{i=new Cb;const u=new Vf;u.name=o,u.page=l;let m=null,c=null;for(;;){const b=n.readEntry(r,o=n.readLine());if(b==0)break;const S=a[r[0]];if(S)S();else{m==null&&(m=[],c=[]),m.push(r[0]);const C=[];for(let v=0;v<b;v++)C.push(parseInt(r[v+1]));c.push(C)}}i.originalWidth==0&&i.originalHeight==0&&(i.originalWidth=i.width,i.originalHeight=i.height);const g=l.baseTexture.resolution;i.x/=g,i.y/=g,i.width/=g,i.height/=g,i.originalWidth/=g,i.originalHeight/=g,i.offsetX/=g,i.offsetY/=g;const p=i.rotate%4!==0,y=new V.Rectangle(i.x,i.y,p?i.height:i.width,p?i.width:i.height),w=new V.Rectangle(0,0,i.originalWidth,i.originalHeight),x=new V.Rectangle(i.offsetX,i.originalHeight-i.height-i.offsetY,i.width,i.height);u.texture=new V.Texture(u.page.baseTexture,y,w,x,i.rotate),u.index=i.index,u.texture.updateUvs(),this.regions.push(u)}}};d()}findRegion(t){for(let e=0;e<this.regions.length;e++)if(this.regions[e].name==t)return this.regions[e];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}},vb=class{constructor(t){ge(this,"lines"),ge(this,"index",0),this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,e){if(e==null||(e=e.trim(),e.length==0))return 0;const s=e.indexOf(":");if(s==-1)return 0;t[0]=e.substr(0,s).trim();for(let n=1,r=s+1;;n++){const l=e.indexOf(",",r);if(l==-1)return t[n]=e.substr(r).trim(),n;if(t[n]=e.substr(r,l-r).trim(),r=l+1,n==4)return 4}}},Nf=class{constructor(){ge(this,"name"),ge(this,"minFilter",pa.Nearest),ge(this,"magFilter",pa.Nearest),ge(this,"uWrap",xa.ClampToEdge),ge(this,"vWrap",xa.ClampToEdge),ge(this,"baseTexture"),ge(this,"width"),ge(this,"height"),ge(this,"pma")}setFilters(){const t=this.baseTexture,e=this.minFilter;e==pa.Linear?t.scaleMode=V.SCALE_MODES.LINEAR:this.minFilter==pa.Nearest?t.scaleMode=V.SCALE_MODES.NEAREST:(t.mipmap=V.MIPMAP_MODES.POW2,e==pa.MipMapNearestNearest?t.scaleMode=V.SCALE_MODES.NEAREST:t.scaleMode=V.SCALE_MODES.LINEAR)}},Vf=class extends Oh{constructor(){super(...arguments),ge(this,"page"),ge(this,"name"),ge(this,"index")}};var ba=(f=>(f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping",f))(ba||{}),_f=(f=>(f[f.none=0]="none",f[f.reset=1]="reset",f[f.update=2]="update",f[f.pose=3]="pose",f))(_f||{}),Df=(f=>(f[f.UNKNOWN=0]="UNKNOWN",f[f.VER37=37]="VER37",f[f.VER38=38]="VER38",f[f.VER40=40]="VER40",f[f.VER41=41]="VER41",f[f.VER42=42]="VER42",f))(Df||{});function Ab(f){const t=f.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const Mb={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var Tb=Object.defineProperty,Eb=(f,t,e)=>t in f?Tb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ys=(f,t,e)=>Eb(f,typeof t!="symbol"?t+"":t,e);const Ni=[0,0,0];let Ib=class extends $i.Sprite{constructor(){super(...arguments),ys(this,"region",null),ys(this,"attachment",null)}},kb=class extends Xi.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),ys(this,"region",null),ys(this,"attachment",null)}};const Lf=class bx extends Et.Container{constructor(t){if(super(),ys(this,"tintRgb"),ys(this,"spineData"),ys(this,"skeleton"),ys(this,"stateData"),ys(this,"state"),ys(this,"slotContainers"),ys(this,"tempClipContainers"),ys(this,"localDelayLimit"),ys(this,"_autoUpdate"),ys(this,"_visible"),ys(this,"_debug"),ys(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),l=this.newContainer();if(this.slotContainers.push(l),this.addChild(l),this.tempClipContainers.push(null),!!r)if(r.type===ba.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,l.addChild(i)}else if(r.type===ba.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,l.addChild(h)}else r.type===ba.Clipping&&(this.createGraphics(n,r),l.addChild(n.clippingContainer),l.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?bx.prototype.autoUpdateTransform:Et.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=V.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:Mb.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=Ab(this.spineData.version||this.spineData.spine.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Df.VER42&&_f.update);const n=this.skeleton.slots,r=this.color;let l=null,h=null;r?(l=r.light,h=r.dark):l=this.tintRgb;for(let u=0,m=n.length;u<m;u++){const c=n[u],g=c.getAttachment(),p=this.slotContainers[u];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(c,g);let w=g.region;const x=g.color;switch(g!=null&&g.type){case ba.Region:if(p.transform.setFromMatrix(c.bone.matrix),w=g.region,c.currentMesh&&(c.currentMesh.visible=!1,c.currentMesh=null,c.currentMeshId=void 0,c.currentMeshName=void 0),!w){c.currentSprite&&(c.currentSprite.renderable=!1);break}if(!c.currentSpriteName||c.currentSpriteName!==g.name){const C=g.name;if(c.currentSprite&&(c.currentSprite.visible=!1),c.sprites=c.sprites||{},c.sprites[C]!==void 0)c.sprites[C].visible=!0;else{const v=this.createSprite(c,g,C);p.addChild(v)}c.currentSprite=c.sprites[C],c.currentSpriteName=C}c.currentSprite.renderable=!0,c.hackRegion||this.setSpriteRegion(g,c.currentSprite,w),c.currentSprite.color?y=c.currentSprite.color:(Ni[0]=l[0]*c.color.r*x.r,Ni[1]=l[1]*c.color.g*x.g,Ni[2]=l[2]*c.color.b*x.b,c.currentSprite.tint=V.utils.rgb2hex(Ni)),c.currentSprite.blendMode=c.blendMode;break;case ba.Mesh:if(c.currentSprite){c.currentSprite.visible=!1,c.currentSprite=null,c.currentSpriteName=void 0;const C=new V.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){c.currentMesh&&(c.currentMesh.renderable=!1);break}const S=g.id;if(c.currentMeshId===void 0||c.currentMeshId!==S){const C=S;if(c.currentMesh&&(c.currentMesh.visible=!1),c.meshes=c.meshes||{},c.meshes[C]!==void 0)c.meshes[C].visible=!0;else{const v=this.createMesh(c,g);p.addChild(v)}c.currentMesh=c.meshes[C],c.currentMeshName=g.name,c.currentMeshId=C}c.currentMesh.renderable=!0,g.computeWorldVerticesOld(c,c.currentMesh.vertices),c.currentMesh.color?y=c.currentMesh.color:(Ni[0]=l[0]*c.color.r*x.r,Ni[1]=l[1]*c.color.g*x.g,Ni[2]=l[2]*c.color.b*x.b,c.currentMesh.tint=V.utils.rgb2hex(Ni)),c.currentMesh.blendMode=c.blendMode,c.hackRegion||this.setMeshRegion(g,c.currentMesh,w);break;case ba.Clipping:c.currentGraphics||(this.createGraphics(c,g),p.addChild(c.clippingContainer),p.addChild(c.currentGraphics)),this.updateGraphics(c,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let b=c.color.r*x.r,S=c.color.g*x.g,C=c.color.b*x.b;y.setLight(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C)),c.darkColor?(b=c.darkColor.r,S=c.darkColor.g,C=c.darkColor.b):(b=0,S=0,C=0),y.setDark(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C))}p.alpha=c.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let u=0,m=i.length;u<m;u++){const c=n[i[u].data.index],g=this.slotContainers[i[u].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),c.currentGraphics&&c.getAttachment())o=c.clippingContainer,a=c.getAttachment(),o.children.length=0,this.children[u]=g,a.endSlot===c.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[u];p||(p=this.tempClipContainers[u]=this.newContainer(),p.visible=!1),this.children[u]=p,g.parent=null,o.addChild(g),a.endSlot==c.data&&(o.renderable=!0,o=null,a=null)}else this.children[u]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*xb.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Et.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,l=this.newSprite(r);return l.anchor.set(.5),n&&this.setSpriteRegion(e,l,e.region),t.sprites=t.sprites||{},t.sprites[s]=l,l}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),V.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new V.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let l=r.region;return e?(l=new Oh,l.texture=e,l.size=s,n.hackRegion=l,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,l):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,l),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),l=this.skeleton.getAttachmentByName(t,e);l.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=l.region;return s?(a=new Oh,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Et.Container}newSprite(t){return new Ib(t)}newGraphics(){return new le.Graphics}newMesh(t,e,s,n,r){return new kb(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let l=0,h=this.skeleton.slots.length;l<h;l++){const i=this.skeleton.slots[l],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};ys(Lf,"clippingPolygon",[]),Object.defineProperty(Lf.prototype,"visible",{get(){return this._visible},set(f){f!==this._visible&&(this._visible=f,f&&(this.lastTime=0))}});const Pb={extension:V.ExtensionType.Asset,loader:{extension:{type:V.ExtensionType.LoadParser,priority:Se.LoaderParserPriority.Normal},test(f){return Se.checkExtension(f,".atlas")},async load(f){return await(await V.settings.ADAPTER.fetch(f)).text()},testParse(f,t){const e=Se.checkExtension(t.src,".atlas"),s=typeof f=="string";return Promise.resolve(e&&s)},async parse(f,t,e){const s=t.data;let n=V.utils.path.dirname(t.src);n&&n.lastIndexOf("/")!==n.length-1&&(n+="/");let r=null,l=null;const h=new Promise((o,d)=>{r=o,l=d});let i;const a=o=>{o||l(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),r(i)};if(s.image||s.images){const o=Object.assign(s.image?{default:s.image}:{},s.images);i=new Wh(f,(d,u)=>{const m=o[d]||o.default;m&&m.baseTexture?u(m.baseTexture):u(m)},a)}else i=new Wh(f,Of(e,n,s.imageMetadata),a);return await h},unload(f){f.dispose()}}},Of=(f,t,e)=>async(s,n)=>{const r=V.utils.path.normalize([...t.split(V.utils.path.sep),s].join(V.utils.path.sep)),l=await f.load({src:r,data:e});n(l.baseTexture)};V.extensions.add(Pb);let Wf=class{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<7,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<14,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<21,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}};var Rb=Object.defineProperty,Yb=(f,t,e)=>t in f?Rb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,In=(f,t,e)=>Yb(f,typeof t!="symbol"?t+"":t,e);const Fr=class wx{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new wx().setFromString(t)}};In(Fr,"WHITE",new Fr(1,1,1,1)),In(Fr,"RED",new Fr(1,0,0,1)),In(Fr,"GREEN",new Fr(0,1,0,1)),In(Fr,"BLUE",new Fr(0,0,1,1)),In(Fr,"MAGENTA",new Fr(1,0,1,1));const cn=class Wl{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Wl.degRad)}static sinDeg(t){return Math.sin(t*Wl.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Wl.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Wl.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};In(cn,"PI",3.1415927),In(cn,"PI2",cn.PI*2),In(cn,"invPI2",1/cn.PI2),In(cn,"radiansToDegrees",180/cn.PI),In(cn,"radDeg",cn.radiansToDegrees),In(cn,"degreesToRadians",cn.PI/180),In(cn,"degRad",cn.degreesToRadians);let Fb=cn;In(class Bo{static arrayCopy(t,e,s,n,r){for(let l=e,h=n;l<e+r;l++,h++)s[h]=t[l]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Bo.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Bo.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Bo.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Bo.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Bo.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}},"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");var Js=(f=>(f[f.UNKNOWN=0]="UNKNOWN",f[f.VER37=37]="VER37",f[f.VER38=38]="VER38",f[f.VER40=40]="VER40",f[f.VER41=41]="VER41",f[f.VER42=42]="VER42",f))(Js||{});function Uo(f){const t=f.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}var wa=(f=>(f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping",f))(wa||{}),Uh=(f=>(f[f.none=0]="none",f[f.reset=1]="reset",f[f.update=2]="update",f[f.pose=3]="pose",f))(Uh||{}),Bb=Object.defineProperty,Xb=(f,t,e)=>t in f?Bb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,qo=(f,t,e)=>Xb(f,typeof t!="symbol"?t+"":t,e);let Uf=class{constructor(){qo(this,"texture"),qo(this,"size",null),qo(this,"names",null),qo(this,"values",null),qo(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};const $b={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var Nb=Object.defineProperty,Vb=(f,t,e)=>t in f?Nb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ss=(f,t,e)=>Vb(f,typeof t!="symbol"?t+"":t,e);const Vi=[0,0,0];let _b=class extends $i.Sprite{constructor(){super(...arguments),Ss(this,"region",null),Ss(this,"attachment",null)}},Db=class extends Xi.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),Ss(this,"region",null),Ss(this,"attachment",null)}};const qf=class yx extends Et.Container{constructor(t){if(super(),Ss(this,"tintRgb"),Ss(this,"spineData"),Ss(this,"skeleton"),Ss(this,"stateData"),Ss(this,"state"),Ss(this,"slotContainers"),Ss(this,"tempClipContainers"),Ss(this,"localDelayLimit"),Ss(this,"_autoUpdate"),Ss(this,"_visible"),Ss(this,"_debug"),Ss(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),l=this.newContainer();if(this.slotContainers.push(l),this.addChild(l),this.tempClipContainers.push(null),!!r)if(r.type===wa.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,l.addChild(i)}else if(r.type===wa.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,l.addChild(h)}else r.type===wa.Clipping&&(this.createGraphics(n,r),l.addChild(n.clippingContainer),l.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?yx.prototype.autoUpdateTransform:Et.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=V.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:$b.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=Uo(this.spineData.version||this.spineData.spine.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Js.VER42&&Uh.update);const n=this.skeleton.slots,r=this.color;let l=null,h=null;r?(l=r.light,h=r.dark):l=this.tintRgb;for(let u=0,m=n.length;u<m;u++){const c=n[u],g=c.getAttachment(),p=this.slotContainers[u];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(c,g);let w=g.region;const x=g.color;switch(g!=null&&g.type){case wa.Region:if(p.transform.setFromMatrix(c.bone.matrix),w=g.region,c.currentMesh&&(c.currentMesh.visible=!1,c.currentMesh=null,c.currentMeshId=void 0,c.currentMeshName=void 0),!w){c.currentSprite&&(c.currentSprite.renderable=!1);break}if(!c.currentSpriteName||c.currentSpriteName!==g.name){const C=g.name;if(c.currentSprite&&(c.currentSprite.visible=!1),c.sprites=c.sprites||{},c.sprites[C]!==void 0)c.sprites[C].visible=!0;else{const v=this.createSprite(c,g,C);p.addChild(v)}c.currentSprite=c.sprites[C],c.currentSpriteName=C}c.currentSprite.renderable=!0,c.hackRegion||this.setSpriteRegion(g,c.currentSprite,w),c.currentSprite.color?y=c.currentSprite.color:(Vi[0]=l[0]*c.color.r*x.r,Vi[1]=l[1]*c.color.g*x.g,Vi[2]=l[2]*c.color.b*x.b,c.currentSprite.tint=V.utils.rgb2hex(Vi)),c.currentSprite.blendMode=c.blendMode;break;case wa.Mesh:if(c.currentSprite){c.currentSprite.visible=!1,c.currentSprite=null,c.currentSpriteName=void 0;const C=new V.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){c.currentMesh&&(c.currentMesh.renderable=!1);break}const S=g.id;if(c.currentMeshId===void 0||c.currentMeshId!==S){const C=S;if(c.currentMesh&&(c.currentMesh.visible=!1),c.meshes=c.meshes||{},c.meshes[C]!==void 0)c.meshes[C].visible=!0;else{const v=this.createMesh(c,g);p.addChild(v)}c.currentMesh=c.meshes[C],c.currentMeshName=g.name,c.currentMeshId=C}c.currentMesh.renderable=!0,g.computeWorldVerticesOld(c,c.currentMesh.vertices),c.currentMesh.color?y=c.currentMesh.color:(Vi[0]=l[0]*c.color.r*x.r,Vi[1]=l[1]*c.color.g*x.g,Vi[2]=l[2]*c.color.b*x.b,c.currentMesh.tint=V.utils.rgb2hex(Vi)),c.currentMesh.blendMode=c.blendMode,c.hackRegion||this.setMeshRegion(g,c.currentMesh,w);break;case wa.Clipping:c.currentGraphics||(this.createGraphics(c,g),p.addChild(c.clippingContainer),p.addChild(c.currentGraphics)),this.updateGraphics(c,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let b=c.color.r*x.r,S=c.color.g*x.g,C=c.color.b*x.b;y.setLight(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C)),c.darkColor?(b=c.darkColor.r,S=c.darkColor.g,C=c.darkColor.b):(b=0,S=0,C=0),y.setDark(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C))}p.alpha=c.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let u=0,m=i.length;u<m;u++){const c=n[i[u].data.index],g=this.slotContainers[i[u].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),c.currentGraphics&&c.getAttachment())o=c.clippingContainer,a=c.getAttachment(),o.children.length=0,this.children[u]=g,a.endSlot===c.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[u];p||(p=this.tempClipContainers[u]=this.newContainer(),p.visible=!1),this.children[u]=p,g.parent=null,o.addChild(g),a.endSlot==c.data&&(o.renderable=!0,o=null,a=null)}else this.children[u]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*Fb.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Et.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,l=this.newSprite(r);return l.anchor.set(.5),n&&this.setSpriteRegion(e,l,e.region),t.sprites=t.sprites||{},t.sprites[s]=l,l}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),V.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new V.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let l=r.region;return e?(l=new Uf,l.texture=e,l.size=s,n.hackRegion=l,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,l):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,l),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),l=this.skeleton.getAttachmentByName(t,e);l.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=l.region;return s?(a=new Uf,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Et.Container}newSprite(t){return new _b(t)}newGraphics(){return new le.Graphics}newMesh(t,e,s,n,r){return new Db(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let l=0,h=this.skeleton.slots.length;l<h;l++){const i=this.skeleton.slots[l],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};Ss(qf,"clippingPolygon",[]);let zf=qf;Object.defineProperty(zf.prototype,"visible",{get(){return this._visible},set(f){f!==this._visible&&(this._visible=f,f&&(this.lastTime=0))}});function Gf(f){return f.hasOwnProperty("bones")}function Lb(f){return f instanceof ArrayBuffer}class Ob{constructor(){}installLoader(){console.log("installLoader");const t=this,e={extension:V.ExtensionType.Asset,loader:{extension:{type:V.ExtensionType.LoadParser,priority:Se.LoaderParserPriority.Normal},test(s){return Se.checkExtension(s,".skel")},async load(s){return await(await V.settings.ADAPTER.fetch(s)).arrayBuffer()},testParse(s,n){var i;const r=Se.checkExtension(n.src,".json")&&Gf(s),l=Se.checkExtension(n.src,".skel")&&Lb(s),h=((i=n.data)==null?void 0:i.spineAtlas)===!1;return Promise.resolve(r&&!h||l)},async parse(s,n,r){var w;const l=V.utils.path.extname(n.src).toLowerCase(),h=V.utils.path.basename(n.src,l);let i=V.utils.path.dirname(n.src);i&&i.lastIndexOf("/")!==i.length-1&&(i+="/");const a=Se.checkExtension(n.src,".json")&&Gf(s);let o=null,d=s;a?o=t.createJsonParser():(o=t.createBinaryParser(),d=new Uint8Array(s));const u=n.data||{},m=(w=u==null?void 0:u.spineSkeletonScale)!=null?w:null;m&&(o.scale=m);const c=u.spineAtlas;if(c&&c.pages)return t.parseData(o,c,d);const g=u.atlasRawData;if(g){let x=null,b=null;const S=new Promise((A,M)=>{x=A,b=M}),C=new Wh(g,Of(r,i,u.imageMetadata),A=>{A||b(`Something went terribly wrong loading a spine .atlas file
Most likely your texture failed to load.`),x(C)}),v=await S;return t.parseData(o,v,d)}let p=u.spineAtlasFile;p||(p=`${i+h}.atlas`);const y=await r.load({src:p,data:u,alias:u.spineAtlasAlias});return t.parseData(o,y,d)}}};return V.extensions.add(e),e}}var Wb=Object.defineProperty,Ub=(f,t,e)=>t in f?Wb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ya=(f,t,e)=>Ub(f,typeof t!="symbol"?t+"":t,e);let qh=class{constructor(t){if(ya(this,"name"),ya(this,"type"),t==null)throw new Error("name cannot be null.");this.name=t}};const Hf=class Sx extends qh{constructor(t){super(t),ya(this,"id",(Sx.nextID++&65535)<<11),ya(this,"bones"),ya(this,"vertices"),ya(this,"worldVerticesLength",0)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,l){s=r+(s>>1)*l;const h=t.bone.skeleton,i=t.attachmentVertices;let a=this.vertices;const o=this.bones;if(o==null){i.length>0&&(a=i);const c=t.bone.matrix,g=c.tx,p=c.ty,y=c.a,w=c.c,x=c.b,b=c.d;for(let S=e,C=r;C<s;S+=2,C+=l){const v=a[S],A=a[S+1];n[C]=v*y+A*w+g,n[C+1]=v*x+A*b+p}return}let d=0,u=0;for(let c=0;c<e;c+=2){const g=o[d];d+=g+1,u+=g}const m=h.bones;if(i.length==0)for(let c=r,g=u*3;c<s;c+=l){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const x=m[o[d]].matrix,b=a[g],S=a[g+1],C=a[g+2];p+=(b*x.a+S*x.c+x.tx)*C,y+=(b*x.b+S*x.d+x.ty)*C}n[c]=p,n[c+1]=y}else{const c=i;for(let g=r,p=u*3,y=u<<1;g<s;g+=l){let w=0,x=0,b=o[d++];for(b+=d;d<b;d++,p+=3,y+=2){const S=m[o[d]].matrix,C=a[p]+c[y],v=a[p+1]+c[y+1],A=a[p+2];w+=(C*S.a+v*S.c+S.tx)*A,x+=(C*S.b+v*S.d+S.ty)*A}n[g]=w,n[g+1]=x}}}applyDeform(t){return this==t}};ya(Hf,"nextID",0);let Sa=Hf;var qb=Object.defineProperty,zb=(f,t,e)=>t in f?qb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Cs=(f,t,e)=>zb(f,typeof t!="symbol"?t+"":t,e);let Gb=class{constructor(){Cs(this,"array",new Array)}add(t){const e=this.contains(t);return this.array[t|0]=t|0,!e}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}};const zn=class Cx{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Cx().setFromString(t)}};Cs(zn,"WHITE",new zn(1,1,1,1)),Cs(zn,"RED",new zn(1,0,0,1)),Cs(zn,"GREEN",new zn(0,1,0,1)),Cs(zn,"BLUE",new zn(0,0,1,1)),Cs(zn,"MAGENTA",new zn(1,0,1,1));let Ls=zn;const dn=class Ul{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Ul.degRad)}static sinDeg(t){return Math.sin(t*Ul.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Ul.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Ul.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};Cs(dn,"PI",3.1415927),Cs(dn,"PI2",dn.PI*2),Cs(dn,"invPI2",1/dn.PI2),Cs(dn,"radiansToDegrees",180/dn.PI),Cs(dn,"radDeg",dn.radiansToDegrees),Cs(dn,"degreesToRadians",dn.PI/180),Cs(dn,"degRad",dn.degreesToRadians);let rt=dn,Hb=class{apply(t,e,s){return t+(e-t)*this.applyInternal(s)}},Kb=class extends Hb{constructor(t){super(),Cs(this,"power",2),this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}},Zb=class extends Kb{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}};const Kf=class Xo{static arrayCopy(t,e,s,n,r){for(let l=e,h=n;l<e+r;l++,h++)s[h]=t[l]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Xo.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Xo.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Xo.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Xo.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Xo.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};Cs(Kf,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let It=Kf,Zf=class{constructor(t){Cs(this,"items",new Array),Cs(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},Jb=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};var un=(f=>(f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping",f))(un||{}),kn=(f=>(f[f.Normal=0]="Normal",f[f.OnlyTranslation=1]="OnlyTranslation",f[f.NoRotationOrReflection=2]="NoRotationOrReflection",f[f.NoScale=3]="NoScale",f[f.NoScaleOrReflection=4]="NoScaleOrReflection",f))(kn||{}),Jf=(f=>(f[f.none=0]="none",f[f.reset=1]="reset",f[f.update=2]="update",f[f.pose=3]="pose",f))(Jf||{}),Qb=Object.defineProperty,jb=(f,t,e)=>t in f?Qb(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,zo=(f,t,e)=>jb(f,typeof t!="symbol"?t+"":t,e);let Qf=class{constructor(){zo(this,"texture"),zo(this,"size",null),zo(this,"names",null),zo(this,"values",null),zo(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var jf=(f=>(f[f.UNKNOWN=0]="UNKNOWN",f[f.VER37=37]="VER37",f[f.VER38=38]="VER38",f[f.VER40=40]="VER40",f[f.VER41=41]="VER41",f[f.VER42=42]="VER42",f))(jf||{});function tw(f){const t=f.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const ew={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var sw=Object.defineProperty,nw=(f,t,e)=>t in f?sw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,vs=(f,t,e)=>nw(f,typeof t!="symbol"?t+"":t,e);const _i=[0,0,0];let rw=class extends $i.Sprite{constructor(){super(...arguments),vs(this,"region",null),vs(this,"attachment",null)}},iw=class extends Xi.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),vs(this,"region",null),vs(this,"attachment",null)}};const tm=class vx extends Et.Container{constructor(t){if(super(),vs(this,"tintRgb"),vs(this,"spineData"),vs(this,"skeleton"),vs(this,"stateData"),vs(this,"state"),vs(this,"slotContainers"),vs(this,"tempClipContainers"),vs(this,"localDelayLimit"),vs(this,"_autoUpdate"),vs(this,"_visible"),vs(this,"_debug"),vs(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),l=this.newContainer();if(this.slotContainers.push(l),this.addChild(l),this.tempClipContainers.push(null),!!r)if(r.type===un.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,l.addChild(i)}else if(r.type===un.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,l.addChild(h)}else r.type===un.Clipping&&(this.createGraphics(n,r),l.addChild(n.clippingContainer),l.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?vx.prototype.autoUpdateTransform:Et.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=V.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:ew.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=tw(this.spineData.version||this.spineData.spine.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===jf.VER42&&Jf.update);const n=this.skeleton.slots,r=this.color;let l=null,h=null;r?(l=r.light,h=r.dark):l=this.tintRgb;for(let u=0,m=n.length;u<m;u++){const c=n[u],g=c.getAttachment(),p=this.slotContainers[u];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(c,g);let w=g.region;const x=g.color;switch(g!=null&&g.type){case un.Region:if(p.transform.setFromMatrix(c.bone.matrix),w=g.region,c.currentMesh&&(c.currentMesh.visible=!1,c.currentMesh=null,c.currentMeshId=void 0,c.currentMeshName=void 0),!w){c.currentSprite&&(c.currentSprite.renderable=!1);break}if(!c.currentSpriteName||c.currentSpriteName!==g.name){const C=g.name;if(c.currentSprite&&(c.currentSprite.visible=!1),c.sprites=c.sprites||{},c.sprites[C]!==void 0)c.sprites[C].visible=!0;else{const v=this.createSprite(c,g,C);p.addChild(v)}c.currentSprite=c.sprites[C],c.currentSpriteName=C}c.currentSprite.renderable=!0,c.hackRegion||this.setSpriteRegion(g,c.currentSprite,w),c.currentSprite.color?y=c.currentSprite.color:(_i[0]=l[0]*c.color.r*x.r,_i[1]=l[1]*c.color.g*x.g,_i[2]=l[2]*c.color.b*x.b,c.currentSprite.tint=V.utils.rgb2hex(_i)),c.currentSprite.blendMode=c.blendMode;break;case un.Mesh:if(c.currentSprite){c.currentSprite.visible=!1,c.currentSprite=null,c.currentSpriteName=void 0;const C=new V.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){c.currentMesh&&(c.currentMesh.renderable=!1);break}const S=g.id;if(c.currentMeshId===void 0||c.currentMeshId!==S){const C=S;if(c.currentMesh&&(c.currentMesh.visible=!1),c.meshes=c.meshes||{},c.meshes[C]!==void 0)c.meshes[C].visible=!0;else{const v=this.createMesh(c,g);p.addChild(v)}c.currentMesh=c.meshes[C],c.currentMeshName=g.name,c.currentMeshId=C}c.currentMesh.renderable=!0,g.computeWorldVerticesOld(c,c.currentMesh.vertices),c.currentMesh.color?y=c.currentMesh.color:(_i[0]=l[0]*c.color.r*x.r,_i[1]=l[1]*c.color.g*x.g,_i[2]=l[2]*c.color.b*x.b,c.currentMesh.tint=V.utils.rgb2hex(_i)),c.currentMesh.blendMode=c.blendMode,c.hackRegion||this.setMeshRegion(g,c.currentMesh,w);break;case un.Clipping:c.currentGraphics||(this.createGraphics(c,g),p.addChild(c.clippingContainer),p.addChild(c.currentGraphics)),this.updateGraphics(c,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let b=c.color.r*x.r,S=c.color.g*x.g,C=c.color.b*x.b;y.setLight(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C)),c.darkColor?(b=c.darkColor.r,S=c.darkColor.g,C=c.darkColor.b):(b=0,S=0,C=0),y.setDark(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C))}p.alpha=c.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let u=0,m=i.length;u<m;u++){const c=n[i[u].data.index],g=this.slotContainers[i[u].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),c.currentGraphics&&c.getAttachment())o=c.clippingContainer,a=c.getAttachment(),o.children.length=0,this.children[u]=g,a.endSlot===c.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[u];p||(p=this.tempClipContainers[u]=this.newContainer(),p.visible=!1),this.children[u]=p,g.parent=null,o.addChild(g),a.endSlot==c.data&&(o.renderable=!0,o=null,a=null)}else this.children[u]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*rt.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Et.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,l=this.newSprite(r);return l.anchor.set(.5),n&&this.setSpriteRegion(e,l,e.region),t.sprites=t.sprites||{},t.sprites[s]=l,l}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),V.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new V.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let l=r.region;return e?(l=new Qf,l.texture=e,l.size=s,n.hackRegion=l,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,l):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,l),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),l=this.skeleton.getAttachmentByName(t,e);l.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=l.region;return s?(a=new Qf,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Et.Container}newSprite(t){return new rw(t)}newGraphics(){return new le.Graphics}newMesh(t,e,s,n,r){return new iw(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let l=0,h=this.skeleton.slots.length;l<h;l++){const i=this.skeleton.slots[l],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};vs(tm,"clippingPolygon",[]);let em=tm;Object.defineProperty(em.prototype,"visible",{get(){return this._visible},set(f){f!==this._visible&&(this._visible=f,f&&(this.lastTime=0))}});var aw=Object.defineProperty,ow=(f,t,e)=>t in f?aw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Di=(f,t,e)=>ow(f,typeof t!="symbol"?t+"":t,e);let zh=class{constructor(t,e){if(Di(this,"blendMode"),Di(this,"data"),Di(this,"bone"),Di(this,"color"),Di(this,"darkColor"),Di(this,"attachment"),Di(this,"attachmentTime"),Di(this,"attachmentVertices",new Array),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new Ls,this.darkColor=t.darkColor==null?null:new Ls,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.attachmentVertices.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};var lw=Object.defineProperty,hw=(f,t,e)=>t in f?lw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ct=(f,t,e)=>hw(f,typeof t!="symbol"?t+"":t,e);const Ft=class Ds extends qh{constructor(t){super(t),Ct(this,"type",un.Region),Ct(this,"x",0),Ct(this,"y",0),Ct(this,"scaleX",1),Ct(this,"scaleY",1),Ct(this,"rotation",0),Ct(this,"width",0),Ct(this,"height",0),Ct(this,"color",new Ls(1,1,1,1)),Ct(this,"path"),Ct(this,"rendererObject"),Ct(this,"region"),Ct(this,"offset",It.newFloatArray(8)),Ct(this,"uvs",It.newFloatArray(8)),Ct(this,"tempColor",new Ls(1,1,1,1))}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*t,n=-this.height/2*this.scaleY+this.region.offsetY*e,r=s+this.region.width*t,l=n+this.region.height*e,h=this.rotation*Math.PI/180,i=Math.cos(h),a=Math.sin(h),o=s*i+this.x,d=s*a,u=n*i+this.y,m=n*a,c=r*i+this.x,g=r*a,p=l*i+this.y,y=l*a,w=this.offset;w[Ds.OX1]=o-m,w[Ds.OY1]=u+d,w[Ds.OX2]=o-y,w[Ds.OY2]=p+d,w[Ds.OX3]=c-y,w[Ds.OY3]=p+g,w[Ds.OX4]=c-m,w[Ds.OY4]=u+g}setRegion(t){this.region=t;const e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,s,n){const r=this.offset,l=t instanceof zh?t.bone.matrix:t.matrix,h=l.tx,i=l.ty,a=l.a,o=l.c,d=l.b,u=l.d;let m=0,c=0;m=r[Ds.OX1],c=r[Ds.OY1],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i,s+=n,m=r[Ds.OX2],c=r[Ds.OY2],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i,s+=n,m=r[Ds.OX3],c=r[Ds.OY3],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i,s+=n,m=r[Ds.OX4],c=r[Ds.OY4],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i}};Ct(Ft,"OX1",0),Ct(Ft,"OY1",1),Ct(Ft,"OX2",2),Ct(Ft,"OY2",3),Ct(Ft,"OX3",4),Ct(Ft,"OY3",5),Ct(Ft,"OX4",6),Ct(Ft,"OY4",7),Ct(Ft,"X1",0),Ct(Ft,"Y1",1),Ct(Ft,"C1R",2),Ct(Ft,"C1G",3),Ct(Ft,"C1B",4),Ct(Ft,"C1A",5),Ct(Ft,"U1",6),Ct(Ft,"V1",7),Ct(Ft,"X2",8),Ct(Ft,"Y2",9),Ct(Ft,"C2R",10),Ct(Ft,"C2G",11),Ct(Ft,"C2B",12),Ct(Ft,"C2A",13),Ct(Ft,"U2",14),Ct(Ft,"V2",15),Ct(Ft,"X3",16),Ct(Ft,"Y3",17),Ct(Ft,"C3R",18),Ct(Ft,"C3G",19),Ct(Ft,"C3B",20),Ct(Ft,"C3A",21),Ct(Ft,"U3",22),Ct(Ft,"V3",23),Ct(Ft,"X4",24),Ct(Ft,"Y4",25),Ct(Ft,"C4R",26),Ct(Ft,"C4G",27),Ct(Ft,"C4B",28),Ct(Ft,"C4A",29),Ct(Ft,"U4",30),Ct(Ft,"V4",31);let Gh=Ft;var cw=Object.defineProperty,dw=(f,t,e)=>t in f?cw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ca=(f,t,e)=>dw(f,typeof t!="symbol"?t+"":t,e);const sm=class Ax{constructor(t){Ca(this,"centerX",0),Ca(this,"centerY",0),Ca(this,"radius",0),Ca(this,"angle",0),Ca(this,"worldX",0),Ca(this,"worldY",0),this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,e,s,n){const r=this.angle*rt.degreesToRadians,l=t.x-this.worldX,h=t.y-this.worldY,i=Math.sqrt(l*l+h*h);if(i<this.radius){const a=Ax.interpolation.apply(0,r,(this.radius-i)/this.radius),o=Math.cos(a),d=Math.sin(a);t.x=o*l-d*h+this.worldX,t.y=d*l+o*h+this.worldY}}end(){}};Ca(sm,"interpolation",new Zb(2));let uw=sm;var at=(f=>(f[f.setup=0]="setup",f[f.first=1]="first",f[f.replace=2]="replace",f[f.add=3]="add",f))(at||{}),Qs=(f=>(f[f.mixIn=0]="mixIn",f[f.mixOut=1]="mixOut",f))(Qs||{}),fw=Object.defineProperty,mw=(f,t,e)=>t in f?fw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,tt=(f,t,e)=>mw(f,typeof t!="symbol"?t+"":t,e);let es=class{constructor(t,e,s){if(tt(this,"name"),tt(this,"timelines"),tt(this,"duration"),t==null)throw new Error("name cannot be null.");if(e==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.duration=s}apply(t,e,s,n,r,l,h,i){if(t==null)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,l,h,i)}static binarySearch(t,e,s=1){let n=0,r=t.length/s-2;if(r==0)return s;let l=r>>>1;for(;;){if(t[(l+1)*s]<=e?n=l+1:r=l,n==r)return(n+1)*s;l=n+r>>>1}}static linearSearch(t,e,s){for(let n=0,r=t.length-s;n<=r;n+=s)if(t[n]>e)return n;return-1}};var nm=(f=>(f[f.rotate=0]="rotate",f[f.translate=1]="translate",f[f.scale=2]="scale",f[f.shear=3]="shear",f[f.attachment=4]="attachment",f[f.color=5]="color",f[f.deform=6]="deform",f[f.event=7]="event",f[f.drawOrder=8]="drawOrder",f[f.ikConstraint=9]="ikConstraint",f[f.transformConstraint=10]="transformConstraint",f[f.pathConstraintPosition=11]="pathConstraintPosition",f[f.pathConstraintSpacing=12]="pathConstraintSpacing",f[f.pathConstraintMix=13]="pathConstraintMix",f[f.twoColor=14]="twoColor",f))(nm||{});const Go=class qe{constructor(t){if(tt(this,"curves"),t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=It.newFloatArray((t-1)*qe.BEZIER_SIZE)}getFrameCount(){return this.curves.length/qe.BEZIER_SIZE+1}setLinear(t){this.curves[t*qe.BEZIER_SIZE]=qe.LINEAR}setStepped(t){this.curves[t*qe.BEZIER_SIZE]=qe.STEPPED}getCurveType(t){const e=t*qe.BEZIER_SIZE;if(e==this.curves.length)return qe.LINEAR;const s=this.curves[e];return s==qe.LINEAR?qe.LINEAR:s==qe.STEPPED?qe.STEPPED:qe.BEZIER}setCurve(t,e,s,n,r){const l=(-e*2+n)*.03,h=(-s*2+r)*.03,i=((e-n)*3+1)*.006,a=((s-r)*3+1)*.006;let o=l*2+i,d=h*2+a,u=e*.3+l+i*.16666667,m=s*.3+h+a*.16666667,c=t*qe.BEZIER_SIZE;const g=this.curves;g[c++]=qe.BEZIER;let p=u,y=m;for(let w=c+qe.BEZIER_SIZE-1;c<w;c+=2)g[c]=p,g[c+1]=y,u+=o,m+=d,o+=i,d+=a,p+=u,y+=m}getCurvePercent(t,e){e=rt.clamp(e,0,1);const s=this.curves;let n=t*qe.BEZIER_SIZE;const r=s[n];if(r==qe.LINEAR)return e;if(r==qe.STEPPED)return 0;n++;let l=0;for(let i=n,a=n+qe.BEZIER_SIZE-1;n<a;n+=2)if(l=s[n],l>=e){let o,d;return n==i?(o=0,d=0):(o=s[n-2],d=s[n-1]),d+(s[n+1]-d)*(e-o)/(l-o)}const h=s[n-1];return h+(1-h)*(e-l)/(1-l)}};tt(Go,"LINEAR",0),tt(Go,"STEPPED",1),tt(Go,"BEZIER",2),tt(Go,"BEZIER_SIZE",10*2-1);let Br=Go;const Ho=class ca extends Br{constructor(t){super(t),tt(this,"boneIndex"),tt(this,"frames"),this.frames=It.newFloatArray(t<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+ca.ROTATION]=s}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.bones[this.boneIndex];if(s<i[0]){switch(l){case at.setup:a.rotation=a.data.rotation;return;case at.first:const g=a.data.rotation-a.rotation;a.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*r}return}if(s>=i[i.length-ca.ENTRIES]){let g=i[i.length+ca.PREV_ROTATION];switch(l){case at.setup:a.rotation=a.data.rotation+g*r;break;case at.first:case at.replace:g+=a.data.rotation-a.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case at.add:a.rotation+=g*r}return}const o=es.binarySearch(i,s,ca.ENTRIES),d=i[o+ca.PREV_ROTATION],u=i[o],m=this.getCurvePercent((o>>1)-1,1-(s-u)/(i[o+ca.PREV_TIME]-u));let c=i[o+ca.ROTATION]-d;switch(c=d+(c-(16384-(16384.499999999996-c/360|0))*360)*m,l){case at.setup:a.rotation=a.data.rotation+(c-(16384-(16384.499999999996-c/360|0))*360)*r;break;case at.first:case at.replace:c+=a.data.rotation-a.rotation;case at.add:a.rotation+=(c-(16384-(16384.499999999996-c/360|0))*360)*r}}};tt(Ho,"ENTRIES",2),tt(Ho,"PREV_TIME",-2),tt(Ho,"PREV_ROTATION",-1),tt(Ho,"ROTATION",1);let Gn=Ho;const va=class rn extends Br{constructor(t){super(t),tt(this,"boneIndex"),tt(this,"frames"),this.frames=It.newFloatArray(t*rn.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,e,s,n){t*=rn.ENTRIES,this.frames[t]=e,this.frames[t+rn.X]=s,this.frames[t+rn.Y]=n}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.bones[this.boneIndex];if(s<i[0]){switch(l){case at.setup:a.x=a.data.x,a.y=a.data.y;return;case at.first:a.x+=(a.data.x-a.x)*r,a.y+=(a.data.y-a.y)*r}return}let o=0,d=0;if(s>=i[i.length-rn.ENTRIES])o=i[i.length+rn.PREV_X],d=i[i.length+rn.PREV_Y];else{const u=es.binarySearch(i,s,rn.ENTRIES);o=i[u+rn.PREV_X],d=i[u+rn.PREV_Y];const m=i[u],c=this.getCurvePercent(u/rn.ENTRIES-1,1-(s-m)/(i[u+rn.PREV_TIME]-m));o+=(i[u+rn.X]-o)*c,d+=(i[u+rn.Y]-d)*c}switch(l){case at.setup:a.x=a.data.x+o*r,a.y=a.data.y+d*r;break;case at.first:case at.replace:a.x+=(a.data.x+o-a.x)*r,a.y+=(a.data.y+d-a.y)*r;break;case at.add:a.x+=o*r,a.y+=d*r}}};tt(va,"ENTRIES",3),tt(va,"PREV_TIME",-3),tt(va,"PREV_X",-2),tt(va,"PREV_Y",-1),tt(va,"X",1),tt(va,"Y",2);let Ko=va,rm=class Tr extends Ko{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.bones[this.boneIndex];if(s<i[0]){switch(l){case at.setup:a.scaleX=a.data.scaleX,a.scaleY=a.data.scaleY;return;case at.first:a.scaleX+=(a.data.scaleX-a.scaleX)*r,a.scaleY+=(a.data.scaleY-a.scaleY)*r}return}let o=0,d=0;if(s>=i[i.length-Tr.ENTRIES])o=i[i.length+Tr.PREV_X]*a.data.scaleX,d=i[i.length+Tr.PREV_Y]*a.data.scaleY;else{const u=es.binarySearch(i,s,Tr.ENTRIES);o=i[u+Tr.PREV_X],d=i[u+Tr.PREV_Y];const m=i[u],c=this.getCurvePercent(u/Tr.ENTRIES-1,1-(s-m)/(i[u+Tr.PREV_TIME]-m));o=(o+(i[u+Tr.X]-o)*c)*a.data.scaleX,d=(d+(i[u+Tr.Y]-d)*c)*a.data.scaleY}if(r==1)l==at.add?(a.scaleX+=o-a.data.scaleX,a.scaleY+=d-a.data.scaleY):(a.scaleX=o,a.scaleY=d);else{let u=0,m=0;if(h==Qs.mixOut)switch(l){case at.setup:u=a.data.scaleX,m=a.data.scaleY,a.scaleX=u+(Math.abs(o)*rt.signum(u)-u)*r,a.scaleY=m+(Math.abs(d)*rt.signum(m)-m)*r;break;case at.first:case at.replace:u=a.scaleX,m=a.scaleY,a.scaleX=u+(Math.abs(o)*rt.signum(u)-u)*r,a.scaleY=m+(Math.abs(d)*rt.signum(m)-m)*r;break;case at.add:u=a.scaleX,m=a.scaleY,a.scaleX=u+(Math.abs(o)*rt.signum(u)-a.data.scaleX)*r,a.scaleY=m+(Math.abs(d)*rt.signum(m)-a.data.scaleY)*r}else switch(l){case at.setup:u=Math.abs(a.data.scaleX)*rt.signum(o),m=Math.abs(a.data.scaleY)*rt.signum(d),a.scaleX=u+(o-u)*r,a.scaleY=m+(d-m)*r;break;case at.first:case at.replace:u=Math.abs(a.scaleX)*rt.signum(o),m=Math.abs(a.scaleY)*rt.signum(d),a.scaleX=u+(o-u)*r,a.scaleY=m+(d-m)*r;break;case at.add:u=rt.signum(o),m=rt.signum(d),a.scaleX=Math.abs(a.scaleX)*u+(o-Math.abs(a.data.scaleX)*u)*r,a.scaleY=Math.abs(a.scaleY)*m+(d-Math.abs(a.data.scaleY)*m)*r}}}},im=class Er extends Ko{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.bones[this.boneIndex];if(s<i[0]){switch(l){case at.setup:a.shearX=a.data.shearX,a.shearY=a.data.shearY;return;case at.first:a.shearX+=(a.data.shearX-a.shearX)*r,a.shearY+=(a.data.shearY-a.shearY)*r}return}let o=0,d=0;if(s>=i[i.length-Er.ENTRIES])o=i[i.length+Er.PREV_X],d=i[i.length+Er.PREV_Y];else{const u=es.binarySearch(i,s,Er.ENTRIES);o=i[u+Er.PREV_X],d=i[u+Er.PREV_Y];const m=i[u],c=this.getCurvePercent(u/Er.ENTRIES-1,1-(s-m)/(i[u+Er.PREV_TIME]-m));o=o+(i[u+Er.X]-o)*c,d=d+(i[u+Er.Y]-d)*c}switch(l){case at.setup:a.shearX=a.data.shearX+o*r,a.shearY=a.data.shearY+d*r;break;case at.first:case at.replace:a.shearX+=(a.data.shearX+o-a.shearX)*r,a.shearY+=(a.data.shearY+d-a.shearY)*r;break;case at.add:a.shearX+=o*r,a.shearY+=d*r}}};const Hn=class Ce extends Br{constructor(t){super(t),tt(this,"slotIndex"),tt(this,"frames"),this.frames=It.newFloatArray(t*Ce.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,e,s,n,r,l){t*=Ce.ENTRIES,this.frames[t]=e,this.frames[t+Ce.R]=s,this.frames[t+Ce.G]=n,this.frames[t+Ce.B]=r,this.frames[t+Ce.A]=l}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex],a=this.frames;if(s<a[0]){switch(l){case at.setup:i.color.setFromColor(i.data.color);return;case at.first:const c=i.color,g=i.data.color;c.add((g.r-c.r)*r,(g.g-c.g)*r,(g.b-c.b)*r,(g.a-c.a)*r)}return}let o=0,d=0,u=0,m=0;if(s>=a[a.length-Ce.ENTRIES]){const c=a.length;o=a[c+Ce.PREV_R],d=a[c+Ce.PREV_G],u=a[c+Ce.PREV_B],m=a[c+Ce.PREV_A]}else{const c=es.binarySearch(a,s,Ce.ENTRIES);o=a[c+Ce.PREV_R],d=a[c+Ce.PREV_G],u=a[c+Ce.PREV_B],m=a[c+Ce.PREV_A];const g=a[c],p=this.getCurvePercent(c/Ce.ENTRIES-1,1-(s-g)/(a[c+Ce.PREV_TIME]-g));o+=(a[c+Ce.R]-o)*p,d+=(a[c+Ce.G]-d)*p,u+=(a[c+Ce.B]-u)*p,m+=(a[c+Ce.A]-m)*p}if(r==1)i.color.set(o,d,u,m);else{const c=i.color;l==at.setup&&c.setFromColor(i.data.color),c.add((o-c.r)*r,(d-c.g)*r,(u-c.b)*r,(m-c.a)*r)}}};tt(Hn,"ENTRIES",5),tt(Hn,"PREV_TIME",-5),tt(Hn,"PREV_R",-4),tt(Hn,"PREV_G",-3),tt(Hn,"PREV_B",-2),tt(Hn,"PREV_A",-1),tt(Hn,"R",1),tt(Hn,"G",2),tt(Hn,"B",3),tt(Hn,"A",4);let Hh=Hn;const As=class te extends Br{constructor(t){super(t),tt(this,"slotIndex"),tt(this,"frames"),this.frames=It.newFloatArray(t*te.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,s,n,r,l,h,i,a){t*=te.ENTRIES,this.frames[t]=e,this.frames[t+te.R]=s,this.frames[t+te.G]=n,this.frames[t+te.B]=r,this.frames[t+te.A]=l,this.frames[t+te.R2]=h,this.frames[t+te.G2]=i,this.frames[t+te.B2]=a}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex],a=this.frames;if(s<a[0]){switch(l){case at.setup:i.color.setFromColor(i.data.color),i.darkColor.setFromColor(i.data.darkColor);return;case at.first:const y=i.color,w=i.darkColor,x=i.data.color,b=i.data.darkColor;y.add((x.r-y.r)*r,(x.g-y.g)*r,(x.b-y.b)*r,(x.a-y.a)*r),w.add((b.r-w.r)*r,(b.g-w.g)*r,(b.b-w.b)*r,0)}return}let o=0,d=0,u=0,m=0,c=0,g=0,p=0;if(s>=a[a.length-te.ENTRIES]){const y=a.length;o=a[y+te.PREV_R],d=a[y+te.PREV_G],u=a[y+te.PREV_B],m=a[y+te.PREV_A],c=a[y+te.PREV_R2],g=a[y+te.PREV_G2],p=a[y+te.PREV_B2]}else{const y=es.binarySearch(a,s,te.ENTRIES);o=a[y+te.PREV_R],d=a[y+te.PREV_G],u=a[y+te.PREV_B],m=a[y+te.PREV_A],c=a[y+te.PREV_R2],g=a[y+te.PREV_G2],p=a[y+te.PREV_B2];const w=a[y],x=this.getCurvePercent(y/te.ENTRIES-1,1-(s-w)/(a[y+te.PREV_TIME]-w));o+=(a[y+te.R]-o)*x,d+=(a[y+te.G]-d)*x,u+=(a[y+te.B]-u)*x,m+=(a[y+te.A]-m)*x,c+=(a[y+te.R2]-c)*x,g+=(a[y+te.G2]-g)*x,p+=(a[y+te.B2]-p)*x}if(r==1)i.color.set(o,d,u,m),i.darkColor.set(c,g,p,1);else{const y=i.color,w=i.darkColor;l==at.setup&&(y.setFromColor(i.data.color),w.setFromColor(i.data.darkColor)),y.add((o-y.r)*r,(d-y.g)*r,(u-y.b)*r,(m-y.a)*r),w.add((c-w.r)*r,(g-w.g)*r,(p-w.b)*r,0)}}};tt(As,"ENTRIES",8),tt(As,"PREV_TIME",-8),tt(As,"PREV_R",-7),tt(As,"PREV_G",-6),tt(As,"PREV_B",-5),tt(As,"PREV_A",-4),tt(As,"PREV_R2",-3),tt(As,"PREV_G2",-2),tt(As,"PREV_B2",-1),tt(As,"R",1),tt(As,"G",2),tt(As,"B",3),tt(As,"A",4),tt(As,"R2",5),tt(As,"G2",6),tt(As,"B2",7);let Kh=As,sh=class{constructor(t){tt(this,"slotIndex"),tt(this,"frames"),tt(this,"attachmentNames"),this.frames=It.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(h==Qs.mixOut&&l==at.setup){const u=i.data.attachmentName;i.setAttachment(u==null?null:t.getAttachment(this.slotIndex,u));return}const a=this.frames;if(s<a[0]){if(l==at.setup||l==at.first){const u=i.data.attachmentName;i.setAttachment(u==null?null:t.getAttachment(this.slotIndex,u))}return}let o=0;s>=a[a.length-1]?o=a.length-1:o=es.binarySearch(a,s,1)-1;const d=this.attachmentNames[o];t.slots[this.slotIndex].setAttachment(d==null?null:t.getAttachment(this.slotIndex,d))}},am=null,om=class extends Br{constructor(t){super(t),tt(this,"slotIndex"),tt(this,"attachment"),tt(this,"frames"),tt(this,"frameVertices"),this.frames=It.newFloatArray(t),this.frameVertices=new Array(t),am==null&&(am=It.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,s){this.frames[t]=e,this.frameVertices[t]=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex],a=i.getAttachment();if(!(a instanceof Sa)||!a.applyDeform(this.attachment))return;const o=i.attachmentVertices;o.length==0&&(l=at.setup);const d=this.frameVertices,u=d[0].length,m=this.frames;if(s<m[0]){const b=a;switch(l){case at.setup:o.length=0;return;case at.first:if(r==1){o.length=0;break}const S=It.setArraySize(o,u);if(b.bones==null){const C=b.vertices;for(let v=0;v<u;v++)S[v]+=(C[v]-S[v])*r}else{r=1-r;for(let C=0;C<u;C++)S[C]*=r}}return}const c=It.setArraySize(o,u);if(s>=m[m.length-1]){const b=d[m.length-1];if(r==1)if(l==at.add){const S=a;if(S.bones==null){const C=S.vertices;for(let v=0;v<u;v++)c[v]+=b[v]-C[v]}else for(let C=0;C<u;C++)c[C]+=b[C]}else It.arrayCopy(b,0,c,0,u);else switch(l){case at.setup:{const C=a;if(C.bones==null){const v=C.vertices;for(let A=0;A<u;A++){const M=v[A];c[A]=M+(b[A]-M)*r}}else for(let v=0;v<u;v++)c[v]=b[v]*r;break}case at.first:case at.replace:for(let C=0;C<u;C++)c[C]+=(b[C]-c[C])*r;case at.add:const S=a;if(S.bones==null){const C=S.vertices;for(let v=0;v<u;v++)c[v]+=(b[v]-C[v])*r}else for(let C=0;C<u;C++)c[C]+=b[C]*r}return}const g=es.binarySearch(m,s),p=d[g-1],y=d[g],w=m[g],x=this.getCurvePercent(g-1,1-(s-w)/(m[g-1]-w));if(r==1)if(l==at.add){const b=a;if(b.bones==null){const S=b.vertices;for(let C=0;C<u;C++){const v=p[C];c[C]+=v+(y[C]-v)*x-S[C]}}else for(let S=0;S<u;S++){const C=p[S];c[S]+=C+(y[S]-C)*x}}else for(let b=0;b<u;b++){const S=p[b];c[b]=S+(y[b]-S)*x}else switch(l){case at.setup:{const S=a;if(S.bones==null){const C=S.vertices;for(let v=0;v<u;v++){const A=p[v],M=C[v];c[v]=M+(A+(y[v]-A)*x-M)*r}}else for(let C=0;C<u;C++){const v=p[C];c[C]=(v+(y[C]-v)*x)*r}break}case at.first:case at.replace:for(let S=0;S<u;S++){const C=p[S];c[S]+=(C+(y[S]-C)*x-c[S])*r}break;case at.add:const b=a;if(b.bones==null){const S=b.vertices;for(let C=0;C<u;C++){const v=p[C];c[C]+=(v+(y[C]-v)*x-S[C])*r}}else for(let S=0;S<u;S++){const C=p[S];c[S]+=(C+(y[S]-C)*x)*r}}}},lm=class{constructor(t){tt(this,"frames"),tt(this,"events"),this.frames=It.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,l,h){if(n==null)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,l,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=es.binarySearch(i,e);const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}},nh=class{constructor(t){tt(this,"frames"),tt(this,"drawOrders"),this.frames=It.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,l,h){const i=t.drawOrder,a=t.slots;if(h==Qs.mixOut&&l==at.setup){It.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const o=this.frames;if(s<o[0]){(l==at.setup||l==at.first)&&It.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let d=0;s>=o[o.length-1]?d=o.length-1:d=es.binarySearch(o,s)-1;const u=this.drawOrders[d];if(u==null)It.arrayCopy(a,0,i,0,a.length);else for(let m=0,c=u.length;m<c;m++)i[m]=a[u[m]]}};const Kn=class fe extends Br{constructor(t){super(t),tt(this,"ikConstraintIndex"),tt(this,"frames"),this.frames=It.newFloatArray(t*fe.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,e,s,n,r,l){t*=fe.ENTRIES,this.frames[t]=e,this.frames[t+fe.MIX]=s,this.frames[t+fe.BEND_DIRECTION]=n,this.frames[t+fe.COMPRESS]=r?1:0,this.frames[t+fe.STRETCH]=l?1:0}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.ikConstraints[this.ikConstraintIndex];if(s<i[0]){switch(l){case at.setup:a.mix=a.data.mix,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case at.first:a.mix+=(a.data.mix-a.mix)*r,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(s>=i[i.length-fe.ENTRIES]){l==at.setup?(a.mix=a.data.mix+(i[i.length+fe.PREV_MIX]-a.data.mix)*r,h==Qs.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=i[i.length+fe.PREV_BEND_DIRECTION],a.compress=i[i.length+fe.PREV_COMPRESS]!=0,a.stretch=i[i.length+fe.PREV_STRETCH]!=0)):(a.mix+=(i[i.length+fe.PREV_MIX]-a.mix)*r,h==Qs.mixIn&&(a.bendDirection=i[i.length+fe.PREV_BEND_DIRECTION],a.compress=i[i.length+fe.PREV_COMPRESS]!=0,a.stretch=i[i.length+fe.PREV_STRETCH]!=0));return}const o=es.binarySearch(i,s,fe.ENTRIES),d=i[o+fe.PREV_MIX],u=i[o],m=this.getCurvePercent(o/fe.ENTRIES-1,1-(s-u)/(i[o+fe.PREV_TIME]-u));l==at.setup?(a.mix=a.data.mix+(d+(i[o+fe.MIX]-d)*m-a.data.mix)*r,h==Qs.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=i[o+fe.PREV_BEND_DIRECTION],a.compress=i[o+fe.PREV_COMPRESS]!=0,a.stretch=i[o+fe.PREV_STRETCH]!=0)):(a.mix+=(d+(i[o+fe.MIX]-d)*m-a.mix)*r,h==Qs.mixIn&&(a.bendDirection=i[o+fe.PREV_BEND_DIRECTION],a.compress=i[o+fe.PREV_COMPRESS]!=0,a.stretch=i[o+fe.PREV_STRETCH]!=0))}};tt(Kn,"ENTRIES",5),tt(Kn,"PREV_TIME",-5),tt(Kn,"PREV_MIX",-4),tt(Kn,"PREV_BEND_DIRECTION",-3),tt(Kn,"PREV_COMPRESS",-2),tt(Kn,"PREV_STRETCH",-1),tt(Kn,"MIX",1),tt(Kn,"BEND_DIRECTION",2),tt(Kn,"COMPRESS",3),tt(Kn,"STRETCH",4);let Zh=Kn;const Zn=class ve extends Br{constructor(t){super(t),tt(this,"transformConstraintIndex"),tt(this,"frames"),this.frames=It.newFloatArray(t*ve.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,e,s,n,r,l){t*=ve.ENTRIES,this.frames[t]=e,this.frames[t+ve.ROTATE]=s,this.frames[t+ve.TRANSLATE]=n,this.frames[t+ve.SCALE]=r,this.frames[t+ve.SHEAR]=l}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.transformConstraints[this.transformConstraintIndex];if(s<i[0]){const c=a.data;switch(l){case at.setup:a.rotateMix=c.rotateMix,a.translateMix=c.translateMix,a.scaleMix=c.scaleMix,a.shearMix=c.shearMix;return;case at.first:a.rotateMix+=(c.rotateMix-a.rotateMix)*r,a.translateMix+=(c.translateMix-a.translateMix)*r,a.scaleMix+=(c.scaleMix-a.scaleMix)*r,a.shearMix+=(c.shearMix-a.shearMix)*r}return}let o=0,d=0,u=0,m=0;if(s>=i[i.length-ve.ENTRIES]){const c=i.length;o=i[c+ve.PREV_ROTATE],d=i[c+ve.PREV_TRANSLATE],u=i[c+ve.PREV_SCALE],m=i[c+ve.PREV_SHEAR]}else{const c=es.binarySearch(i,s,ve.ENTRIES);o=i[c+ve.PREV_ROTATE],d=i[c+ve.PREV_TRANSLATE],u=i[c+ve.PREV_SCALE],m=i[c+ve.PREV_SHEAR];const g=i[c],p=this.getCurvePercent(c/ve.ENTRIES-1,1-(s-g)/(i[c+ve.PREV_TIME]-g));o+=(i[c+ve.ROTATE]-o)*p,d+=(i[c+ve.TRANSLATE]-d)*p,u+=(i[c+ve.SCALE]-u)*p,m+=(i[c+ve.SHEAR]-m)*p}if(l==at.setup){const c=a.data;a.rotateMix=c.rotateMix+(o-c.rotateMix)*r,a.translateMix=c.translateMix+(d-c.translateMix)*r,a.scaleMix=c.scaleMix+(u-c.scaleMix)*r,a.shearMix=c.shearMix+(m-c.shearMix)*r}else a.rotateMix+=(o-a.rotateMix)*r,a.translateMix+=(d-a.translateMix)*r,a.scaleMix+=(u-a.scaleMix)*r,a.shearMix+=(m-a.shearMix)*r}};tt(Zn,"ENTRIES",5),tt(Zn,"PREV_TIME",-5),tt(Zn,"PREV_ROTATE",-4),tt(Zn,"PREV_TRANSLATE",-3),tt(Zn,"PREV_SCALE",-2),tt(Zn,"PREV_SHEAR",-1),tt(Zn,"ROTATE",1),tt(Zn,"TRANSLATE",2),tt(Zn,"SCALE",3),tt(Zn,"SHEAR",4);let Jh=Zn;const Zo=class Ir extends Br{constructor(t){super(t),tt(this,"pathConstraintIndex"),tt(this,"frames"),this.frames=It.newFloatArray(t*Ir.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,e,s){t*=Ir.ENTRIES,this.frames[t]=e,this.frames[t+Ir.VALUE]=s}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(s<i[0]){switch(l){case at.setup:a.position=a.data.position;return;case at.first:a.position+=(a.data.position-a.position)*r}return}let o=0;if(s>=i[i.length-Ir.ENTRIES])o=i[i.length+Ir.PREV_VALUE];else{const d=es.binarySearch(i,s,Ir.ENTRIES);o=i[d+Ir.PREV_VALUE];const u=i[d],m=this.getCurvePercent(d/Ir.ENTRIES-1,1-(s-u)/(i[d+Ir.PREV_TIME]-u));o+=(i[d+Ir.VALUE]-o)*m}l==at.setup?a.position=a.data.position+(o-a.data.position)*r:a.position+=(o-a.position)*r}};tt(Zo,"ENTRIES",2),tt(Zo,"PREV_TIME",-2),tt(Zo,"PREV_VALUE",-1),tt(Zo,"VALUE",1);let rh=Zo,hm=class da extends rh{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(s<i[0]){switch(l){case at.setup:a.spacing=a.data.spacing;return;case at.first:a.spacing+=(a.data.spacing-a.spacing)*r}return}let o=0;if(s>=i[i.length-da.ENTRIES])o=i[i.length+da.PREV_VALUE];else{const d=es.binarySearch(i,s,da.ENTRIES);o=i[d+da.PREV_VALUE];const u=i[d],m=this.getCurvePercent(d/da.ENTRIES-1,1-(s-u)/(i[d+da.PREV_TIME]-u));o+=(i[d+da.VALUE]-o)*m}l==at.setup?a.spacing=a.data.spacing+(o-a.data.spacing)*r:a.spacing+=(o-a.spacing)*r}};const Aa=class an extends Br{constructor(t){super(t),tt(this,"pathConstraintIndex"),tt(this,"frames"),this.frames=It.newFloatArray(t*an.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,e,s,n){t*=an.ENTRIES,this.frames[t]=e,this.frames[t+an.ROTATE]=s,this.frames[t+an.TRANSLATE]=n}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(s<i[0]){switch(l){case at.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case at.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*r,a.translateMix+=(a.data.translateMix-a.translateMix)*r}return}let o=0,d=0;if(s>=i[i.length-an.ENTRIES])o=i[i.length+an.PREV_ROTATE],d=i[i.length+an.PREV_TRANSLATE];else{const u=es.binarySearch(i,s,an.ENTRIES);o=i[u+an.PREV_ROTATE],d=i[u+an.PREV_TRANSLATE];const m=i[u],c=this.getCurvePercent(u/an.ENTRIES-1,1-(s-m)/(i[u+an.PREV_TIME]-m));o+=(i[u+an.ROTATE]-o)*c,d+=(i[u+an.TRANSLATE]-d)*c}l==at.setup?(a.rotateMix=a.data.rotateMix+(o-a.data.rotateMix)*r,a.translateMix=a.data.translateMix+(d-a.data.translateMix)*r):(a.rotateMix+=(o-a.rotateMix)*r,a.translateMix+=(d-a.translateMix)*r)}};tt(Aa,"ENTRIES",3),tt(Aa,"PREV_TIME",-3),tt(Aa,"PREV_ROTATE",-2),tt(Aa,"PREV_TRANSLATE",-1),tt(Aa,"ROTATE",1),tt(Aa,"TRANSLATE",2);let Qh=Aa;var gw=Object.defineProperty,pw=(f,t,e)=>t in f?gw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ft=(f,t,e)=>pw(f,typeof t!="symbol"?t+"":t,e);const ti=class xs{constructor(t){ft(this,"data"),ft(this,"tracks",new Array),ft(this,"events",new Array),ft(this,"listeners",new Array),ft(this,"queue",new fm(this)),ft(this,"propertyIDs",new Gb),ft(this,"animationsChanged",!1),ft(this,"timeScale",1),ft(this,"trackEntryPool",new Zf(()=>new dm)),ft(this,"onComplete"),ft(this,"onEvent"),ft(this,"onStart"),ft(this,"onEnd"),this.data=t}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r==null)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let l=t*r.timeScale;if(r.delay>0){if(r.delay-=l,r.delay>0)continue;l=-r.delay,r.delay=0}let h=r.next;if(h!=null){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=l,this.setCurrent(s,h,!0);h.mixingFrom!=null;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&r.mixingFrom==null){e[s]=null,this.queue.end(r),this.disposeNext(r);continue}if(r.mixingFrom!=null&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i!=null&&(i.mixingTo=null);i!=null;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=l}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(s==null)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom!=null&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(t==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let r=0,l=s.length;r<l;r++){const h=s[r];if(h==null||h.delay>0)continue;n=!0;const i=r==0?at.first:h.mixBlend;let a=h.alpha;h.mixingFrom!=null?a*=this.applyMixingFrom(h,t,i):h.trackTime>=h.trackEnd&&h.next==null&&(a=0);const o=h.animationLast,d=h.getAnimationTime(),u=h.animation.timelines.length,m=h.animation.timelines;if(r==0&&a==1||i==at.add)for(let c=0;c<u;c++)It.webkit602BugfixHelper(a,i),m[c].apply(t,o,d,e,a,i,Qs.mixIn);else{const c=h.timelineMode,g=h.timelinesRotation.length==0;g&&It.setArraySize(h.timelinesRotation,u<<1,null);const p=h.timelinesRotation;for(let y=0;y<u;y++){const w=m[y],x=c[y]==xs.SUBSEQUENT?i:at.setup;w instanceof Gn?this.applyRotateTimeline(w,t,d,a,x,p,y<<1,g):(It.webkit602BugfixHelper(a,i),w.apply(t,o,d,e,a,x,Qs.mixIn))}}this.queueEvents(h,d),e.length=0,h.nextAnimationLast=d,h.nextTrackLast=h.trackTime}return this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom!=null&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==at.first&&(s=at.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=at.first&&(s=n.mixBlend));const l=r<n.eventThreshold?this.events:null,h=r<n.attachmentThreshold,i=r<n.drawOrderThreshold,a=n.animationLast,o=n.getAnimationTime(),d=n.animation.timelines.length,u=n.animation.timelines,m=n.alpha*t.interruptAlpha,c=m*(1-r);if(s==at.add)for(let g=0;g<d;g++)u[g].apply(e,a,o,l,c,s,Qs.mixOut);else{const g=n.timelineMode,p=n.timelineHoldMix,y=n.timelinesRotation.length==0;y&&It.setArraySize(n.timelinesRotation,d<<1,null);const w=n.timelinesRotation;n.totalAlpha=0;for(let x=0;x<d;x++){const b=u[x];let S=Qs.mixOut,C,v=0;switch(g[x]){case xs.SUBSEQUENT:if(!h&&b instanceof sh||!i&&b instanceof nh)continue;C=s,v=c;break;case xs.FIRST:C=at.setup,v=c;break;case xs.HOLD:C=at.setup,v=m;break;default:C=at.setup;const A=p[x];v=m*Math.max(0,1-A.mixTime/A.mixDuration);break}n.totalAlpha+=v,b instanceof Gn?this.applyRotateTimeline(b,e,o,v,C,w,x<<1,y):(It.webkit602BugfixHelper(v,s),C==at.setup&&(b instanceof sh?h&&(S=Qs.mixOut):b instanceof nh&&i&&(S=Qs.mixOut)),b.apply(e,a,o,l,v,C,S))}}return t.mixDuration>0&&this.queueEvents(n,o),this.events.length=0,n.nextAnimationLast=o,n.nextTrackLast=n.trackTime,r}applyRotateTimeline(t,e,s,n,r,l,h,i){if(i&&(l[h]=0),n==1){t.apply(e,0,s,null,1,r,Qs.mixIn);return}const a=t,o=a.frames,d=e.bones[a.boneIndex];let u=0,m=0;if(s<o[0])switch(r){case at.setup:d.rotation=d.data.rotation;default:return;case at.first:u=d.rotation,m=d.data.rotation}else if(u=r==at.setup?d.data.rotation:d.rotation,s>=o[o.length-Gn.ENTRIES])m=d.data.rotation+o[o.length+Gn.PREV_ROTATION];else{const p=es.binarySearch(o,s,Gn.ENTRIES),y=o[p+Gn.PREV_ROTATION],w=o[p],x=a.getCurvePercent((p>>1)-1,1-(s-w)/(o[p+Gn.PREV_TIME]-w));m=o[p+Gn.ROTATION]-y,m-=(16384-(16384.499999999996-m/360|0))*360,m=y+m*x+d.data.rotation,m-=(16384-(16384.499999999996-m/360|0))*360}let c=0,g=m-u;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)c=l[h];else{let p=0,y=0;i?(p=0,y=g):(p=l[h],y=l[h+1]);const w=g>0;let x=p>=0;rt.signum(y)!=rt.signum(g)&&Math.abs(y)<=90&&(Math.abs(p)>180&&(p+=360*rt.signum(p)),x=w),c=g+p-p%360,x!=w&&(c+=360*rt.signum(p)),l[h]=c}l[h+1]=g,u+=c*n,d.rotation=u-(16384-(16384.499999999996-u/360|0))*360}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,l=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<l)break;d.time>n||this.queue.event(t,d)}let o=!1;for(t.loop?o=r==0||l>t.trackTime%r:o=e>=n&&t.animationLast<n,o&&this.queue.complete(t);i<a;i++)h[i].time<s||this.queue.event(t,h[i])}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(e==null)return;this.queue.end(e),this.disposeNext(e);let s=e;for(;;){const n=s.mixingFrom;if(n==null)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,n!=null&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom!=null&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s){const n=this.data.skeletonData.findAnimation(e);if(n==null)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s){if(e==null)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r!=null&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.disposeNext(r),r=r.mixingFrom,n=!1):this.disposeNext(r));const l=this.trackEntry(t,e,s,r);return this.setCurrent(t,l,n),this.queue.drain(),l}addAnimation(t,e,s,n){const r=this.data.skeletonData.findAnimation(e);if(r==null)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s,n){if(e==null)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r!=null)for(;r.next!=null;)r=r.next;const l=this.trackEntry(t,e,s,r);if(r==null)this.setCurrent(t,l,!0),this.queue.drain();else if(r.next=l,n<=0){const h=r.animationEnd-r.animationStart;h!=0?(r.loop?n+=h*(1+(r.trackTime/h|0)):n+=Math.max(h,r.trackTime),n-=this.data.getMix(r.animation,e)):n=r.trackTime}return l.delay=n,l}setEmptyAnimation(t,e){const s=this.setAnimationWith(t,xs.emptyAnimation,!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e,s){s<=0&&(s-=e);const n=this.addAnimationWith(t,xs.emptyAnimation,!1,s);return n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r!=null&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(It.ensureArrayCapacity(this.tracks,t-this.tracks.length+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=n==null?0:this.data.getMix(n.animation,e),r}disposeNext(t){let e=t.next;for(;e!=null;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,e=this.tracks.length;t<e;t++){let s=this.tracks[t];if(s!=null){for(;s.mixingFrom!=null;)s=s.mixingFrom;do(s.mixingFrom==null||s.mixBlend!=at.add)&&this.setTimelineModes(s),s=s.mixingTo;while(s!=null)}}}setTimelineModes(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=It.setArraySize(t.timelineMode,n);t.timelineHoldMix.length=0;const l=It.setArraySize(t.timelineHoldMix,n),h=this.propertyIDs;if(e!=null&&e.holdPrevious){for(let i=0;i<n;i++)h.add(s[i].getPropertyId()),r[i]=xs.HOLD;return}t:for(let i=0;i<n;i++){const a=s[i].getPropertyId();if(!h.add(a))r[i]=xs.SUBSEQUENT;else if(e==null||!this.hasTimeline(e,a))r[i]=xs.FIRST;else{for(let o=e.mixingTo;o!=null;o=o.mixingTo)if(!this.hasTimeline(o,a)){if(t.mixDuration>0){r[i]=xs.HOLD_MIX,l[i]=o;continue t}break}r[i]=xs.HOLD}}}hasTimeline(t,e){const s=t.animation.timelines;for(let n=0,r=s.length;n<r;n++)if(s[n].getPropertyId()==e)return!0;return!1}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(t==null)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){xs.deprecatedWarning1||(xs.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){xs.deprecatedWarning2||(xs.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return xs.deprecatedWarning3||(xs.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};ft(ti,"emptyAnimation",new es("<empty>",[],0)),ft(ti,"SUBSEQUENT",0),ft(ti,"FIRST",1),ft(ti,"HOLD",2),ft(ti,"HOLD_MIX",3),ft(ti,"deprecatedWarning1",!1),ft(ti,"deprecatedWarning2",!1),ft(ti,"deprecatedWarning3",!1);let cm=ti;const jh=class Ti{constructor(){ft(this,"animation"),ft(this,"next"),ft(this,"mixingFrom"),ft(this,"mixingTo"),ft(this,"listener"),ft(this,"trackIndex"),ft(this,"loop"),ft(this,"holdPrevious"),ft(this,"eventThreshold"),ft(this,"attachmentThreshold"),ft(this,"drawOrderThreshold"),ft(this,"animationStart"),ft(this,"animationEnd"),ft(this,"animationLast"),ft(this,"nextAnimationLast"),ft(this,"delay"),ft(this,"trackTime"),ft(this,"trackLast"),ft(this,"nextTrackLast"),ft(this,"trackEnd"),ft(this,"timeScale"),ft(this,"alpha"),ft(this,"mixTime"),ft(this,"mixDuration"),ft(this,"interruptAlpha"),ft(this,"totalAlpha"),ft(this,"mixBlend",at.replace),ft(this,"timelineMode",new Array),ft(this,"timelineHoldMix",new Array),ft(this,"timelinesRotation",new Array),ft(this,"onComplete"),ft(this,"onEvent"),ft(this,"onStart"),ft(this,"onEnd")}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Ti.deprecatedWarning1||(Ti.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Ti.deprecatedWarning1||(Ti.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Ti.deprecatedWarning2||(Ti.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Ti.deprecatedWarning2||(Ti.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};ft(jh,"deprecatedWarning1",!1),ft(jh,"deprecatedWarning2",!1);let dm=jh;const um=class If{constructor(t){ft(this,"objects",[]),ft(this,"drainDisabled",!1),ft(this,"animState"),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}deprecateStuff(){return If.deprecatedWarning1||(If.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener!=null&&r.listener.start&&r.listener.start(r);for(let i=0;i<e.length;i++)e[i].start&&e[i].start(r);r.onStart&&this.deprecateStuff()&&r.onStart(r.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(r.trackIndex);break;case 1:r.listener!=null&&r.listener.interrupt&&r.listener.interrupt(r);for(let i=0;i<e.length;i++)e[i].interrupt&&e[i].interrupt(r);break;case 2:r.listener!=null&&r.listener.end&&r.listener.end(r);for(let i=0;i<e.length;i++)e[i].end&&e[i].end(r);r.onEnd&&this.deprecateStuff()&&r.onEnd(r.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(r.trackIndex);case 3:r.listener!=null&&r.listener.dispose&&r.listener.dispose(r);for(let i=0;i<e.length;i++)e[i].dispose&&e[i].dispose(r);this.animState.trackEntryPool.free(r);break;case 4:r.listener!=null&&r.listener.complete&&r.listener.complete(r);for(let i=0;i<e.length;i++)e[i].complete&&e[i].complete(r);const l=rt.toInt(r.loopsCount());r.onComplete&&this.deprecateStuff()&&r.onComplete(r.trackIndex,l),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(r.trackIndex,l);break;case 5:const h=t[s+++2];r.listener!=null&&r.listener.event&&r.listener.event(r,h);for(let i=0;i<e.length;i++)e[i].event&&e[i].event(r,h);r.onEvent&&this.deprecateStuff()&&r.onEvent(r.trackIndex,h),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(r.trackIndex,h);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};ft(um,"deprecatedWarning1",!1);let fm=um;var mm=(f=>(f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event",f))(mm||{});class xw{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}var bw=Object.defineProperty,ww=(f,t,e)=>t in f?bw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ih=(f,t,e)=>ww(f,typeof t!="symbol"?t+"":t,e);const gm=class kf{constructor(t){if(ih(this,"skeletonData"),ih(this,"animationToMixTime",{}),ih(this,"defaultMix",0),t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(r==null)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixByName(t,e,s){kf.deprecatedWarning1||(kf.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,e,s)}setMixWith(t,e,s){if(t==null)throw new Error("from cannot be null.");if(e==null)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};ih(gm,"deprecatedWarning1",!1);let pm=gm;var yw=Object.defineProperty,Sw=(f,t,e)=>t in f?yw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,xm=(f,t,e)=>Sw(f,typeof t!="symbol"?t+"":t,e);let bm=class extends Sa{constructor(t){super(t),xm(this,"type",un.BoundingBox),xm(this,"color",new Ls(1,1,1,1))}};var Cw=Object.defineProperty,vw=(f,t,e)=>t in f?Cw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,tc=(f,t,e)=>vw(f,typeof t!="symbol"?t+"":t,e);let wm=class extends Sa{constructor(t){super(t),tc(this,"type",un.Clipping),tc(this,"endSlot"),tc(this,"color",new Ls(.2275,.2275,.8078,1))}};var Aw=Object.defineProperty,Mw=(f,t,e)=>t in f?Aw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Jn=(f,t,e)=>Mw(f,typeof t!="symbol"?t+"":t,e);let ec=class extends Sa{constructor(t){super(t),Jn(this,"type",un.Mesh),Jn(this,"region"),Jn(this,"path"),Jn(this,"regionUVs"),Jn(this,"uvs"),Jn(this,"triangles"),Jn(this,"color",new Ls(1,1,1,1)),Jn(this,"hullLength"),Jn(this,"parentMesh"),Jn(this,"inheritDeform",!1),Jn(this,"tempColor",new Ls(0,0,0,0))}applyDeform(t){return this==t||this.inheritDeform&&this.parentMesh==t}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}};var Tw=Object.defineProperty,Ew=(f,t,e)=>t in f?Tw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Jo=(f,t,e)=>Ew(f,typeof t!="symbol"?t+"":t,e);let Qo=class extends Sa{constructor(t){super(t),Jo(this,"type",un.Path),Jo(this,"lengths"),Jo(this,"closed",!1),Jo(this,"constantSpeed",!1),Jo(this,"color",new Ls(1,1,1,1))}};var Iw=Object.defineProperty,kw=(f,t,e)=>t in f?Iw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,jo=(f,t,e)=>kw(f,typeof t!="symbol"?t+"":t,e);let ym=class extends Sa{constructor(t){super(t),jo(this,"type",un.Point),jo(this,"x"),jo(this,"y"),jo(this,"rotation"),jo(this,"color",new Ls(.38,.94,0,1))}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=rt.cosDeg(this.rotation),n=rt.sinDeg(this.rotation),r=s*e.a+n*e.c,l=s*e.b+n*e.d;return Math.atan2(l,r)*rt.radDeg}};var Pw=Object.defineProperty,Rw=(f,t,e)=>t in f?Pw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Yw=(f,t,e)=>Rw(f,typeof t!="symbol"?t+"":t,e);let Sm=class{constructor(t){Yw(this,"atlas"),this.atlas=t}newRegionAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);const r=new Gh(e);return r.region=n,r}newMeshAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);const r=new ec(e);return r.region=n,r}newBoundingBoxAttachment(t,e){return new bm(e)}newPathAttachment(t,e){return new Qo(e)}newPointAttachment(t,e){return new ym(e)}newClippingAttachment(t,e){return new wm(e)}};var go=(f=>(f[f.Fixed=0]="Fixed",f[f.Percent=1]="Percent",f))(go||{}),Ma=(f=>(f[f.Tangent=0]="Tangent",f[f.Chain=1]="Chain",f[f.ChainScale=2]="ChainScale",f))(Ma||{}),Fw=Object.defineProperty,Bw=(f,t,e)=>t in f?Fw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,_n=(f,t,e)=>Bw(f,typeof t!="symbol"?t+"":t,e);let Cm=class{constructor(t){_n(this,"name"),_n(this,"order",0),_n(this,"bones",new Array),_n(this,"target"),_n(this,"positionMode"),_n(this,"spacingMode"),_n(this,"rotateMode"),_n(this,"offsetRotation"),_n(this,"position"),_n(this,"spacing"),_n(this,"rotateMix"),_n(this,"translateMix"),this.name=t}};var Qn=(f=>(f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f))(Qn||{}),Xw=Object.defineProperty,$w=(f,t,e)=>t in f?Xw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ms=(f,t,e)=>$w(f,typeof t!="symbol"?t+"":t,e);const tl=class fo{constructor(t,e){if(Ms(this,"data"),Ms(this,"bones"),Ms(this,"target"),Ms(this,"position",0),Ms(this,"spacing",0),Ms(this,"rotateMix",0),Ms(this,"translateMix",0),Ms(this,"spaces",new Array),Ms(this,"positions",new Array),Ms(this,"world",new Array),Ms(this,"curves",new Array),Ms(this,"lengths",new Array),Ms(this,"segments",new Array),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let s=0,n=t.bones.length;s<n;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}apply(){this.update()}update(){const t=this.target.getAttachment();if(!(t instanceof Qo))return;const e=this.rotateMix,s=this.translateMix,n=s>0,r=e>0;if(!n&&!r)return;const l=this.data,h=l.spacingMode,i=h==Qn.Length,a=l.rotateMode,o=a==Ma.Tangent,d=a==Ma.ChainScale,u=this.bones.length,m=o?u:u+1,c=this.bones,g=It.setArraySize(this.spaces,m);let p=null;const y=this.spacing;if(d||i){d&&(p=It.setArraySize(this.lengths,u));for(let v=0,A=m-1;v<A;){const M=c[v],I=M.data.length;if(I<fo.epsilon)d&&(p[v]=0),g[++v]=0;else{const E=I*M.matrix.a,P=I*M.matrix.b,R=Math.sqrt(E*E+P*P);d&&(p[v]=R),g[++v]=(i?I+y:y)*R/I}}}else for(let v=1;v<m;v++)g[v]=y;const w=this.computeWorldPositions(t,m,o,l.positionMode==go.Percent,h==Qn.Percent);let x=w[0],b=w[1],S=l.offsetRotation,C=!1;if(S==0)C=a==Ma.Chain;else{C=!1;const v=this.target.bone.matrix;S*=v.a*v.d-v.b*v.c>0?rt.degRad:-rt.degRad}for(let v=0,A=3;v<u;v++,A+=3){const M=c[v],I=M.matrix;I.tx+=(x-I.tx)*s,I.ty+=(b-I.ty)*s;const E=w[A],P=w[A+1],R=E-x,k=P-b;if(d){const Y=p[v];if(Y!=0){const F=(Math.sqrt(R*R+k*k)/Y-1)*e+1;I.a*=F,I.b*=F}}if(x=E,b=P,r){const Y=I.a,F=I.c,X=I.b,W=I.d;let B=0,N=0,O=0;if(o&&(o?B=w[A-1]:g[v+1]==0?B=w[A+2]:B=Math.atan2(k,R)),B-=Math.atan2(X,Y),C){N=Math.cos(B),O=Math.sin(B);const Z=M.data.length;x+=(Z*(N*Y-O*X)-R)*e,b+=(Z*(O*Y+N*X)-k)*e}else B+=S;B>rt.PI?B-=rt.PI2:B<-rt.PI&&(B+=rt.PI2),B*=e,N=Math.cos(B),O=Math.sin(B),I.a=N*Y-O*X,I.c=N*F-O*W,I.b=O*Y+N*X,I.d=O*F+N*W}M.appliedValid=!1}}computeWorldPositions(t,e,s,n,r){const l=this.target;let h=this.position;const i=this.spaces,a=It.setArraySize(this.positions,e*3+2);let o=null;const d=t.closed;let u=t.worldVerticesLength,m=u/6,c=fo.NONE;if(!t.constantSpeed){const B=t.lengths;m-=d?1:2;const N=B[m];if(n&&(h*=N),r)for(let O=0;O<e;O++)i[O]*=N;o=It.setArraySize(this.world,8);for(let O=0,Z=0,$=0;O<e;O++,Z+=3){const D=i[O];h+=D;let _=h;if(d)_%=N,_<0&&(_+=N),$=0;else if(_<0){c!=fo.BEFORE&&(c=fo.BEFORE,t.computeWorldVertices(l,2,4,o,0,2)),this.addBeforePosition(_,o,0,a,Z);continue}else if(_>N){c!=fo.AFTER&&(c=fo.AFTER,t.computeWorldVertices(l,u-6,4,o,0,2)),this.addAfterPosition(_-N,o,0,a,Z);continue}for(;;$++){const lt=B[$];if(!(_>lt)){if($==0)_/=lt;else{const wt=B[$-1];_=(_-wt)/(lt-wt)}break}}$!=c&&(c=$,d&&$==m?(t.computeWorldVertices(l,u-4,4,o,0,2),t.computeWorldVertices(l,0,4,o,4,2)):t.computeWorldVertices(l,$*6+2,8,o,0,2)),this.addCurvePosition(_,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],a,Z,s||O>0&&D==0)}return a}d?(u+=2,o=It.setArraySize(this.world,u),t.computeWorldVertices(l,2,u-4,o,0,2),t.computeWorldVertices(l,0,2,o,u-4,2),o[u-2]=o[0],o[u-1]=o[1]):(m--,u-=4,o=It.setArraySize(this.world,u),t.computeWorldVertices(l,2,u,o,0,2));const g=It.setArraySize(this.curves,m);let p=0,y=o[0],w=o[1],x=0,b=0,S=0,C=0,v=0,A=0,M=0,I=0,E=0,P=0,R=0,k=0,Y=0,F=0;for(let B=0,N=2;B<m;B++,N+=6)x=o[N],b=o[N+1],S=o[N+2],C=o[N+3],v=o[N+4],A=o[N+5],M=(y-x*2+S)*.1875,I=(w-b*2+C)*.1875,E=((x-S)*3-y+v)*.09375,P=((b-C)*3-w+A)*.09375,R=M*2+E,k=I*2+P,Y=(x-y)*.75+M+E*.16666667,F=(b-w)*.75+I+P*.16666667,p+=Math.sqrt(Y*Y+F*F),Y+=R,F+=k,R+=E,k+=P,p+=Math.sqrt(Y*Y+F*F),Y+=R,F+=k,p+=Math.sqrt(Y*Y+F*F),Y+=R+E,F+=k+P,p+=Math.sqrt(Y*Y+F*F),g[B]=p,y=v,w=A;if(n&&(h*=p),r)for(let B=0;B<e;B++)i[B]*=p;const X=this.segments;let W=0;for(let B=0,N=0,O=0,Z=0;B<e;B++,N+=3){const $=i[B];h+=$;let D=h;if(d)D%=p,D<0&&(D+=p),O=0;else if(D<0){this.addBeforePosition(D,o,0,a,N);continue}else if(D>p){this.addAfterPosition(D-p,o,u-4,a,N);continue}for(;;O++){const _=g[O];if(!(D>_)){if(O==0)D/=_;else{const lt=g[O-1];D=(D-lt)/(_-lt)}break}}if(O!=c){c=O;let _=O*6;for(y=o[_],w=o[_+1],x=o[_+2],b=o[_+3],S=o[_+4],C=o[_+5],v=o[_+6],A=o[_+7],M=(y-x*2+S)*.03,I=(w-b*2+C)*.03,E=((x-S)*3-y+v)*.006,P=((b-C)*3-w+A)*.006,R=M*2+E,k=I*2+P,Y=(x-y)*.3+M+E*.16666667,F=(b-w)*.3+I+P*.16666667,W=Math.sqrt(Y*Y+F*F),X[0]=W,_=1;_<8;_++)Y+=R,F+=k,R+=E,k+=P,W+=Math.sqrt(Y*Y+F*F),X[_]=W;Y+=R,F+=k,W+=Math.sqrt(Y*Y+F*F),X[8]=W,Y+=R+E,F+=k+P,W+=Math.sqrt(Y*Y+F*F),X[9]=W,Z=0}for(D*=W;;Z++){const _=X[Z];if(!(D>_)){if(Z==0)D/=_;else{const lt=X[Z-1];D=Z+(D-lt)/(_-lt)}break}}this.addCurvePosition(D*.1,y,w,x,b,S,C,v,A,a,N,s||B>0&&$==0)}return a}addBeforePosition(t,e,s,n,r){const l=e[s],h=e[s+1],i=e[s+2]-l,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){const l=e[s+2],h=e[s+3],i=l-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,l,h,i,a,o,d,u){(t==0||isNaN(t))&&(t=1e-4);const m=t*t,c=m*t,g=1-t,p=g*g,y=p*g,w=g*t,x=w*3,b=g*x,S=x*t,C=e*y+n*b+l*S+i*c,v=s*y+r*b+h*S+a*c;o[d]=C,o[d+1]=v,u&&(o[d+2]=Math.atan2(v-(s*p+r*w*2+h*m),C-(e*p+n*w*2+l*m)))}getOrder(){return this.data.order}};Ms(tl,"NONE",-1),Ms(tl,"BEFORE",-2),Ms(tl,"AFTER",-3),Ms(tl,"epsilon",1e-5);let vm=tl;var Nw=Object.defineProperty,Vw=(f,t,e)=>t in f?Nw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ee=(f,t,e)=>Vw(f,typeof t!="symbol"?t+"":t,e);let sc=class{constructor(t,e,s){if(Ee(this,"matrix",new V.Matrix),Ee(this,"data"),Ee(this,"skeleton"),Ee(this,"parent"),Ee(this,"children",new Array),Ee(this,"x",0),Ee(this,"y",0),Ee(this,"rotation",0),Ee(this,"scaleX",0),Ee(this,"scaleY",0),Ee(this,"shearX",0),Ee(this,"shearY",0),Ee(this,"ax",0),Ee(this,"ay",0),Ee(this,"arotation",0),Ee(this,"ascaleX",0),Ee(this,"ascaleY",0),Ee(this,"ashearX",0),Ee(this,"ashearY",0),Ee(this,"appliedValid",!1),Ee(this,"sorted",!1),Ee(this,"active",!0),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,l,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=l,this.ashearY=h,this.appliedValid=!0;const i=this.parent,a=this.matrix,o=this.skeleton.scaleX,d=-this.skeleton.scaleY;if(i==null){const p=this.skeleton,y=s+90+h;a.a=rt.cosDeg(s+l)*n*o,a.c=rt.cosDeg(y)*r*o,a.b=rt.sinDeg(s+l)*n*d,a.d=rt.sinDeg(y)*r*d,a.tx=t*o+p.x,a.ty=e*d+p.y;return}let u=i.matrix.a,m=i.matrix.c,c=i.matrix.b,g=i.matrix.d;switch(a.tx=u*t+m*e+i.matrix.tx,a.ty=c*t+g*e+i.matrix.ty,this.data.transformMode){case kn.Normal:{const p=s+90+h,y=rt.cosDeg(s+l)*n,w=rt.cosDeg(p)*r,x=rt.sinDeg(s+l)*n,b=rt.sinDeg(p)*r;a.a=u*y+m*x,a.c=u*w+m*b,a.b=c*y+g*x,a.d=c*w+g*b;return}case kn.OnlyTranslation:{const p=s+90+h;a.a=rt.cosDeg(s+l)*n,a.c=rt.cosDeg(p)*r,a.b=rt.sinDeg(s+l)*n,a.d=rt.sinDeg(p)*r;break}case kn.NoRotationOrReflection:{let p=u*u+c*c,y=0;p>1e-4?(p=Math.abs(u*g-m*c)/p,m=c*p,g=u*p,y=Math.atan2(c,u)*rt.radDeg):(u=0,c=0,y=90-Math.atan2(g,m)*rt.radDeg);const w=s+l-y,x=s+h-y+90,b=rt.cosDeg(w)*n,S=rt.cosDeg(x)*r,C=rt.sinDeg(w)*n,v=rt.sinDeg(x)*r;a.a=u*b-m*C,a.c=u*S-m*v,a.b=c*b+g*C,a.d=c*S+g*v;break}case kn.NoScale:case kn.NoScaleOrReflection:{const p=rt.cosDeg(s),y=rt.sinDeg(s);let w=(u*p+m*y)/o,x=(c*p+g*y)/d,b=Math.sqrt(w*w+x*x);b>1e-5&&(b=1/b),w*=b,x*=b,b=Math.sqrt(w*w+x*x),this.data.transformMode==kn.NoScale&&u*g-m*c<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY>0)&&(b=-b);const S=Math.PI/2+Math.atan2(x,w),C=Math.cos(S)*b,v=Math.sin(S)*b,A=rt.cosDeg(l)*n,M=rt.cosDeg(90+h)*r,I=rt.sinDeg(l)*n,E=rt.sinDeg(90+h)*r;a.a=w*A+C*I,a.c=w*M+C*E,a.b=x*A+v*I,a.d=x*M+v*E;break}}a.a*=o,a.c*=o,a.b*=d,a.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*rt.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*rt.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(t==null){this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*rt.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*rt.radDeg;return}const s=t.matrix,n=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,l=e.ty-s.ty;this.ax=r*s.d*n-l*s.c*n,this.ay=l*s.a*n-r*s.b*n;const h=n*s.d,i=n*s.a,a=n*s.c,o=n*s.b,d=h*e.a-a*e.b,u=h*e.c-a*e.d,m=i*e.b-o*e.a,c=i*e.d-o*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*c-u*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*u+m*c,g)*rt.radDeg,this.arotation=Math.atan2(m,d)*rt.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+c*c),this.ashearY=0,this.arotation=90-Math.atan2(c,u)*rt.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=1/(s*l-n*r),i=t.x-e.tx,a=t.y-e.ty;return t.x=i*l*h-a*n*h,t.y=a*s*h-i*r*h,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=rt.sinDeg(t),s=rt.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*s,n.d*s-n.c*e)*rt.radDeg}localToWorldRotation(t){const e=rt.sinDeg(t),s=rt.cosDeg(t),n=this.matrix;return Math.atan2(s*n.b+e*n.d,s*n.a+e*n.c)*rt.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=rt.cosDeg(t),i=rt.sinDeg(t);e.a=h*s-i*r,e.c=h*n-i*l,e.b=i*s+h*r,e.d=i*n+h*l,this.appliedValid=!1}};var _w=Object.defineProperty,Dw=(f,t,e)=>t in f?_w(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ta=(f,t,e)=>Dw(f,typeof t!="symbol"?t+"":t,e);let Am=class{constructor(t,e){if(Ta(this,"data"),Ta(this,"bones"),Ta(this,"target"),Ta(this,"bendDirection",0),Ta(this,"compress",!1),Ta(this,"stretch",!1),Ta(this,"mix",1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}getOrder(){return this.data.order}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.mix);break}}apply1(t,e,s,n,r,l,h){t.appliedValid||t.updateAppliedTransform();const i=t.parent.matrix,a=1/(i.a*i.d-i.b*i.c),o=e-i.tx,d=s-i.ty,u=(o*i.d-d*i.c)*a-t.ax,m=(d*i.a-o*i.b)*a-t.ay;let c=Math.atan2(m,u)*rt.radDeg-t.ashearX-t.arotation;t.ascaleX<0&&(c+=180),c>180?c-=360:c<-180&&(c+=360);let g=t.ascaleX,p=t.ascaleY;if(n||r){const y=t.data.length*g,w=Math.sqrt(u*u+m*m);if(n&&w<y||r&&w>y&&y>1e-4){const x=(w/y-1)*h+1;g*=x,l&&(p*=x)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+c*h,g,p,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,l,h){if(h==0){e.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const i=t.ax,a=t.ay;let o=t.ascaleX,d=o,u=t.ascaleY,m=e.ascaleX;const c=t.matrix;let g=0,p=0,y=0;o<0?(o=-o,g=180,y=-1):(g=0,y=1),u<0&&(u=-u,y=-y),m<0?(m=-m,p=180):p=0;const w=e.ax;let x=0,b=0,S=0,C=c.a,v=c.c,A=c.b,M=c.d;const I=Math.abs(o-u)<=1e-4;I?(x=e.ay,b=C*w+v*x+c.tx,S=A*w+M*x+c.ty):(x=0,b=C*w+c.tx,S=A*w+c.ty);const E=t.parent.matrix;C=E.a,v=E.c,A=E.b,M=E.d;const P=1/(C*M-v*A);let R=s-E.tx,k=n-E.ty;const Y=(R*M-k*v)*P-i,F=(k*C-R*A)*P-a,X=Y*Y+F*F;R=b-E.tx,k=S-E.ty;const W=(R*M-k*v)*P-i,B=(k*C-R*A)*P-a,N=Math.sqrt(W*W+B*B);let O=e.data.length*m,Z=0,$=0;t:if(I){O*=o;let lt=(X-N*N-O*O)/(2*N*O);lt<-1?lt=-1:lt>1&&(lt=1,l&&N+O>1e-4&&(d*=(Math.sqrt(X)/(N+O)-1)*h+1)),$=Math.acos(lt)*r,C=N+O*lt,v=O*Math.sin($),Z=Math.atan2(F*C-Y*v,Y*C+F*v)}else{C=o*O,v=u*O;const lt=C*C,wt=v*v,Tt=Math.atan2(F,Y);A=wt*N*N+lt*X-lt*wt;const ct=-2*wt*N,Mt=wt-lt;if(M=ct*ct-4*Mt*A,M>=0){let ue=Math.sqrt(M);ct<0&&(ue=-ue),ue=-(ct+ue)/2;const ye=ue/Mt,Ue=A/ue,Kt=Math.abs(ye)<Math.abs(Ue)?ye:Ue;if(Kt*Kt<=X){k=Math.sqrt(X-Kt*Kt)*r,Z=Tt-Math.atan2(k,Kt),$=Math.atan2(k/u,(Kt-N)/o);break t}}let Rt=rt.PI,de=N-C,Ze=de*de,Je=0,we=0,Ye=N+C,Qe=Ye*Ye,je=0;A=-C*N/(lt-wt),A>=-1&&A<=1&&(A=Math.acos(A),R=C*Math.cos(A)+N,k=v*Math.sin(A),M=R*R+k*k,M<Ze&&(Rt=A,Ze=M,de=R,Je=k),M>Qe&&(we=A,Qe=M,Ye=R,je=k)),X<=(Ze+Qe)/2?(Z=Tt-Math.atan2(Je*r,de),$=Rt*r):(Z=Tt-Math.atan2(je*r,Ye),$=we*r)}const D=Math.atan2(x,w)*y;let _=t.arotation;Z=(Z-D)*rt.radDeg+g-_,Z>180?Z-=360:Z<-180&&(Z+=360),t.updateWorldTransformWith(i,a,_+Z*h,d,t.ascaleY,0,0),_=e.arotation,$=(($+D)*rt.radDeg-e.ashearX)*y+p-_,$>180?$-=360:$<-180&&($+=360),e.updateWorldTransformWith(w,x,_+$*h,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}};var Lw=Object.defineProperty,Ow=(f,t,e)=>t in f?Lw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Li=(f,t,e)=>Ow(f,typeof t!="symbol"?t+"":t,e);let Mm=class{constructor(t,e){if(Li(this,"data"),Li(this,"bones"),Li(this,"target"),Li(this,"rotateMix",0),Li(this,"translateMix",0),Li(this,"scaleMix",0),Li(this,"shearMix",0),Li(this,"temp",new Jb),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target,l=r.matrix,h=l.a,i=l.c,a=l.b,o=l.d,d=h*o-i*a>0?rt.degRad:-rt.degRad,u=this.data.offsetRotation*d,m=this.data.offsetShearY*d,c=this.bones;for(let g=0,p=c.length;g<p;g++){const y=c[g];let w=!1;const x=y.matrix;if(t!=0){const b=x.a,S=x.c,C=x.b,v=x.d;let A=Math.atan2(a,h)-Math.atan2(C,b)+u;A>rt.PI?A-=rt.PI2:A<-rt.PI&&(A+=rt.PI2),A*=t;const M=Math.cos(A),I=Math.sin(A);x.a=M*b-I*C,x.c=M*S-I*v,x.b=I*b+M*C,x.d=I*S+M*v,w=!0}if(e!=0){const b=this.temp;r.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),x.tx+=(b.x-x.tx)*e,x.ty+=(b.y-x.ty)*e,w=!0}if(s>0){let b=Math.sqrt(x.a*x.a+x.b*x.b),S=Math.sqrt(h*h+a*a);b>1e-5&&(b=(b+(S-b+this.data.offsetScaleX)*s)/b),x.a*=b,x.b*=b,b=Math.sqrt(x.c*x.c+x.d*x.d),S=Math.sqrt(i*i+o*o),b>1e-5&&(b=(b+(S-b+this.data.offsetScaleY)*s)/b),x.c*=b,x.d*=b,w=!0}if(n>0){const b=x.c,S=x.d,C=Math.atan2(S,b);let v=Math.atan2(o,i)-Math.atan2(a,h)-(C-Math.atan2(x.b,x.a));v>rt.PI?v-=rt.PI2:v<-rt.PI&&(v+=rt.PI2),v=C+(v+m)*n;const A=Math.sqrt(b*b+S*S);x.c=Math.cos(v)*A,x.d=Math.sin(v)*A,w=!0}w&&(y.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target,l=r.matrix,h=l.a,i=l.c,a=l.b,o=l.d,d=h*o-i*a>0?rt.degRad:-rt.degRad,u=this.data.offsetRotation*d,m=this.data.offsetShearY*d,c=this.bones;for(let g=0,p=c.length;g<p;g++){const y=c[g];let w=!1;const x=y.matrix;if(t!=0){const b=x.a,S=x.c,C=x.b,v=x.d;let A=Math.atan2(a,h)+u;A>rt.PI?A-=rt.PI2:A<-rt.PI&&(A+=rt.PI2),A*=t;const M=Math.cos(A),I=Math.sin(A);x.a=M*b-I*C,x.c=M*S-I*v,x.b=I*b+M*C,x.d=I*S+M*v,w=!0}if(e!=0){const b=this.temp;r.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),x.tx+=b.x*e,x.ty+=b.y*e,w=!0}if(s>0){let b=(Math.sqrt(h*h+a*a)-1+this.data.offsetScaleX)*s+1;x.a*=b,x.b*=b,b=(Math.sqrt(i*i+o*o)-1+this.data.offsetScaleY)*s+1,x.c*=b,x.d*=b,w=!0}if(n>0){let b=Math.atan2(o,i)-Math.atan2(a,h);b>rt.PI?b-=rt.PI2:b<-rt.PI&&(b+=rt.PI2);const S=x.c,C=x.d;b=Math.atan2(C,S)+(b-rt.PI/2+m)*n;const v=Math.sqrt(S*S+C*C);x.c=Math.cos(b)*v,x.d=Math.sin(b)*v,w=!0}w&&(y.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target;r.appliedValid||r.updateAppliedTransform();const l=this.bones;for(let h=0,i=l.length;h<i;h++){const a=l[h];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;if(t!=0){let p=r.arotation-o+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,o+=p*t}let d=a.ax,u=a.ay;e!=0&&(d+=(r.ax-d+this.data.offsetX)*e,u+=(r.ay-u+this.data.offsetY)*e);let m=a.ascaleX,c=a.ascaleY;s>0&&(m>1e-5&&(m=(m+(r.ascaleX-m+this.data.offsetScaleX)*s)/m),c>1e-5&&(c=(c+(r.ascaleY-c+this.data.offsetScaleY)*s)/c));const g=a.ashearY;if(n>0){let p=r.ashearY-g+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,a.shearY+=p*n}a.updateWorldTransformWith(d,u,o,m,c,a.ashearX,g)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target;r.appliedValid||r.updateAppliedTransform();const l=this.bones;for(let h=0,i=l.length;h<i;h++){const a=l[h];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;t!=0&&(o+=(r.arotation+this.data.offsetRotation)*t);let d=a.ax,u=a.ay;e!=0&&(d+=(r.ax+this.data.offsetX)*e,u+=(r.ay+this.data.offsetY)*e);let m=a.ascaleX,c=a.ascaleY;s>0&&(m>1e-5&&(m*=(r.ascaleX-1+this.data.offsetScaleX)*s+1),c>1e-5&&(c*=(r.ascaleY-1+this.data.offsetScaleY)*s+1));let g=a.ashearY;n>0&&(g+=(r.ashearY+this.data.offsetShearY)*n),a.updateWorldTransformWith(d,u,o,m,c,a.ashearX,g)}}getOrder(){return this.data.order}};var Ww=Object.defineProperty,Uw=(f,t,e)=>t in f?Ww(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ts=(f,t,e)=>Uw(f,typeof t!="symbol"?t+"":t,e);const Tm=class ql{constructor(t){if(Ts(this,"data"),Ts(this,"bones"),Ts(this,"slots"),Ts(this,"drawOrder"),Ts(this,"ikConstraints"),Ts(this,"transformConstraints"),Ts(this,"pathConstraints"),Ts(this,"_updateCache",new Array),Ts(this,"updateCacheReset",new Array),Ts(this,"skin"),Ts(this,"color"),Ts(this,"time",0),Ts(this,"scaleX",1),Ts(this,"scaleY",1),Ts(this,"x",0),Ts(this,"y",0),t==null)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(s.parent==null)n=new sc(s,this,null);else{const r=this.bones[s.parent.index];n=new sc(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new zh(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new Am(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new Mm(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new vm(s,this))}this.color=new Ls(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0,this.updateCacheReset.length=0;const e=this.bones;for(let o=0,d=e.length;o<d;o++)e[o].sorted=!1;const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,l=s.length,h=n.length,i=r.length,a=l+h+i;t:for(let o=0;o<a;o++){for(let d=0;d<l;d++){const u=s[d];if(u.data.order==o){this.sortIkConstraint(u);continue t}}for(let d=0;d<h;d++){const u=n[d];if(u.data.order==o){this.sortTransformConstraint(u);continue t}}for(let d=0;d<i;d++){const u=r[d];if(u.data.order==o){this.sortPathConstraint(u);continue t}}}for(let o=0,d=e.length;o<d;o++)this.sortBone(e[o])}sortIkConstraint(t){const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length>1){const r=s[s.length-1];this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}this._updateCache.push(t),this.sortReset(n.children),s[s.length-1].sorted=!0}sortPathConstraint(t){const e=t.target,s=e.data.index,n=e.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof Qo&&this.sortPathConstraintAttachmentWith(r,n);const l=t.bones,h=l.length;for(let i=0;i<h;i++)this.sortBone(l[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(l[i].children);for(let i=0;i<h;i++)l[i].sorted=!0}sortTransformConstraint(t){this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof Qo))return;const s=t.bones;if(s==null)this.sortBone(e);else{const n=this.bones;let r=0;for(;r<s.length;){const l=s[r++];for(let h=r+l;r<h;r++){const i=s[r];this.sortBone(n[i])}}}}sortBone(t){if(t.sorted)return;const e=t.parent;e!=null&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.sorted&&this.sortReset(n.children),n.sorted=!1}}updateWorldTransform(){const t=this.updateCacheReset;for(let s=0,n=t.length;s<n;s++){const r=t[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY,r.appliedValid=!0}const e=this._updateCache;for(let s=0,n=e.length;s<n;s++)e[s].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let r=0,l=t.length;r<l;r++)t[r].setToSetupPose();const e=this.ikConstraints;for(let r=0,l=e.length;r<l;r++){const h=e[r];h.bendDirection=h.data.bendDirection,h.mix=h.data.mix}const s=this.transformConstraints;for(let r=0,l=s.length;r<l;r++){const h=s[r],i=h.data;h.rotateMix=i.rotateMix,h.translateMix=i.translateMix,h.scaleMix=i.scaleMix,h.shearMix=i.shearMix}const n=this.pathConstraints;for(let r=0,l=n.length;r<l;r++){const h=n[r],i=h.data;h.position=i.position,h.spacing=i.spacing,h.rotateMix=i.rotateMix,h.translateMix=i.translateMix}}setSlotsToSetupPose(){const t=this.slots;It.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(e==null)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=null)if(this.skin!=null)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],l=r.data.attachmentName;if(l!=null){const h=t.getAttachment(s,l);h!=null&&r.setAttachment(h)}}}this.skin=t}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)}getAttachment(t,e){if(e==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const s=this.skin.getAttachment(t,e);if(s!=null)return s}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.data.name==t){let h=null;if(e!=null&&(h=this.getAttachment(n,e),h==null))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);l.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}getBounds(t,e,s){if(t==null)throw new Error("offset cannot be null.");if(e==null)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let a=0,o=n.length;a<o;a++){const d=n[a];let u=0,m=null;const c=d.getAttachment();if(c instanceof Gh)u=8,m=It.setArraySize(s,u,0),c.computeWorldVertices(d.bone,m,0,2);else if(c instanceof ec){const g=c;u=g.worldVerticesLength,m=It.setArraySize(s,u,0),g.computeWorldVertices(d,0,u,m,0,2)}if(m!=null)for(let g=0,p=m.length;g<p;g+=2){const y=m[g],w=m[g+1];r=Math.min(r,y),l=Math.min(l,w),h=Math.max(h,y),i=Math.max(i,w)}}t.set(r,l),e.set(h-r,i-l)}update(t){this.time+=t}get flipX(){return this.scaleX==-1}set flipX(t){ql.deprecatedWarning1||(ql.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){ql.deprecatedWarning1||(ql.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};Ts(Tm,"deprecatedWarning1",!1);let Em=Tm;var qw=Object.defineProperty,zw=(f,t,e)=>t in f?qw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ea=(f,t,e)=>zw(f,typeof t!="symbol"?t+"":t,e);let Im=class{constructor(t,e){if(Ea(this,"data"),Ea(this,"intValue"),Ea(this,"floatValue"),Ea(this,"stringValue"),Ea(this,"time"),Ea(this,"volume"),Ea(this,"balance"),e==null)throw new Error("data cannot be null.");this.time=t,this.data=e}};var Gw=Object.defineProperty,Hw=(f,t,e)=>t in f?Gw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Os=(f,t,e)=>Hw(f,typeof t!="symbol"?t+"":t,e);let km=class{constructor(){Os(this,"name"),Os(this,"bones",new Array),Os(this,"slots",new Array),Os(this,"skins",new Array),Os(this,"defaultSkin"),Os(this,"events",new Array),Os(this,"animations",new Array),Os(this,"ikConstraints",new Array),Os(this,"transformConstraints",new Array),Os(this,"pathConstraints",new Array),Os(this,"width"),Os(this,"height"),Os(this,"version"),Os(this,"hash"),Os(this,"fps",0),Os(this,"imagesPath")}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}};var Kw=Object.defineProperty,Zw=(f,t,e)=>t in f?Kw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ia=(f,t,e)=>Zw(f,typeof t!="symbol"?t+"":t,e);let Pm=class{constructor(t,e,s){if(Ia(this,"index"),Ia(this,"name"),Ia(this,"boneData"),Ia(this,"color",new Ls(1,1,1,1)),Ia(this,"darkColor"),Ia(this,"attachmentName"),Ia(this,"blendMode"),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}};var Jw=Object.defineProperty,Qw=(f,t,e)=>t in f?Jw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Dn=(f,t,e)=>Qw(f,typeof t!="symbol"?t+"":t,e);let Rm=class{constructor(t,e,s){if(Dn(this,"index"),Dn(this,"name"),Dn(this,"parent"),Dn(this,"length"),Dn(this,"x",0),Dn(this,"y",0),Dn(this,"rotation",0),Dn(this,"scaleX",1),Dn(this,"scaleY",1),Dn(this,"shearX",0),Dn(this,"shearY",0),Dn(this,"transformMode",kn.Normal),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}};var jw=Object.defineProperty,t1=(f,t,e)=>t in f?jw(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ei=(f,t,e)=>t1(f,typeof t!="symbol"?t+"":t,e);let Ym=class{constructor(t){ei(this,"name"),ei(this,"order",0),ei(this,"bones",new Array),ei(this,"target"),ei(this,"bendDirection",1),ei(this,"compress",!1),ei(this,"stretch",!1),ei(this,"uniform",!1),ei(this,"mix",1),this.name=t}};var e1=Object.defineProperty,s1=(f,t,e)=>t in f?e1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ws=(f,t,e)=>s1(f,typeof t!="symbol"?t+"":t,e);let Fm=class{constructor(t){if(Ws(this,"name"),Ws(this,"order",0),Ws(this,"bones",new Array),Ws(this,"target"),Ws(this,"rotateMix",0),Ws(this,"translateMix",0),Ws(this,"scaleMix",0),Ws(this,"shearMix",0),Ws(this,"offsetRotation",0),Ws(this,"offsetX",0),Ws(this,"offsetY",0),Ws(this,"offsetScaleX",0),Ws(this,"offsetScaleY",0),Ws(this,"offsetShearY",0),Ws(this,"relative",!1),Ws(this,"local",!1),t==null)throw new Error("name cannot be null.");this.name=t}};var n1=Object.defineProperty,r1=(f,t,e)=>t in f?n1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Bm=(f,t,e)=>r1(f,typeof t!="symbol"?t+"":t,e);let Xm=class{constructor(t){if(Bm(this,"name"),Bm(this,"attachments",new Array),t==null)throw new Error("name cannot be null.");this.name=t}addAttachment(t,e,s){if(s==null)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],l=r.getAttachment();if(l&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(l==a){const o=this.getAttachment(s,i);o!=null&&r.setAttachment(o);break}}}s++}}};var i1=Object.defineProperty,a1=(f,t,e)=>t in f?i1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ka=(f,t,e)=>a1(f,typeof t!="symbol"?t+"":t,e);let $m=class{constructor(t){ka(this,"name"),ka(this,"intValue"),ka(this,"floatValue"),ka(this,"stringValue"),ka(this,"audioPath"),ka(this,"volume"),ka(this,"balance"),this.name=t}};var o1=Object.defineProperty,l1=(f,t,e)=>t in f?o1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Pa=(f,t,e)=>l1(f,typeof t!="symbol"?t+"":t,e);let Nm=class $o{constructor(t){Pa(this,"attachmentLoader"),Pa(this,"scale",1),Pa(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new km,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r!=null&&(s.hash=r.hash,s.version=r.spine,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images),n.bones)for(let l=0;l<n.bones.length;l++){const h=n.bones[l];let i=null;const a=this.getValue(h,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const o=new Rm(s.bones.length,h.name,i);o.length=this.getValue(h,"length",0)*e,o.x=this.getValue(h,"x",0)*e,o.y=this.getValue(h,"y",0)*e,o.rotation=this.getValue(h,"rotation",0),o.scaleX=this.getValue(h,"scaleX",1),o.scaleY=this.getValue(h,"scaleY",1),o.shearX=this.getValue(h,"shearX",0),o.shearY=this.getValue(h,"shearY",0),o.transformMode=$o.transformModeFromString(this.getValue(h,"transform","normal")),s.bones.push(o)}if(n.slots)for(let l=0;l<n.slots.length;l++){const h=n.slots[l],i=h.name,a=h.bone,o=s.findBone(a);if(o==null)throw new Error(`Slot bone not found: ${a}`);const d=new Pm(s.slots.length,i,o),u=this.getValue(h,"color",null);u!=null&&d.color.setFromString(u);const m=this.getValue(h,"dark",null);m!=null&&(d.darkColor=new Ls(1,1,1,1),d.darkColor.setFromString(m)),d.attachmentName=this.getValue(h,"attachment",null),d.blendMode=$o.blendModeFromString(this.getValue(h,"blend","normal")),s.slots.push(d)}if(n.ik)for(let l=0;l<n.ik.length;l++){const h=n.ik[l],i=new Ym(h.name);i.order=this.getValue(h,"order",0);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],u=s.findBone(d);if(u==null)throw new Error(`IK bone not found: ${d}`);i.bones.push(u)}const a=h.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`IK target bone not found: ${a}`);i.bendDirection=this.getValue(h,"bendPositive",!0)?1:-1,i.mix=this.getValue(h,"mix",1),s.ikConstraints.push(i)}if(n.transform)for(let l=0;l<n.transform.length;l++){const h=n.transform[l],i=new Fm(h.name);i.order=this.getValue(h,"order",0);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],u=s.findBone(d);if(u==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(u)}const a=h.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);i.local=this.getValue(h,"local",!1),i.relative=this.getValue(h,"relative",!1),i.offsetRotation=this.getValue(h,"rotation",0),i.offsetX=this.getValue(h,"x",0)*e,i.offsetY=this.getValue(h,"y",0)*e,i.offsetScaleX=this.getValue(h,"scaleX",0),i.offsetScaleY=this.getValue(h,"scaleY",0),i.offsetShearY=this.getValue(h,"shearY",0),i.rotateMix=this.getValue(h,"rotateMix",1),i.translateMix=this.getValue(h,"translateMix",1),i.scaleMix=this.getValue(h,"scaleMix",1),i.shearMix=this.getValue(h,"shearMix",1),s.transformConstraints.push(i)}if(n.path)for(let l=0;l<n.path.length;l++){const h=n.path[l],i=new Cm(h.name);i.order=this.getValue(h,"order",0);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],u=s.findBone(d);if(u==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(u)}const a=h.target;if(i.target=s.findSlot(a),i.target==null)throw new Error(`Path target slot not found: ${a}`);i.positionMode=$o.positionModeFromString(this.getValue(h,"positionMode","percent")),i.spacingMode=$o.spacingModeFromString(this.getValue(h,"spacingMode","length")),i.rotateMode=$o.rotateModeFromString(this.getValue(h,"rotateMode","tangent")),i.offsetRotation=this.getValue(h,"rotation",0),i.position=this.getValue(h,"position",0),i.positionMode==go.Fixed&&(i.position*=e),i.spacing=this.getValue(h,"spacing",0),(i.spacingMode==Qn.Length||i.spacingMode==Qn.Fixed)&&(i.spacing*=e),i.rotateMix=this.getValue(h,"rotateMix",1),i.translateMix=this.getValue(h,"translateMix",1),s.pathConstraints.push(i)}if(n.skins)for(const l in n.skins){const h=n.skins[l],i=new Xm(l);for(const a in h){const o=s.findSlotIndex(a);if(o==-1)throw new Error(`Slot not found: ${a}`);const d=h[a];for(const u in d){const m=this.readAttachment(d[u],i,o,u,s);m!=null&&i.addAttachment(o,u,m)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let l=0,h=this.linkedMeshes.length;l<h;l++){const i=this.linkedMeshes[l],a=i.skin==null?s.defaultSkin:s.findSkin(i.skin);if(a==null)throw new Error(`Skin not found: ${i.skin}`);const o=a.getAttachment(i.slotIndex,i.parent);if(o==null)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,n.events)for(const l in n.events){const h=n.events[l],i=new $m(l);i.intValue=this.getValue(h,"int",0),i.floatValue=this.getValue(h,"float",0),i.stringValue=this.getValue(h,"string",""),i.audioPath=this.getValue(h,"audio",null),i.audioPath!=null&&(i.volume=this.getValue(h,"volume",1),i.balance=this.getValue(h,"balance",0)),s.events.push(i)}if(n.animations)for(const l in n.animations){const h=n.animations[l];this.readAnimation(h,l,s)}return s}readAttachment(t,e,s,n,r){const l=this.scale;switch(n=this.getValue(t,"name",n),this.getValue(t,"type","region")){case"region":{const i=this.getValue(t,"path",n),a=this.attachmentLoader.newRegionAttachment(e,n,i);if(a==null)return null;a.path=i,a.x=this.getValue(t,"x",0)*l,a.y=this.getValue(t,"y",0)*l,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*l,a.height=t.height*l;const o=this.getValue(t,"color",null);return o!=null&&a.color.setFromString(o),a}case"boundingbox":{const i=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(i==null)return null;this.readVertices(t,i,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"mesh":case"linkedmesh":{const i=this.getValue(t,"path",n),a=this.attachmentLoader.newMeshAttachment(e,n,i);if(a==null)return null;a.path=i;const o=this.getValue(t,"color",null);o!=null&&a.color.setFromString(o);const d=this.getValue(t,"parent",null);if(d!=null)return a.inheritDeform=this.getValue(t,"deform",!0),this.linkedMeshes.push(new h1(a,this.getValue(t,"skin",null),s,d)),a;const u=t.uvs;return this.readVertices(t,a,u.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(u),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const i=this.attachmentLoader.newPathAttachment(e,n);if(i==null)return null;i.closed=this.getValue(t,"closed",!1),i.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,i,a<<1);const o=It.newArray(a/3,0);for(let u=0;u<t.lengths.length;u++)o[u]=t.lengths[u]*l;i.lengths=o;const d=this.getValue(t,"color",null);return d!=null&&i.color.setFromString(d),i}case"point":{const i=this.attachmentLoader.newPointAttachment(e,n);if(i==null)return null;i.x=this.getValue(t,"x",0)*l,i.y=this.getValue(t,"y",0)*l,i.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"clipping":{const i=this.attachmentLoader.newClippingAttachment(e,n);if(i==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const u=r.findSlot(a);if(u==null)throw new Error(`Clipping end slot not found: ${a}`);i.endSlot=u}const o=t.vertexCount;this.readVertices(t,i,o<<1);const d=this.getValue(t,"color",null);return d!=null&&i.color.setFromString(d),i}}return null}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=It.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const l=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),l.push(r[i+1]*n),l.push(r[i+2]*n),l.push(r[i+3])}e.bones=h,e.vertices=It.toFloatArray(l)}readAnimation(t,e,s){const n=this.scale,r=new Array;let l=0;if(t.slots)for(const i in t.slots){const a=t.slots[i],o=s.findSlotIndex(i);if(o==-1)throw new Error(`Slot not found: ${i}`);for(const d in a){const u=a[d];if(d=="attachment"){const m=new sh(u.length);m.slotIndex=o;let c=0;for(let g=0;g<u.length;g++){const p=u[g];m.setFrame(c++,p.time,p.name)}r.push(m),l=Math.max(l,m.frames[m.getFrameCount()-1])}else if(d=="color"){const m=new Hh(u.length);m.slotIndex=o;let c=0;for(let g=0;g<u.length;g++){const p=u[g],y=new Ls;y.setFromString(p.color||"ffffffff"),m.setFrame(c,p.time,y.r,y.g,y.b,y.a),this.readCurve(p,m,c),c++}r.push(m),l=Math.max(l,m.frames[(m.getFrameCount()-1)*Hh.ENTRIES])}else if(d=="twoColor"){const m=new Kh(u.length);m.slotIndex=o;let c=0;for(let g=0;g<u.length;g++){const p=u[g],y=new Ls,w=new Ls;y.setFromString(p.light),w.setFromString(p.dark),m.setFrame(c,p.time,y.r,y.g,y.b,y.a,w.r,w.g,w.b),this.readCurve(p,m,c),c++}r.push(m),l=Math.max(l,m.frames[(m.getFrameCount()-1)*Kh.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${d} (${i})`)}}if(t.bones)for(const i in t.bones){const a=t.bones[i],o=s.findBoneIndex(i);if(o==-1)throw new Error(`Bone not found: ${i}`);for(const d in a){const u=a[d];if(d==="rotate"){const m=new Gn(u.length);m.boneIndex=o;let c=0;for(let g=0;g<u.length;g++){const p=u[g];m.setFrame(c,p.time,p.angle),this.readCurve(p,m,c),c++}r.push(m),l=Math.max(l,m.frames[(m.getFrameCount()-1)*Gn.ENTRIES])}else if(d==="translate"||d==="scale"||d==="shear"){let m=null,c=1;d==="scale"?m=new rm(u.length):d==="shear"?m=new im(u.length):(m=new Ko(u.length),c=n),m.boneIndex=o;let g=0;for(let p=0;p<u.length;p++){const y=u[p],w=this.getValue(y,"x",0),x=this.getValue(y,"y",0);m.setFrame(g,y.time,w*c,x*c),this.readCurve(y,m,g),g++}r.push(m),l=Math.max(l,m.frames[(m.getFrameCount()-1)*Ko.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${d} (${i})`)}}if(t.ik)for(const i in t.ik){const a=t.ik[i],o=s.findIkConstraint(i),d=new Zh(a.length);d.ikConstraintIndex=s.ikConstraints.indexOf(o);let u=0;for(let m=0;m<a.length;m++){const c=a[m];d.setFrame(u,c.time,this.getValue(c,"mix",1),this.getValue(c,"bendPositive",!0)?1:-1,this.getValue(c,"compress",!1),this.getValue(c,"stretch",!1)),this.readCurve(c,d,u),u++}r.push(d),l=Math.max(l,d.frames[(d.getFrameCount()-1)*Zh.ENTRIES])}if(t.transform)for(const i in t.transform){const a=t.transform[i],o=s.findTransformConstraint(i),d=new Jh(a.length);d.transformConstraintIndex=s.transformConstraints.indexOf(o);let u=0;for(let m=0;m<a.length;m++){const c=a[m];d.setFrame(u,c.time,this.getValue(c,"rotateMix",1),this.getValue(c,"translateMix",1),this.getValue(c,"scaleMix",1),this.getValue(c,"shearMix",1)),this.readCurve(c,d,u),u++}r.push(d),l=Math.max(l,d.frames[(d.getFrameCount()-1)*Jh.ENTRIES])}if(t.paths)for(const i in t.paths){const a=t.paths[i],o=s.findPathConstraintIndex(i);if(o==-1)throw new Error(`Path constraint not found: ${i}`);const d=s.pathConstraints[o];for(const u in a){const m=a[u];if(u==="position"||u==="spacing"){let c=null,g=1;u==="spacing"?(c=new hm(m.length),(d.spacingMode==Qn.Length||d.spacingMode==Qn.Fixed)&&(g=n)):(c=new rh(m.length),d.positionMode==go.Fixed&&(g=n)),c.pathConstraintIndex=o;let p=0;for(let y=0;y<m.length;y++){const w=m[y];c.setFrame(p,w.time,this.getValue(w,u,0)*g),this.readCurve(w,c,p),p++}r.push(c),l=Math.max(l,c.frames[(c.getFrameCount()-1)*rh.ENTRIES])}else if(u==="mix"){const c=new Qh(m.length);c.pathConstraintIndex=o;let g=0;for(let p=0;p<m.length;p++){const y=m[p];c.setFrame(g,y.time,this.getValue(y,"rotateMix",1),this.getValue(y,"translateMix",1)),this.readCurve(y,c,g),g++}r.push(c),l=Math.max(l,c.frames[(c.getFrameCount()-1)*Qh.ENTRIES])}}}if(t.deform)for(const i in t.deform){const a=t.deform[i],o=s.findSkin(i);if(o!=null)for(const d in a){const u=a[d],m=s.findSlotIndex(d);if(m==-1)throw new Error(`Slot not found: ${u.name}`);for(const c in u){const g=u[c],p=o.getAttachment(m,c);if(p==null)throw new Error(`Deform attachment not found: ${g.name}`);const y=p.bones!=null,w=p.vertices,x=y?w.length/3*2:w.length,b=new om(g.length);b.slotIndex=m,b.attachment=p;let S=0;for(let C=0;C<g.length;C++){const v=g[C];let A;const M=this.getValue(v,"vertices",null);if(M==null)A=y?It.newFloatArray(x):w;else{A=It.newFloatArray(x);const I=this.getValue(v,"offset",0);if(It.arrayCopy(M,0,A,I,M.length),n!=1)for(let E=I,P=E+M.length;E<P;E++)A[E]*=n;if(!y)for(let E=0;E<x;E++)A[E]+=w[E]}b.setFrame(S,v.time,A),this.readCurve(v,b,S),S++}r.push(b),l=Math.max(l,b.frames[b.getFrameCount()-1])}}}let h=t.drawOrder;if(h==null&&(h=t.draworder),h!=null){const i=new nh(h.length),a=s.slots.length;let o=0;for(let d=0;d<h.length;d++){const u=h[d];let m=null;const c=this.getValue(u,"offsets",null);if(c!=null){m=It.newArray(a,-1);const g=It.newArray(a-c.length,0);let p=0,y=0;for(let w=0;w<c.length;w++){const x=c[w],b=s.findSlotIndex(x.slot);if(b==-1)throw new Error(`Slot not found: ${x.slot}`);for(;p!=b;)g[y++]=p++;m[p+x.offset]=p++}for(;p<a;)g[y++]=p++;for(let w=a-1;w>=0;w--)m[w]==-1&&(m[w]=g[--y])}i.setFrame(o++,u.time,m)}r.push(i),l=Math.max(l,i.frames[i.getFrameCount()-1])}if(t.events){const i=new lm(t.events.length);let a=0;for(let o=0;o<t.events.length;o++){const d=t.events[o],u=s.findEvent(d.name);if(u==null)throw new Error(`Event not found: ${d.name}`);const m=new Im(It.toSinglePrecision(d.time),u);m.intValue=this.getValue(d,"int",u.intValue),m.floatValue=this.getValue(d,"float",u.floatValue),m.stringValue=this.getValue(d,"string",u.stringValue),m.data.audioPath!=null&&(m.volume=this.getValue(d,"volume",1),m.balance=this.getValue(d,"balance",0)),i.setFrame(a++,m)}r.push(i),l=Math.max(l,i.frames[i.getFrameCount()-1])}if(isNaN(l))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new es(e,r,l))}readCurve(t,e,s){if(t.curve){if(t.curve==="stepped")e.setStepped(s);else if(Object.prototype.toString.call(t.curve)==="[object Array]"){const n=t.curve;e.setCurve(s,n[0],n[1],n[2],n[3])}}}getValue(t,e,s){return t[e]!==void 0?t[e]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return V.BLEND_MODES.NORMAL;if(t=="additive")return V.BLEND_MODES.ADD;if(t=="multiply")return V.BLEND_MODES.MULTIPLY;if(t=="screen")return V.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return go.Fixed;if(t=="percent")return go.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return Qn.Length;if(t=="fixed")return Qn.Fixed;if(t=="percent")return Qn.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return Ma.Tangent;if(t=="chain")return Ma.Chain;if(t=="chainscale")return Ma.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return kn.Normal;if(t=="onlytranslation")return kn.OnlyTranslation;if(t=="norotationorreflection")return kn.NoRotationOrReflection;if(t=="noscale")return kn.NoScale;if(t=="noscaleorreflection")return kn.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},h1=class{constructor(t,e,s,n){Pa(this,"parent"),Pa(this,"skin"),Pa(this,"slotIndex"),Pa(this,"mesh"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n}};var c1=Object.defineProperty,d1=(f,t,e)=>t in f?c1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Es=(f,t,e)=>d1(f,typeof t!="symbol"?t+"":t,e);let u1=class{constructor(){Es(this,"array",new Array)}add(t){const e=this.contains(t);return this.array[t|0]=t|0,!e}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}};const jn=class Mx{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Mx().setFromString(t)}};Es(jn,"WHITE",new jn(1,1,1,1)),Es(jn,"RED",new jn(1,0,0,1)),Es(jn,"GREEN",new jn(0,1,0,1)),Es(jn,"BLUE",new jn(0,0,1,1)),Es(jn,"MAGENTA",new jn(1,0,1,1));let ne=jn;const fn=class zl{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*zl.degRad)}static sinDeg(t){return Math.sin(t*zl.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*zl.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return zl.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};Es(fn,"PI",3.1415927),Es(fn,"PI2",fn.PI*2),Es(fn,"invPI2",1/fn.PI2),Es(fn,"radiansToDegrees",180/fn.PI),Es(fn,"radDeg",fn.radiansToDegrees),Es(fn,"degreesToRadians",fn.PI/180),Es(fn,"degRad",fn.degreesToRadians);let nt=fn,f1=class{apply(t,e,s){return t+(e-t)*this.applyInternal(s)}},m1=class extends f1{constructor(t){super(),Es(this,"power",2),this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}},g1=class extends m1{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}};const Vm=class No{static arrayCopy(t,e,s,n,r){for(let l=e,h=n;l<e+r;l++,h++)s[h]=t[l]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:No.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(No.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(No.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return No.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return No.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};Es(Vm,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let dt=Vm,_m=class{constructor(t){Es(this,"items",new Array),Es(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},p1=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};var Be=(f=>(f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping",f))(Be||{}),Ie=(f=>(f[f.Normal=0]="Normal",f[f.OnlyTranslation=1]="OnlyTranslation",f[f.NoRotationOrReflection=2]="NoRotationOrReflection",f[f.NoScale=3]="NoScale",f[f.NoScaleOrReflection=4]="NoScaleOrReflection",f))(Ie||{}),Dm=(f=>(f[f.none=0]="none",f[f.reset=1]="reset",f[f.update=2]="update",f[f.pose=3]="pose",f))(Dm||{}),x1=Object.defineProperty,b1=(f,t,e)=>t in f?x1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,el=(f,t,e)=>b1(f,typeof t!="symbol"?t+"":t,e);let Lm=class{constructor(){el(this,"texture"),el(this,"size",null),el(this,"names",null),el(this,"values",null),el(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var Om=(f=>(f[f.UNKNOWN=0]="UNKNOWN",f[f.VER37=37]="VER37",f[f.VER38=38]="VER38",f[f.VER40=40]="VER40",f[f.VER41=41]="VER41",f[f.VER42=42]="VER42",f))(Om||{});function w1(f){const t=f.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const y1={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var S1=Object.defineProperty,C1=(f,t,e)=>t in f?S1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Is=(f,t,e)=>C1(f,typeof t!="symbol"?t+"":t,e);const Oi=[0,0,0];let v1=class extends $i.Sprite{constructor(){super(...arguments),Is(this,"region",null),Is(this,"attachment",null)}},A1=class extends Xi.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),Is(this,"region",null),Is(this,"attachment",null)}};const Wm=class Tx extends Et.Container{constructor(t){if(super(),Is(this,"tintRgb"),Is(this,"spineData"),Is(this,"skeleton"),Is(this,"stateData"),Is(this,"state"),Is(this,"slotContainers"),Is(this,"tempClipContainers"),Is(this,"localDelayLimit"),Is(this,"_autoUpdate"),Is(this,"_visible"),Is(this,"_debug"),Is(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),l=this.newContainer();if(this.slotContainers.push(l),this.addChild(l),this.tempClipContainers.push(null),!!r)if(r.type===Be.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,l.addChild(i)}else if(r.type===Be.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,l.addChild(h)}else r.type===Be.Clipping&&(this.createGraphics(n,r),l.addChild(n.clippingContainer),l.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?Tx.prototype.autoUpdateTransform:Et.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=V.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:y1.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=w1(this.spineData.version||this.spineData.spine.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Om.VER42&&Dm.update);const n=this.skeleton.slots,r=this.color;let l=null,h=null;r?(l=r.light,h=r.dark):l=this.tintRgb;for(let u=0,m=n.length;u<m;u++){const c=n[u],g=c.getAttachment(),p=this.slotContainers[u];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(c,g);let w=g.region;const x=g.color;switch(g!=null&&g.type){case Be.Region:if(p.transform.setFromMatrix(c.bone.matrix),w=g.region,c.currentMesh&&(c.currentMesh.visible=!1,c.currentMesh=null,c.currentMeshId=void 0,c.currentMeshName=void 0),!w){c.currentSprite&&(c.currentSprite.renderable=!1);break}if(!c.currentSpriteName||c.currentSpriteName!==g.name){const C=g.name;if(c.currentSprite&&(c.currentSprite.visible=!1),c.sprites=c.sprites||{},c.sprites[C]!==void 0)c.sprites[C].visible=!0;else{const v=this.createSprite(c,g,C);p.addChild(v)}c.currentSprite=c.sprites[C],c.currentSpriteName=C}c.currentSprite.renderable=!0,c.hackRegion||this.setSpriteRegion(g,c.currentSprite,w),c.currentSprite.color?y=c.currentSprite.color:(Oi[0]=l[0]*c.color.r*x.r,Oi[1]=l[1]*c.color.g*x.g,Oi[2]=l[2]*c.color.b*x.b,c.currentSprite.tint=V.utils.rgb2hex(Oi)),c.currentSprite.blendMode=c.blendMode;break;case Be.Mesh:if(c.currentSprite){c.currentSprite.visible=!1,c.currentSprite=null,c.currentSpriteName=void 0;const C=new V.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){c.currentMesh&&(c.currentMesh.renderable=!1);break}const S=g.id;if(c.currentMeshId===void 0||c.currentMeshId!==S){const C=S;if(c.currentMesh&&(c.currentMesh.visible=!1),c.meshes=c.meshes||{},c.meshes[C]!==void 0)c.meshes[C].visible=!0;else{const v=this.createMesh(c,g);p.addChild(v)}c.currentMesh=c.meshes[C],c.currentMeshName=g.name,c.currentMeshId=C}c.currentMesh.renderable=!0,g.computeWorldVerticesOld(c,c.currentMesh.vertices),c.currentMesh.color?y=c.currentMesh.color:(Oi[0]=l[0]*c.color.r*x.r,Oi[1]=l[1]*c.color.g*x.g,Oi[2]=l[2]*c.color.b*x.b,c.currentMesh.tint=V.utils.rgb2hex(Oi)),c.currentMesh.blendMode=c.blendMode,c.hackRegion||this.setMeshRegion(g,c.currentMesh,w);break;case Be.Clipping:c.currentGraphics||(this.createGraphics(c,g),p.addChild(c.clippingContainer),p.addChild(c.currentGraphics)),this.updateGraphics(c,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let b=c.color.r*x.r,S=c.color.g*x.g,C=c.color.b*x.b;y.setLight(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C)),c.darkColor?(b=c.darkColor.r,S=c.darkColor.g,C=c.darkColor.b):(b=0,S=0,C=0),y.setDark(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C))}p.alpha=c.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let u=0,m=i.length;u<m;u++){const c=n[i[u].data.index],g=this.slotContainers[i[u].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),c.currentGraphics&&c.getAttachment())o=c.clippingContainer,a=c.getAttachment(),o.children.length=0,this.children[u]=g,a.endSlot===c.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[u];p||(p=this.tempClipContainers[u]=this.newContainer(),p.visible=!1),this.children[u]=p,g.parent=null,o.addChild(g),a.endSlot==c.data&&(o.renderable=!0,o=null,a=null)}else this.children[u]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*nt.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Et.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,l=this.newSprite(r);return l.anchor.set(.5),n&&this.setSpriteRegion(e,l,e.region),t.sprites=t.sprites||{},t.sprites[s]=l,l}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),V.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new V.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let l=r.region;return e?(l=new Lm,l.texture=e,l.size=s,n.hackRegion=l,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,l):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,l),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),l=this.skeleton.getAttachmentByName(t,e);l.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=l.region;return s?(a=new Lm,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Et.Container}newSprite(t){return new v1(t)}newGraphics(){return new le.Graphics}newMesh(t,e,s,n,r){return new A1(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let l=0,h=this.skeleton.slots.length;l<h;l++){const i=this.skeleton.slots[l],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};Is(Wm,"clippingPolygon",[]);let Um=Wm;Object.defineProperty(Um.prototype,"visible",{get(){return this._visible},set(f){f!==this._visible&&(this._visible=f,f&&(this.lastTime=0))}});var M1=Object.defineProperty,T1=(f,t,e)=>t in f?M1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Wi=(f,t,e)=>T1(f,typeof t!="symbol"?t+"":t,e);let nc=class{constructor(t){if(Wi(this,"name"),Wi(this,"type"),t==null)throw new Error("name cannot be null.");this.name=t}};const qm=class Ex extends nc{constructor(t){super(t),Wi(this,"id",(Ex.nextID++&65535)<<11),Wi(this,"bones"),Wi(this,"vertices"),Wi(this,"worldVerticesLength",0),Wi(this,"deformAttachment",this)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,l){s=r+(s>>1)*l;const h=t.bone.skeleton,i=t.deform;let a=this.vertices;const o=this.bones;if(o==null){i.length>0&&(a=i);const c=t.bone.matrix,g=c.tx,p=c.ty,y=c.a,w=c.c,x=c.b,b=c.d;for(let S=e,C=r;C<s;S+=2,C+=l){const v=a[S],A=a[S+1];n[C]=v*y+A*w+g,n[C+1]=v*x+A*b+p}return}let d=0,u=0;for(let c=0;c<e;c+=2){const g=o[d];d+=g+1,u+=g}const m=h.bones;if(i.length==0)for(let c=r,g=u*3;c<s;c+=l){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const x=m[o[d]].matrix,b=a[g],S=a[g+1],C=a[g+2];p+=(b*x.a+S*x.c+x.tx)*C,y+=(b*x.b+S*x.d+x.ty)*C}n[c]=p,n[c+1]=y}else{const c=i;for(let g=r,p=u*3,y=u<<1;g<s;g+=l){let w=0,x=0,b=o[d++];for(b+=d;d<b;d++,p+=3,y+=2){const S=m[o[d]].matrix,C=a[p]+c[y],v=a[p+1]+c[y+1],A=a[p+2];w+=(C*S.a+v*S.c+S.tx)*A,x+=(C*S.b+v*S.d+S.ty)*A}n[g]=w,n[g+1]=x}}}copyTo(t){this.bones!=null?(t.bones=new Array(this.bones.length),dt.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices!=null?(t.vertices=dt.newFloatArray(this.vertices.length),dt.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};Wi(qm,"nextID",0);let Ra=qm;var E1=Object.defineProperty,I1=(f,t,e)=>t in f?E1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,si=(f,t,e)=>I1(f,typeof t!="symbol"?t+"":t,e);let rc=class{constructor(t,e){if(si(this,"blendMode"),si(this,"data"),si(this,"bone"),si(this,"color"),si(this,"darkColor"),si(this,"attachment"),si(this,"attachmentTime"),si(this,"attachmentState"),si(this,"deform",new Array),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new ne,this.darkColor=t.darkColor==null?null:new ne,this.setToSetupPose(),this.blendMode=this.data.blendMode}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};var k1=Object.defineProperty,P1=(f,t,e)=>t in f?k1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,vt=(f,t,e)=>P1(f,typeof t!="symbol"?t+"":t,e);const Bt=class bs extends nc{constructor(t){super(t),vt(this,"type",Be.Region),vt(this,"x",0),vt(this,"y",0),vt(this,"scaleX",1),vt(this,"scaleY",1),vt(this,"rotation",0),vt(this,"width",0),vt(this,"height",0),vt(this,"color",new ne(1,1,1,1)),vt(this,"path"),vt(this,"rendererObject"),vt(this,"region"),vt(this,"offset",dt.newFloatArray(8)),vt(this,"uvs",dt.newFloatArray(8)),vt(this,"tempColor",new ne(1,1,1,1))}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*t,n=-this.height/2*this.scaleY+this.region.offsetY*e,r=s+this.region.width*t,l=n+this.region.height*e,h=this.rotation*Math.PI/180,i=Math.cos(h),a=Math.sin(h),o=s*i+this.x,d=s*a,u=n*i+this.y,m=n*a,c=r*i+this.x,g=r*a,p=l*i+this.y,y=l*a,w=this.offset;w[bs.OX1]=o-m,w[bs.OY1]=u+d,w[bs.OX2]=o-y,w[bs.OY2]=p+d,w[bs.OX3]=c-y,w[bs.OY3]=p+g,w[bs.OX4]=c-m,w[bs.OY4]=u+g}setRegion(t){this.region=t;const e=this.uvs;t.rotate?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,s,n){const r=this.offset,l=t instanceof rc?t.bone.matrix:t.matrix,h=l.tx,i=l.ty,a=l.a,o=l.c,d=l.b,u=l.d;let m=0,c=0;m=r[bs.OX1],c=r[bs.OY1],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i,s+=n,m=r[bs.OX2],c=r[bs.OY2],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i,s+=n,m=r[bs.OX3],c=r[bs.OY3],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i,s+=n,m=r[bs.OX4],c=r[bs.OY4],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i}copy(){const t=new bs(this.name);return t.region=this.region,t.rendererObject=this.rendererObject,t.path=this.path,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,dt.arrayCopy(this.uvs,0,t.uvs,0,8),dt.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t}};vt(Bt,"OX1",0),vt(Bt,"OY1",1),vt(Bt,"OX2",2),vt(Bt,"OY2",3),vt(Bt,"OX3",4),vt(Bt,"OY3",5),vt(Bt,"OX4",6),vt(Bt,"OY4",7),vt(Bt,"X1",0),vt(Bt,"Y1",1),vt(Bt,"C1R",2),vt(Bt,"C1G",3),vt(Bt,"C1B",4),vt(Bt,"C1A",5),vt(Bt,"U1",6),vt(Bt,"V1",7),vt(Bt,"X2",8),vt(Bt,"Y2",9),vt(Bt,"C2R",10),vt(Bt,"C2G",11),vt(Bt,"C2B",12),vt(Bt,"C2A",13),vt(Bt,"U2",14),vt(Bt,"V2",15),vt(Bt,"X3",16),vt(Bt,"Y3",17),vt(Bt,"C3R",18),vt(Bt,"C3G",19),vt(Bt,"C3B",20),vt(Bt,"C3A",21),vt(Bt,"U3",22),vt(Bt,"V3",23),vt(Bt,"X4",24),vt(Bt,"Y4",25),vt(Bt,"C4R",26),vt(Bt,"C4G",27),vt(Bt,"C4B",28),vt(Bt,"C4A",29),vt(Bt,"U4",30),vt(Bt,"V4",31);let ic=Bt;var R1=Object.defineProperty,Y1=(f,t,e)=>t in f?R1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ya=(f,t,e)=>Y1(f,typeof t!="symbol"?t+"":t,e);const zm=class Ix{constructor(t){Ya(this,"centerX",0),Ya(this,"centerY",0),Ya(this,"radius",0),Ya(this,"angle",0),Ya(this,"worldX",0),Ya(this,"worldY",0),this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,e,s,n){const r=this.angle*nt.degreesToRadians,l=t.x-this.worldX,h=t.y-this.worldY,i=Math.sqrt(l*l+h*h);if(i<this.radius){const a=Ix.interpolation.apply(0,r,(this.radius-i)/this.radius),o=Math.cos(a),d=Math.sin(a);t.x=o*l-d*h+this.worldX,t.y=d*l+o*h+this.worldY}}end(){}};Ya(zm,"interpolation",new g1(2));let F1=zm;var it=(f=>(f[f.setup=0]="setup",f[f.first=1]="first",f[f.replace=2]="replace",f[f.add=3]="add",f))(it||{}),mn=(f=>(f[f.mixIn=0]="mixIn",f[f.mixOut=1]="mixOut",f))(mn||{}),B1=Object.defineProperty,X1=(f,t,e)=>t in f?B1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Q=(f,t,e)=>X1(f,typeof t!="symbol"?t+"":t,e);let Xe=class{constructor(t,e,s){if(Q(this,"name"),Q(this,"timelines"),Q(this,"timelineIds"),Q(this,"duration"),t==null)throw new Error("name cannot be null.");if(e==null)throw new Error("timelines cannot be null.");this.name=t,this.timelines=e,this.timelineIds=[];for(let n=0;n<e.length;n++)this.timelineIds[e[n].getPropertyId()]=!0;this.duration=s}hasTimeline(t){return this.timelineIds[t]==!0}apply(t,e,s,n,r,l,h,i){if(t==null)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,l,h,i)}static binarySearch(t,e,s=1){let n=0,r=t.length/s-2;if(r==0)return s;let l=r>>>1;for(;;){if(t[(l+1)*s]<=e?n=l+1:r=l,n==r)return(n+1)*s;l=n+r>>>1}}static linearSearch(t,e,s){for(let n=0,r=t.length-s;n<=r;n+=s)if(t[n]>e)return n;return-1}};var Gm=(f=>(f[f.rotate=0]="rotate",f[f.translate=1]="translate",f[f.scale=2]="scale",f[f.shear=3]="shear",f[f.attachment=4]="attachment",f[f.color=5]="color",f[f.deform=6]="deform",f[f.event=7]="event",f[f.drawOrder=8]="drawOrder",f[f.ikConstraint=9]="ikConstraint",f[f.transformConstraint=10]="transformConstraint",f[f.pathConstraintPosition=11]="pathConstraintPosition",f[f.pathConstraintSpacing=12]="pathConstraintSpacing",f[f.pathConstraintMix=13]="pathConstraintMix",f[f.twoColor=14]="twoColor",f))(Gm||{});const sl=class ze{constructor(t){if(Q(this,"curves"),t<=0)throw new Error(`frameCount must be > 0: ${t}`);this.curves=dt.newFloatArray((t-1)*ze.BEZIER_SIZE)}getFrameCount(){return this.curves.length/ze.BEZIER_SIZE+1}setLinear(t){this.curves[t*ze.BEZIER_SIZE]=ze.LINEAR}setStepped(t){this.curves[t*ze.BEZIER_SIZE]=ze.STEPPED}getCurveType(t){const e=t*ze.BEZIER_SIZE;if(e==this.curves.length)return ze.LINEAR;const s=this.curves[e];return s==ze.LINEAR?ze.LINEAR:s==ze.STEPPED?ze.STEPPED:ze.BEZIER}setCurve(t,e,s,n,r){const l=(-e*2+n)*.03,h=(-s*2+r)*.03,i=((e-n)*3+1)*.006,a=((s-r)*3+1)*.006;let o=l*2+i,d=h*2+a,u=e*.3+l+i*.16666667,m=s*.3+h+a*.16666667,c=t*ze.BEZIER_SIZE;const g=this.curves;g[c++]=ze.BEZIER;let p=u,y=m;for(let w=c+ze.BEZIER_SIZE-1;c<w;c+=2)g[c]=p,g[c+1]=y,u+=o,m+=d,o+=i,d+=a,p+=u,y+=m}getCurvePercent(t,e){e=nt.clamp(e,0,1);const s=this.curves;let n=t*ze.BEZIER_SIZE;const r=s[n];if(r==ze.LINEAR)return e;if(r==ze.STEPPED)return 0;n++;let l=0;for(let i=n,a=n+ze.BEZIER_SIZE-1;n<a;n+=2)if(l=s[n],l>=e){let o,d;return n==i?(o=0,d=0):(o=s[n-2],d=s[n-1]),d+(s[n+1]-d)*(e-o)/(l-o)}const h=s[n-1];return h+(1-h)*(e-l)/(1-l)}};Q(sl,"LINEAR",0),Q(sl,"STEPPED",1),Q(sl,"BEZIER",2),Q(sl,"BEZIER_SIZE",10*2-1);let Xr=sl;const nl=class ua extends Xr{constructor(t){super(t),Q(this,"boneIndex"),Q(this,"frames"),this.frames=dt.newFloatArray(t<<1)}getPropertyId(){return 0+this.boneIndex}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+ua.ROTATION]=s}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(l){case it.setup:a.rotation=a.data.rotation;return;case it.first:const g=a.data.rotation-a.rotation;a.rotation+=(g-(16384-(16384.499999999996-g/360|0))*360)*r}return}if(s>=i[i.length-ua.ENTRIES]){let g=i[i.length+ua.PREV_ROTATION];switch(l){case it.setup:a.rotation=a.data.rotation+g*r;break;case it.first:case it.replace:g+=a.data.rotation-a.rotation,g-=(16384-(16384.499999999996-g/360|0))*360;case it.add:a.rotation+=g*r}return}const o=Xe.binarySearch(i,s,ua.ENTRIES),d=i[o+ua.PREV_ROTATION],u=i[o],m=this.getCurvePercent((o>>1)-1,1-(s-u)/(i[o+ua.PREV_TIME]-u));let c=i[o+ua.ROTATION]-d;switch(c=d+(c-(16384-(16384.499999999996-c/360|0))*360)*m,l){case it.setup:a.rotation=a.data.rotation+(c-(16384-(16384.499999999996-c/360|0))*360)*r;break;case it.first:case it.replace:c+=a.data.rotation-a.rotation;case it.add:a.rotation+=(c-(16384-(16384.499999999996-c/360|0))*360)*r}}};Q(nl,"ENTRIES",2),Q(nl,"PREV_TIME",-2),Q(nl,"PREV_ROTATION",-1),Q(nl,"ROTATION",1);let Pn=nl;const Fa=class on extends Xr{constructor(t){super(t),Q(this,"boneIndex"),Q(this,"frames"),this.frames=dt.newFloatArray(t*on.ENTRIES)}getPropertyId(){return(1<<24)+this.boneIndex}setFrame(t,e,s,n){t*=on.ENTRIES,this.frames[t]=e,this.frames[t+on.X]=s,this.frames[t+on.Y]=n}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(l){case it.setup:a.x=a.data.x,a.y=a.data.y;return;case it.first:a.x+=(a.data.x-a.x)*r,a.y+=(a.data.y-a.y)*r}return}let o=0,d=0;if(s>=i[i.length-on.ENTRIES])o=i[i.length+on.PREV_X],d=i[i.length+on.PREV_Y];else{const u=Xe.binarySearch(i,s,on.ENTRIES);o=i[u+on.PREV_X],d=i[u+on.PREV_Y];const m=i[u],c=this.getCurvePercent(u/on.ENTRIES-1,1-(s-m)/(i[u+on.PREV_TIME]-m));o+=(i[u+on.X]-o)*c,d+=(i[u+on.Y]-d)*c}switch(l){case it.setup:a.x=a.data.x+o*r,a.y=a.data.y+d*r;break;case it.first:case it.replace:a.x+=(a.data.x+o-a.x)*r,a.y+=(a.data.y+d-a.y)*r;break;case it.add:a.x+=o*r,a.y+=d*r}}};Q(Fa,"ENTRIES",3),Q(Fa,"PREV_TIME",-3),Q(Fa,"PREV_X",-2),Q(Fa,"PREV_Y",-1),Q(Fa,"X",1),Q(Fa,"Y",2);let Ba=Fa,ac=class kr extends Ba{constructor(t){super(t)}getPropertyId(){return(2<<24)+this.boneIndex}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(l){case it.setup:a.scaleX=a.data.scaleX,a.scaleY=a.data.scaleY;return;case it.first:a.scaleX+=(a.data.scaleX-a.scaleX)*r,a.scaleY+=(a.data.scaleY-a.scaleY)*r}return}let o=0,d=0;if(s>=i[i.length-kr.ENTRIES])o=i[i.length+kr.PREV_X]*a.data.scaleX,d=i[i.length+kr.PREV_Y]*a.data.scaleY;else{const u=Xe.binarySearch(i,s,kr.ENTRIES);o=i[u+kr.PREV_X],d=i[u+kr.PREV_Y];const m=i[u],c=this.getCurvePercent(u/kr.ENTRIES-1,1-(s-m)/(i[u+kr.PREV_TIME]-m));o=(o+(i[u+kr.X]-o)*c)*a.data.scaleX,d=(d+(i[u+kr.Y]-d)*c)*a.data.scaleY}if(r==1)l==it.add?(a.scaleX+=o-a.data.scaleX,a.scaleY+=d-a.data.scaleY):(a.scaleX=o,a.scaleY=d);else{let u=0,m=0;if(h==mn.mixOut)switch(l){case it.setup:u=a.data.scaleX,m=a.data.scaleY,a.scaleX=u+(Math.abs(o)*nt.signum(u)-u)*r,a.scaleY=m+(Math.abs(d)*nt.signum(m)-m)*r;break;case it.first:case it.replace:u=a.scaleX,m=a.scaleY,a.scaleX=u+(Math.abs(o)*nt.signum(u)-u)*r,a.scaleY=m+(Math.abs(d)*nt.signum(m)-m)*r;break;case it.add:u=a.scaleX,m=a.scaleY,a.scaleX=u+(Math.abs(o)*nt.signum(u)-a.data.scaleX)*r,a.scaleY=m+(Math.abs(d)*nt.signum(m)-a.data.scaleY)*r}else switch(l){case it.setup:u=Math.abs(a.data.scaleX)*nt.signum(o),m=Math.abs(a.data.scaleY)*nt.signum(d),a.scaleX=u+(o-u)*r,a.scaleY=m+(d-m)*r;break;case it.first:case it.replace:u=Math.abs(a.scaleX)*nt.signum(o),m=Math.abs(a.scaleY)*nt.signum(d),a.scaleX=u+(o-u)*r,a.scaleY=m+(d-m)*r;break;case it.add:u=nt.signum(o),m=nt.signum(d),a.scaleX=Math.abs(a.scaleX)*u+(o-Math.abs(a.data.scaleX)*u)*r,a.scaleY=Math.abs(a.scaleY)*m+(d-Math.abs(a.data.scaleY)*m)*r}}}},oc=class Pr extends Ba{constructor(t){super(t)}getPropertyId(){return(3<<24)+this.boneIndex}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.bones[this.boneIndex];if(!a.active)return;if(s<i[0]){switch(l){case it.setup:a.shearX=a.data.shearX,a.shearY=a.data.shearY;return;case it.first:a.shearX+=(a.data.shearX-a.shearX)*r,a.shearY+=(a.data.shearY-a.shearY)*r}return}let o=0,d=0;if(s>=i[i.length-Pr.ENTRIES])o=i[i.length+Pr.PREV_X],d=i[i.length+Pr.PREV_Y];else{const u=Xe.binarySearch(i,s,Pr.ENTRIES);o=i[u+Pr.PREV_X],d=i[u+Pr.PREV_Y];const m=i[u],c=this.getCurvePercent(u/Pr.ENTRIES-1,1-(s-m)/(i[u+Pr.PREV_TIME]-m));o=o+(i[u+Pr.X]-o)*c,d=d+(i[u+Pr.Y]-d)*c}switch(l){case it.setup:a.shearX=a.data.shearX+o*r,a.shearY=a.data.shearY+d*r;break;case it.first:case it.replace:a.shearX+=(a.data.shearX+o-a.shearX)*r,a.shearY+=(a.data.shearY+d-a.shearY)*r;break;case it.add:a.shearX+=o*r,a.shearY+=d*r}}};const tr=class Ae extends Xr{constructor(t){super(t),Q(this,"slotIndex"),Q(this,"frames"),this.frames=dt.newFloatArray(t*Ae.ENTRIES)}getPropertyId(){return(5<<24)+this.slotIndex}setFrame(t,e,s,n,r,l){t*=Ae.ENTRIES,this.frames[t]=e,this.frames[t+Ae.R]=s,this.frames[t+Ae.G]=n,this.frames[t+Ae.B]=r,this.frames[t+Ae.A]=l}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames;if(s<a[0]){switch(l){case it.setup:i.color.setFromColor(i.data.color);return;case it.first:const c=i.color,g=i.data.color;c.add((g.r-c.r)*r,(g.g-c.g)*r,(g.b-c.b)*r,(g.a-c.a)*r)}return}let o=0,d=0,u=0,m=0;if(s>=a[a.length-Ae.ENTRIES]){const c=a.length;o=a[c+Ae.PREV_R],d=a[c+Ae.PREV_G],u=a[c+Ae.PREV_B],m=a[c+Ae.PREV_A]}else{const c=Xe.binarySearch(a,s,Ae.ENTRIES);o=a[c+Ae.PREV_R],d=a[c+Ae.PREV_G],u=a[c+Ae.PREV_B],m=a[c+Ae.PREV_A];const g=a[c],p=this.getCurvePercent(c/Ae.ENTRIES-1,1-(s-g)/(a[c+Ae.PREV_TIME]-g));o+=(a[c+Ae.R]-o)*p,d+=(a[c+Ae.G]-d)*p,u+=(a[c+Ae.B]-u)*p,m+=(a[c+Ae.A]-m)*p}if(r==1)i.color.set(o,d,u,m);else{const c=i.color;l==it.setup&&c.setFromColor(i.data.color),c.add((o-c.r)*r,(d-c.g)*r,(u-c.b)*r,(m-c.a)*r)}}};Q(tr,"ENTRIES",5),Q(tr,"PREV_TIME",-5),Q(tr,"PREV_R",-4),Q(tr,"PREV_G",-3),Q(tr,"PREV_B",-2),Q(tr,"PREV_A",-1),Q(tr,"R",1),Q(tr,"G",2),Q(tr,"B",3),Q(tr,"A",4);let rl=tr;const ks=class ee extends Xr{constructor(t){super(t),Q(this,"slotIndex"),Q(this,"frames"),this.frames=dt.newFloatArray(t*ee.ENTRIES)}getPropertyId(){return(14<<24)+this.slotIndex}setFrame(t,e,s,n,r,l,h,i,a){t*=ee.ENTRIES,this.frames[t]=e,this.frames[t+ee.R]=s,this.frames[t+ee.G]=n,this.frames[t+ee.B]=r,this.frames[t+ee.A]=l,this.frames[t+ee.R2]=h,this.frames[t+ee.G2]=i,this.frames[t+ee.B2]=a}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames;if(s<a[0]){switch(l){case it.setup:i.color.setFromColor(i.data.color),i.darkColor.setFromColor(i.data.darkColor);return;case it.first:const y=i.color,w=i.darkColor,x=i.data.color,b=i.data.darkColor;y.add((x.r-y.r)*r,(x.g-y.g)*r,(x.b-y.b)*r,(x.a-y.a)*r),w.add((b.r-w.r)*r,(b.g-w.g)*r,(b.b-w.b)*r,0)}return}let o=0,d=0,u=0,m=0,c=0,g=0,p=0;if(s>=a[a.length-ee.ENTRIES]){const y=a.length;o=a[y+ee.PREV_R],d=a[y+ee.PREV_G],u=a[y+ee.PREV_B],m=a[y+ee.PREV_A],c=a[y+ee.PREV_R2],g=a[y+ee.PREV_G2],p=a[y+ee.PREV_B2]}else{const y=Xe.binarySearch(a,s,ee.ENTRIES);o=a[y+ee.PREV_R],d=a[y+ee.PREV_G],u=a[y+ee.PREV_B],m=a[y+ee.PREV_A],c=a[y+ee.PREV_R2],g=a[y+ee.PREV_G2],p=a[y+ee.PREV_B2];const w=a[y],x=this.getCurvePercent(y/ee.ENTRIES-1,1-(s-w)/(a[y+ee.PREV_TIME]-w));o+=(a[y+ee.R]-o)*x,d+=(a[y+ee.G]-d)*x,u+=(a[y+ee.B]-u)*x,m+=(a[y+ee.A]-m)*x,c+=(a[y+ee.R2]-c)*x,g+=(a[y+ee.G2]-g)*x,p+=(a[y+ee.B2]-p)*x}if(r==1)i.color.set(o,d,u,m),i.darkColor.set(c,g,p,1);else{const y=i.color,w=i.darkColor;l==it.setup&&(y.setFromColor(i.data.color),w.setFromColor(i.data.darkColor)),y.add((o-y.r)*r,(d-y.g)*r,(u-y.b)*r,(m-y.a)*r),w.add((c-w.r)*r,(g-w.g)*r,(p-w.b)*r,0)}}};Q(ks,"ENTRIES",8),Q(ks,"PREV_TIME",-8),Q(ks,"PREV_R",-7),Q(ks,"PREV_G",-6),Q(ks,"PREV_B",-5),Q(ks,"PREV_A",-4),Q(ks,"PREV_R2",-3),Q(ks,"PREV_G2",-2),Q(ks,"PREV_B2",-1),Q(ks,"R",1),Q(ks,"G",2),Q(ks,"B",3),Q(ks,"A",4),Q(ks,"R2",5),Q(ks,"G2",6),Q(ks,"B2",7);let il=ks,Xa=class{constructor(t){Q(this,"slotIndex"),Q(this,"frames"),Q(this,"attachmentNames"),this.frames=dt.newFloatArray(t),this.attachmentNames=new Array(t)}getPropertyId(){return(4<<24)+this.slotIndex}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;if(h==mn.mixOut){l==it.setup&&this.setAttachment(t,i,i.data.attachmentName);return}const a=this.frames;if(s<a[0]){(l==it.setup||l==it.first)&&this.setAttachment(t,i,i.data.attachmentName);return}let o=0;s>=a[a.length-1]?o=a.length-1:o=Xe.binarySearch(a,s,1)-1;const d=this.attachmentNames[o];t.slots[this.slotIndex].setAttachment(d==null?null:t.getAttachment(this.slotIndex,d))}setAttachment(t,e,s){e.setAttachment(s==null?null:t.getAttachment(this.slotIndex,s))}},Hm=null,lc=class extends Xr{constructor(t){super(t),Q(this,"slotIndex"),Q(this,"attachment"),Q(this,"frames"),Q(this,"frameVertices"),this.frames=dt.newFloatArray(t),this.frameVertices=new Array(t),Hm==null&&(Hm=dt.newFloatArray(64))}getPropertyId(){return(6<<27)+Number(this.attachment.id)+this.slotIndex}setFrame(t,e,s){this.frames[t]=e,this.frameVertices[t]=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.getAttachment();if(!(a instanceof Ra)||a.deformAttachment!=this.attachment)return;const o=i.deform;o.length==0&&(l=it.setup);const d=this.frameVertices,u=d[0].length,m=this.frames;if(s<m[0]){const b=a;switch(l){case it.setup:o.length=0;return;case it.first:if(r==1){o.length=0;break}const S=dt.setArraySize(o,u);if(b.bones==null){const C=b.vertices;for(let v=0;v<u;v++)S[v]+=(C[v]-S[v])*r}else{r=1-r;for(let C=0;C<u;C++)S[C]*=r}}return}const c=dt.setArraySize(o,u);if(s>=m[m.length-1]){const b=d[m.length-1];if(r==1)if(l==it.add){const S=a;if(S.bones==null){const C=S.vertices;for(let v=0;v<u;v++)c[v]+=b[v]-C[v]}else for(let C=0;C<u;C++)c[C]+=b[C]}else dt.arrayCopy(b,0,c,0,u);else switch(l){case it.setup:{const C=a;if(C.bones==null){const v=C.vertices;for(let A=0;A<u;A++){const M=v[A];c[A]=M+(b[A]-M)*r}}else for(let v=0;v<u;v++)c[v]=b[v]*r;break}case it.first:case it.replace:for(let C=0;C<u;C++)c[C]+=(b[C]-c[C])*r;break;case it.add:const S=a;if(S.bones==null){const C=S.vertices;for(let v=0;v<u;v++)c[v]+=(b[v]-C[v])*r}else for(let C=0;C<u;C++)c[C]+=b[C]*r}return}const g=Xe.binarySearch(m,s),p=d[g-1],y=d[g],w=m[g],x=this.getCurvePercent(g-1,1-(s-w)/(m[g-1]-w));if(r==1)if(l==it.add){const b=a;if(b.bones==null){const S=b.vertices;for(let C=0;C<u;C++){const v=p[C];c[C]+=v+(y[C]-v)*x-S[C]}}else for(let S=0;S<u;S++){const C=p[S];c[S]+=C+(y[S]-C)*x}}else for(let b=0;b<u;b++){const S=p[b];c[b]=S+(y[b]-S)*x}else switch(l){case it.setup:{const S=a;if(S.bones==null){const C=S.vertices;for(let v=0;v<u;v++){const A=p[v],M=C[v];c[v]=M+(A+(y[v]-A)*x-M)*r}}else for(let C=0;C<u;C++){const v=p[C];c[C]=(v+(y[C]-v)*x)*r}break}case it.first:case it.replace:for(let S=0;S<u;S++){const C=p[S];c[S]+=(C+(y[S]-C)*x-c[S])*r}break;case it.add:const b=a;if(b.bones==null){const S=b.vertices;for(let C=0;C<u;C++){const v=p[C];c[C]+=(v+(y[C]-v)*x-S[C])*r}}else for(let S=0;S<u;S++){const C=p[S];c[S]+=(C+(y[S]-C)*x)*r}}}},ah=class{constructor(t){Q(this,"frames"),Q(this,"events"),this.frames=dt.newFloatArray(t),this.events=new Array(t)}getPropertyId(){return 7<<24}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,l,h){if(n==null)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,l,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=Xe.binarySearch(i,e);const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}},po=class{constructor(t){Q(this,"frames"),Q(this,"drawOrders"),this.frames=dt.newFloatArray(t),this.drawOrders=new Array(t)}getPropertyId(){return 8<<24}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,l,h){const i=t.drawOrder,a=t.slots;if(h==mn.mixOut&&l==it.setup){dt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const o=this.frames;if(s<o[0]){(l==it.setup||l==it.first)&&dt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}let d=0;s>=o[o.length-1]?d=o.length-1:d=Xe.binarySearch(o,s)-1;const u=this.drawOrders[d];if(u==null)dt.arrayCopy(a,0,i,0,a.length);else for(let m=0,c=u.length;m<c;m++)i[m]=a[u[m]]}};const Rn=class se extends Xr{constructor(t){super(t),Q(this,"ikConstraintIndex"),Q(this,"frames"),this.frames=dt.newFloatArray(t*se.ENTRIES)}getPropertyId(){return(9<<24)+this.ikConstraintIndex}setFrame(t,e,s,n,r,l,h){t*=se.ENTRIES,this.frames[t]=e,this.frames[t+se.MIX]=s,this.frames[t+se.SOFTNESS]=n,this.frames[t+se.BEND_DIRECTION]=r,this.frames[t+se.COMPRESS]=l?1:0,this.frames[t+se.STRETCH]=h?1:0}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.ikConstraints[this.ikConstraintIndex];if(!a.active)return;if(s<i[0]){switch(l){case it.setup:a.mix=a.data.mix,a.softness=a.data.softness,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case it.first:a.mix+=(a.data.mix-a.mix)*r,a.softness+=(a.data.softness-a.softness)*r,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}if(s>=i[i.length-se.ENTRIES]){l==it.setup?(a.mix=a.data.mix+(i[i.length+se.PREV_MIX]-a.data.mix)*r,a.softness=a.data.softness+(i[i.length+se.PREV_SOFTNESS]-a.data.softness)*r,h==mn.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=i[i.length+se.PREV_BEND_DIRECTION],a.compress=i[i.length+se.PREV_COMPRESS]!=0,a.stretch=i[i.length+se.PREV_STRETCH]!=0)):(a.mix+=(i[i.length+se.PREV_MIX]-a.mix)*r,a.softness+=(i[i.length+se.PREV_SOFTNESS]-a.softness)*r,h==mn.mixIn&&(a.bendDirection=i[i.length+se.PREV_BEND_DIRECTION],a.compress=i[i.length+se.PREV_COMPRESS]!=0,a.stretch=i[i.length+se.PREV_STRETCH]!=0));return}const o=Xe.binarySearch(i,s,se.ENTRIES),d=i[o+se.PREV_MIX],u=i[o+se.PREV_SOFTNESS],m=i[o],c=this.getCurvePercent(o/se.ENTRIES-1,1-(s-m)/(i[o+se.PREV_TIME]-m));l==it.setup?(a.mix=a.data.mix+(d+(i[o+se.MIX]-d)*c-a.data.mix)*r,a.softness=a.data.softness+(u+(i[o+se.SOFTNESS]-u)*c-a.data.softness)*r,h==mn.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=i[o+se.PREV_BEND_DIRECTION],a.compress=i[o+se.PREV_COMPRESS]!=0,a.stretch=i[o+se.PREV_STRETCH]!=0)):(a.mix+=(d+(i[o+se.MIX]-d)*c-a.mix)*r,a.softness+=(u+(i[o+se.SOFTNESS]-u)*c-a.softness)*r,h==mn.mixIn&&(a.bendDirection=i[o+se.PREV_BEND_DIRECTION],a.compress=i[o+se.PREV_COMPRESS]!=0,a.stretch=i[o+se.PREV_STRETCH]!=0))}};Q(Rn,"ENTRIES",6),Q(Rn,"PREV_TIME",-6),Q(Rn,"PREV_MIX",-5),Q(Rn,"PREV_SOFTNESS",-4),Q(Rn,"PREV_BEND_DIRECTION",-3),Q(Rn,"PREV_COMPRESS",-2),Q(Rn,"PREV_STRETCH",-1),Q(Rn,"MIX",1),Q(Rn,"SOFTNESS",2),Q(Rn,"BEND_DIRECTION",3),Q(Rn,"COMPRESS",4),Q(Rn,"STRETCH",5);let al=Rn;const er=class Me extends Xr{constructor(t){super(t),Q(this,"transformConstraintIndex"),Q(this,"frames"),this.frames=dt.newFloatArray(t*Me.ENTRIES)}getPropertyId(){return(10<<24)+this.transformConstraintIndex}setFrame(t,e,s,n,r,l){t*=Me.ENTRIES,this.frames[t]=e,this.frames[t+Me.ROTATE]=s,this.frames[t+Me.TRANSLATE]=n,this.frames[t+Me.SCALE]=r,this.frames[t+Me.SHEAR]=l}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.transformConstraints[this.transformConstraintIndex];if(!a.active)return;if(s<i[0]){const c=a.data;switch(l){case it.setup:a.rotateMix=c.rotateMix,a.translateMix=c.translateMix,a.scaleMix=c.scaleMix,a.shearMix=c.shearMix;return;case it.first:a.rotateMix+=(c.rotateMix-a.rotateMix)*r,a.translateMix+=(c.translateMix-a.translateMix)*r,a.scaleMix+=(c.scaleMix-a.scaleMix)*r,a.shearMix+=(c.shearMix-a.shearMix)*r}return}let o=0,d=0,u=0,m=0;if(s>=i[i.length-Me.ENTRIES]){const c=i.length;o=i[c+Me.PREV_ROTATE],d=i[c+Me.PREV_TRANSLATE],u=i[c+Me.PREV_SCALE],m=i[c+Me.PREV_SHEAR]}else{const c=Xe.binarySearch(i,s,Me.ENTRIES);o=i[c+Me.PREV_ROTATE],d=i[c+Me.PREV_TRANSLATE],u=i[c+Me.PREV_SCALE],m=i[c+Me.PREV_SHEAR];const g=i[c],p=this.getCurvePercent(c/Me.ENTRIES-1,1-(s-g)/(i[c+Me.PREV_TIME]-g));o+=(i[c+Me.ROTATE]-o)*p,d+=(i[c+Me.TRANSLATE]-d)*p,u+=(i[c+Me.SCALE]-u)*p,m+=(i[c+Me.SHEAR]-m)*p}if(l==it.setup){const c=a.data;a.rotateMix=c.rotateMix+(o-c.rotateMix)*r,a.translateMix=c.translateMix+(d-c.translateMix)*r,a.scaleMix=c.scaleMix+(u-c.scaleMix)*r,a.shearMix=c.shearMix+(m-c.shearMix)*r}else a.rotateMix+=(o-a.rotateMix)*r,a.translateMix+=(d-a.translateMix)*r,a.scaleMix+=(u-a.scaleMix)*r,a.shearMix+=(m-a.shearMix)*r}};Q(er,"ENTRIES",5),Q(er,"PREV_TIME",-5),Q(er,"PREV_ROTATE",-4),Q(er,"PREV_TRANSLATE",-3),Q(er,"PREV_SCALE",-2),Q(er,"PREV_SHEAR",-1),Q(er,"ROTATE",1),Q(er,"TRANSLATE",2),Q(er,"SCALE",3),Q(er,"SHEAR",4);let ol=er;const ll=class Rr extends Xr{constructor(t){super(t),Q(this,"pathConstraintIndex"),Q(this,"frames"),this.frames=dt.newFloatArray(t*Rr.ENTRIES)}getPropertyId(){return(11<<24)+this.pathConstraintIndex}setFrame(t,e,s){t*=Rr.ENTRIES,this.frames[t]=e,this.frames[t+Rr.VALUE]=s}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<i[0]){switch(l){case it.setup:a.position=a.data.position;return;case it.first:a.position+=(a.data.position-a.position)*r}return}let o=0;if(s>=i[i.length-Rr.ENTRIES])o=i[i.length+Rr.PREV_VALUE];else{const d=Xe.binarySearch(i,s,Rr.ENTRIES);o=i[d+Rr.PREV_VALUE];const u=i[d],m=this.getCurvePercent(d/Rr.ENTRIES-1,1-(s-u)/(i[d+Rr.PREV_TIME]-u));o+=(i[d+Rr.VALUE]-o)*m}l==it.setup?a.position=a.data.position+(o-a.data.position)*r:a.position+=(o-a.position)*r}};Q(ll,"ENTRIES",2),Q(ll,"PREV_TIME",-2),Q(ll,"PREV_VALUE",-1),Q(ll,"VALUE",1);let xo=ll,hc=class fa extends xo{constructor(t){super(t)}getPropertyId(){return(12<<24)+this.pathConstraintIndex}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<i[0]){switch(l){case it.setup:a.spacing=a.data.spacing;return;case it.first:a.spacing+=(a.data.spacing-a.spacing)*r}return}let o=0;if(s>=i[i.length-fa.ENTRIES])o=i[i.length+fa.PREV_VALUE];else{const d=Xe.binarySearch(i,s,fa.ENTRIES);o=i[d+fa.PREV_VALUE];const u=i[d],m=this.getCurvePercent(d/fa.ENTRIES-1,1-(s-u)/(i[d+fa.PREV_TIME]-u));o+=(i[d+fa.VALUE]-o)*m}l==it.setup?a.spacing=a.data.spacing+(o-a.data.spacing)*r:a.spacing+=(o-a.spacing)*r}};const $a=class ln extends Xr{constructor(t){super(t),Q(this,"pathConstraintIndex"),Q(this,"frames"),this.frames=dt.newFloatArray(t*ln.ENTRIES)}getPropertyId(){return(13<<24)+this.pathConstraintIndex}setFrame(t,e,s,n){t*=ln.ENTRIES,this.frames[t]=e,this.frames[t+ln.ROTATE]=s,this.frames[t+ln.TRANSLATE]=n}apply(t,e,s,n,r,l,h){const i=this.frames,a=t.pathConstraints[this.pathConstraintIndex];if(!a.active)return;if(s<i[0]){switch(l){case it.setup:a.rotateMix=a.data.rotateMix,a.translateMix=a.data.translateMix;return;case it.first:a.rotateMix+=(a.data.rotateMix-a.rotateMix)*r,a.translateMix+=(a.data.translateMix-a.translateMix)*r}return}let o=0,d=0;if(s>=i[i.length-ln.ENTRIES])o=i[i.length+ln.PREV_ROTATE],d=i[i.length+ln.PREV_TRANSLATE];else{const u=Xe.binarySearch(i,s,ln.ENTRIES);o=i[u+ln.PREV_ROTATE],d=i[u+ln.PREV_TRANSLATE];const m=i[u],c=this.getCurvePercent(u/ln.ENTRIES-1,1-(s-m)/(i[u+ln.PREV_TIME]-m));o+=(i[u+ln.ROTATE]-o)*c,d+=(i[u+ln.TRANSLATE]-d)*c}l==it.setup?(a.rotateMix=a.data.rotateMix+(o-a.data.rotateMix)*r,a.translateMix=a.data.translateMix+(d-a.data.translateMix)*r):(a.rotateMix+=(o-a.rotateMix)*r,a.translateMix+=(d-a.translateMix)*r)}};Q($a,"ENTRIES",3),Q($a,"PREV_TIME",-3),Q($a,"PREV_ROTATE",-2),Q($a,"PREV_TRANSLATE",-1),Q($a,"ROTATE",1),Q($a,"TRANSLATE",2);let hl=$a;var $1=Object.defineProperty,N1=(f,t,e)=>t in f?$1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ut=(f,t,e)=>N1(f,typeof t!="symbol"?t+"":t,e);const Ln=class Te{constructor(t){ut(this,"data"),ut(this,"tracks",new Array),ut(this,"timeScale",1),ut(this,"unkeyedState",0),ut(this,"events",new Array),ut(this,"listeners",new Array),ut(this,"queue",new Qm(this)),ut(this,"propertyIDs",new u1),ut(this,"animationsChanged",!1),ut(this,"trackEntryPool",new _m(()=>new Zm)),ut(this,"onComplete"),ut(this,"onEvent"),ut(this,"onStart"),ut(this,"onEnd"),this.data=t}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r==null)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let l=t*r.timeScale;if(r.delay>0){if(r.delay-=l,r.delay>0)continue;l=-r.delay,r.delay=0}let h=r.next;if(h!=null){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=l,this.setCurrent(s,h,!0);h.mixingFrom!=null;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&r.mixingFrom==null){e[s]=null,this.queue.end(r),this.disposeNext(r);continue}if(r.mixingFrom!=null&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i!=null&&(i.mixingTo=null);i!=null;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=l}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(s==null)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom!=null&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(t==null)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let h=0,i=s.length;h<i;h++){const a=s[h];if(a==null||a.delay>0)continue;n=!0;const o=h==0?it.first:a.mixBlend;let d=a.alpha;a.mixingFrom!=null?d*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&a.next==null&&(d=0);const u=a.animationLast,m=a.getAnimationTime(),c=a.animation.timelines.length,g=a.animation.timelines;if(h==0&&d==1||o==it.add)for(let p=0;p<c;p++){dt.webkit602BugfixHelper(d,o);const y=g[p];y instanceof Xa?this.applyAttachmentTimeline(y,t,m,o,!0):y.apply(t,u,m,e,d,o,mn.mixIn)}else{const p=a.timelineMode,y=a.timelinesRotation.length==0;y&&dt.setArraySize(a.timelinesRotation,c<<1,null);const w=a.timelinesRotation;for(let x=0;x<c;x++){const b=g[x],S=p[x]==Te.SUBSEQUENT?o:it.setup;b instanceof Pn?this.applyRotateTimeline(b,t,m,d,S,w,x<<1,y):b instanceof Xa?this.applyAttachmentTimeline(b,t,m,o,!0):(dt.webkit602BugfixHelper(d,o),b.apply(t,u,m,e,d,S,mn.mixIn))}}this.queueEvents(a,m),e.length=0,a.nextAnimationLast=m,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+Te.SETUP,l=t.slots;for(let h=0,i=t.slots.length;h<i;h++){const a=l[h];if(a.attachmentState==r){const o=a.data.attachmentName;a.setAttachment(o==null?null:t.getAttachment(a.data.index,o))}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom!=null&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==it.first&&(s=it.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=it.first&&(s=n.mixBlend));const l=r<n.eventThreshold?this.events:null,h=r<n.attachmentThreshold,i=r<n.drawOrderThreshold,a=n.animationLast,o=n.getAnimationTime(),d=n.animation.timelines.length,u=n.animation.timelines,m=n.alpha*t.interruptAlpha,c=m*(1-r);if(s==it.add)for(let g=0;g<d;g++)u[g].apply(e,a,o,l,c,s,mn.mixOut);else{const g=n.timelineMode,p=n.timelineHoldMix,y=n.timelinesRotation.length==0;y&&dt.setArraySize(n.timelinesRotation,d<<1,null);const w=n.timelinesRotation;n.totalAlpha=0;for(let x=0;x<d;x++){const b=u[x];let S=mn.mixOut,C,v=0;switch(g[x]){case Te.SUBSEQUENT:if(!i&&b instanceof po)continue;C=s,v=c;break;case Te.FIRST:C=it.setup,v=c;break;case Te.HOLD_SUBSEQUENT:C=s,v=m;break;case Te.HOLD_FIRST:C=it.setup,v=m;break;default:C=it.setup;const A=p[x];v=m*Math.max(0,1-A.mixTime/A.mixDuration);break}n.totalAlpha+=v,b instanceof Pn?this.applyRotateTimeline(b,e,o,v,C,w,x<<1,y):b instanceof Xa?this.applyAttachmentTimeline(b,e,o,C,h):(dt.webkit602BugfixHelper(v,s),i&&b instanceof po&&C==it.setup&&(S=mn.mixIn),b.apply(e,a,o,l,v,C,S))}}return t.mixDuration>0&&this.queueEvents(n,o),this.events.length=0,n.nextAnimationLast=o,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(t,e,s,n,r){const l=e.slots[t.slotIndex];if(!l.bone.active)return;const h=t.frames;if(s<h[0])(n==it.setup||n==it.first)&&this.setAttachment(e,l,l.data.attachmentName,r);else{let i;s>=h[h.length-1]?i=h.length-1:i=Xe.binarySearch(h,s)-1,this.setAttachment(e,l,t.attachmentNames[i],r)}l.attachmentState<=this.unkeyedState&&(l.attachmentState=this.unkeyedState+Te.SETUP)}setAttachment(t,e,s,n){e.setAttachment(s==null?null:t.getAttachment(e.data.index,s)),n&&(e.attachmentState=this.unkeyedState+Te.CURRENT)}applyRotateTimeline(t,e,s,n,r,l,h,i){if(i&&(l[h]=0),n==1){t.apply(e,0,s,null,1,r,mn.mixIn);return}const a=t,o=a.frames,d=e.bones[a.boneIndex];if(!d.active)return;let u=0,m=0;if(s<o[0])switch(r){case it.setup:d.rotation=d.data.rotation;default:return;case it.first:u=d.rotation,m=d.data.rotation}else if(u=r==it.setup?d.data.rotation:d.rotation,s>=o[o.length-Pn.ENTRIES])m=d.data.rotation+o[o.length+Pn.PREV_ROTATION];else{const p=Xe.binarySearch(o,s,Pn.ENTRIES),y=o[p+Pn.PREV_ROTATION],w=o[p],x=a.getCurvePercent((p>>1)-1,1-(s-w)/(o[p+Pn.PREV_TIME]-w));m=o[p+Pn.ROTATION]-y,m-=(16384-(16384.499999999996-m/360|0))*360,m=y+m*x+d.data.rotation,m-=(16384-(16384.499999999996-m/360|0))*360}let c=0,g=m-u;if(g-=(16384-(16384.499999999996-g/360|0))*360,g==0)c=l[h];else{let p=0,y=0;i?(p=0,y=g):(p=l[h],y=l[h+1]);const w=g>0;let x=p>=0;nt.signum(y)!=nt.signum(g)&&Math.abs(y)<=90&&(Math.abs(p)>180&&(p+=360*nt.signum(p)),x=w),c=g+p-p%360,x!=w&&(c+=360*nt.signum(p)),l[h]=c}l[h+1]=g,u+=c*n,d.rotation=u-(16384-(16384.499999999996-u/360|0))*360}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,l=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<l)break;d.time>n||this.queue.event(t,d)}let o=!1;for(t.loop?o=r==0||l>t.trackTime%r:o=e>=n&&t.animationLast<n,o&&this.queue.complete(t);i<a;i++)h[i].time<s||this.queue.event(t,h[i])}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(e==null)return;this.queue.end(e),this.disposeNext(e);let s=e;for(;;){const n=s.mixingFrom;if(n==null)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,n!=null&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom!=null&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s){const n=this.data.skeletonData.findAnimation(e);if(n==null)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s){if(e==null)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r!=null&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.disposeNext(r),r=r.mixingFrom,n=!1):this.disposeNext(r));const l=this.trackEntry(t,e,s,r);return this.setCurrent(t,l,n),this.queue.drain(),l}addAnimation(t,e,s,n){const r=this.data.skeletonData.findAnimation(e);if(r==null)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s,n){if(e==null)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r!=null)for(;r.next!=null;)r=r.next;const l=this.trackEntry(t,e,s,r);if(r==null)this.setCurrent(t,l,!0),this.queue.drain();else if(r.next=l,n<=0){const h=r.animationEnd-r.animationStart;h!=0?(r.loop?n+=h*(1+(r.trackTime/h|0)):n+=Math.max(h,r.trackTime),n-=this.data.getMix(r.animation,e)):n=r.trackTime}return l.delay=n,l}setEmptyAnimation(t,e){const s=this.setAnimationWith(t,Te.emptyAnimation,!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e,s){s<=0&&(s-=e);const n=this.addAnimationWith(t,Te.emptyAnimation,!1,s);return n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r!=null&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(dt.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=n==null?0:this.data.getMix(n.animation,e),r.mixBlend=it.replace,r}disposeNext(t){let e=t.next;for(;e!=null;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();for(let t=0,e=this.tracks.length;t<e;t++){let s=this.tracks[t];if(s!=null){for(;s.mixingFrom!=null;)s=s.mixingFrom;do(s.mixingFrom==null||s.mixBlend!=it.add)&&this.computeHold(s),s=s.mixingTo;while(s!=null)}}}computeHold(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=dt.setArraySize(t.timelineMode,n);t.timelineHoldMix.length=0;const l=dt.setArraySize(t.timelineHoldMix,n),h=this.propertyIDs;if(e!=null&&e.holdPrevious){for(let i=0;i<n;i++)r[i]=h.add(s[i].getPropertyId())?Te.HOLD_FIRST:Te.HOLD_SUBSEQUENT;return}t:for(let i=0;i<n;i++){const a=s[i],o=a.getPropertyId();if(!h.add(o))r[i]=Te.SUBSEQUENT;else if(e==null||a instanceof Xa||a instanceof po||a instanceof ah||!e.animation.hasTimeline(o))r[i]=Te.FIRST;else{for(let d=e.mixingTo;d!=null;d=d.mixingTo)if(!d.animation.hasTimeline(o)){if(t.mixDuration>0){r[i]=Te.HOLD_MIX,l[i]=d;continue t}break}r[i]=Te.HOLD_FIRST}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(t==null)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){Te.deprecatedWarning1||(Te.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){Te.deprecatedWarning2||(Te.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return Te.deprecatedWarning3||(Te.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};ut(Ln,"emptyAnimation",new Xe("<empty>",[],0)),ut(Ln,"SUBSEQUENT",0),ut(Ln,"FIRST",1),ut(Ln,"HOLD_SUBSEQUENT",2),ut(Ln,"HOLD_FIRST",3),ut(Ln,"HOLD_MIX",4),ut(Ln,"SETUP",1),ut(Ln,"CURRENT",2),ut(Ln,"deprecatedWarning1",!1),ut(Ln,"deprecatedWarning2",!1),ut(Ln,"deprecatedWarning3",!1);let Km=Ln;const cc=class Ei{constructor(){ut(this,"animation"),ut(this,"next"),ut(this,"mixingFrom"),ut(this,"mixingTo"),ut(this,"listener"),ut(this,"trackIndex"),ut(this,"loop"),ut(this,"holdPrevious"),ut(this,"eventThreshold"),ut(this,"attachmentThreshold"),ut(this,"drawOrderThreshold"),ut(this,"animationStart"),ut(this,"animationEnd"),ut(this,"animationLast"),ut(this,"nextAnimationLast"),ut(this,"delay"),ut(this,"trackTime"),ut(this,"trackLast"),ut(this,"nextTrackLast"),ut(this,"trackEnd"),ut(this,"timeScale"),ut(this,"alpha"),ut(this,"mixTime"),ut(this,"mixDuration"),ut(this,"interruptAlpha"),ut(this,"totalAlpha"),ut(this,"mixBlend",it.replace),ut(this,"timelineMode",new Array),ut(this,"timelineHoldMix",new Array),ut(this,"timelinesRotation",new Array),ut(this,"onComplete"),ut(this,"onEvent"),ut(this,"onStart"),ut(this,"onEnd")}reset(){this.next=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}get time(){return Ei.deprecatedWarning1||(Ei.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Ei.deprecatedWarning1||(Ei.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Ei.deprecatedWarning2||(Ei.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Ei.deprecatedWarning2||(Ei.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};ut(cc,"deprecatedWarning1",!1),ut(cc,"deprecatedWarning2",!1);let Zm=cc;const Jm=class Pf{constructor(t){ut(this,"objects",[]),ut(this,"drainDisabled",!1),ut(this,"animState"),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}deprecateStuff(){return Pf.deprecatedWarning1||(Pf.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: onComplete, onStart, onEnd, onEvent art deprecated, please use listeners from now on. 'state.addListener({ complete: function(track, event) { } })'")),!0}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener!=null&&r.listener.start&&r.listener.start(r);for(let i=0;i<e.length;i++)e[i].start&&e[i].start(r);r.onStart&&this.deprecateStuff()&&r.onStart(r.trackIndex),this.animState.onStart&&this.deprecateStuff()&&this.deprecateStuff&&this.animState.onStart(r.trackIndex);break;case 1:r.listener!=null&&r.listener.interrupt&&r.listener.interrupt(r);for(let i=0;i<e.length;i++)e[i].interrupt&&e[i].interrupt(r);break;case 2:r.listener!=null&&r.listener.end&&r.listener.end(r);for(let i=0;i<e.length;i++)e[i].end&&e[i].end(r);r.onEnd&&this.deprecateStuff()&&r.onEnd(r.trackIndex),this.animState.onEnd&&this.deprecateStuff()&&this.animState.onEnd(r.trackIndex);case 3:r.listener!=null&&r.listener.dispose&&r.listener.dispose(r);for(let i=0;i<e.length;i++)e[i].dispose&&e[i].dispose(r);this.animState.trackEntryPool.free(r);break;case 4:r.listener!=null&&r.listener.complete&&r.listener.complete(r);for(let i=0;i<e.length;i++)e[i].complete&&e[i].complete(r);const l=nt.toInt(r.loopsCount());r.onComplete&&this.deprecateStuff()&&r.onComplete(r.trackIndex,l),this.animState.onComplete&&this.deprecateStuff()&&this.animState.onComplete(r.trackIndex,l);break;case 5:const h=t[s+++2];r.listener!=null&&r.listener.event&&r.listener.event(r,h);for(let i=0;i<e.length;i++)e[i].event&&e[i].event(r,h);r.onEvent&&this.deprecateStuff()&&r.onEvent(r.trackIndex,h),this.animState.onEvent&&this.deprecateStuff()&&this.animState.onEvent(r.trackIndex,h);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};ut(Jm,"deprecatedWarning1",!1);let Qm=Jm;var jm=(f=>(f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event",f))(jm||{});let V1=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}};var _1=Object.defineProperty,D1=(f,t,e)=>t in f?_1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,oh=(f,t,e)=>D1(f,typeof t!="symbol"?t+"":t,e);const tg=class Rf{constructor(t){if(oh(this,"skeletonData"),oh(this,"animationToMixTime",{}),oh(this,"defaultMix",0),t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(r==null)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixByName(t,e,s){Rf.deprecatedWarning1||(Rf.deprecatedWarning1=!0,console.warn("Deprecation Warning: AnimationStateData.setMixByName is deprecated, please use setMix from now on.")),this.setMix(t,e,s)}setMixWith(t,e,s){if(t==null)throw new Error("from cannot be null.");if(e==null)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};oh(tg,"deprecatedWarning1",!1);let eg=tg;var L1=Object.defineProperty,O1=(f,t,e)=>t in f?L1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,sg=(f,t,e)=>O1(f,typeof t!="symbol"?t+"":t,e);let ng=class kx extends Ra{constructor(t){super(t),sg(this,"type",Be.BoundingBox),sg(this,"color",new ne(1,1,1,1))}copy(){const t=new kx(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}};var W1=Object.defineProperty,U1=(f,t,e)=>t in f?W1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,dc=(f,t,e)=>U1(f,typeof t!="symbol"?t+"":t,e);let rg=class Px extends Ra{constructor(t){super(t),dc(this,"type",Be.Clipping),dc(this,"endSlot"),dc(this,"color",new ne(.2275,.2275,.8078,1))}copy(){const t=new Px(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}};var q1=Object.defineProperty,z1=(f,t,e)=>t in f?q1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,On=(f,t,e)=>z1(f,typeof t!="symbol"?t+"":t,e);let lh=class Yf extends Ra{constructor(t){super(t),On(this,"type",Be.Mesh),On(this,"region"),On(this,"path"),On(this,"regionUVs"),On(this,"triangles"),On(this,"color",new ne(1,1,1,1)),On(this,"width"),On(this,"height"),On(this,"hullLength"),On(this,"edges"),On(this,"parentMesh"),On(this,"tempColor",new ne(0,0,0,0))}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t!=null&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh!=null)return this.newLinkedMesh();const t=new Yf(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),dt.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),dt.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges!=null&&(t.edges=new Array(this.edges.length),dt.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Yf(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh!=null?this.parentMesh:this),t}};var G1=Object.defineProperty,H1=(f,t,e)=>t in f?G1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,cl=(f,t,e)=>H1(f,typeof t!="symbol"?t+"":t,e);let dl=class Rx extends Ra{constructor(t){super(t),cl(this,"type",Be.Path),cl(this,"lengths"),cl(this,"closed",!1),cl(this,"constantSpeed",!1),cl(this,"color",new ne(1,1,1,1))}copy(){const t=new Rx(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),dt.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}};var K1=Object.defineProperty,Z1=(f,t,e)=>t in f?K1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ul=(f,t,e)=>Z1(f,typeof t!="symbol"?t+"":t,e);let ig=class Yx extends Ra{constructor(t){super(t),ul(this,"type",Be.Point),ul(this,"x"),ul(this,"y"),ul(this,"rotation"),ul(this,"color",new ne(.38,.94,0,1))}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=nt.cosDeg(this.rotation),n=nt.sinDeg(this.rotation),r=s*e.a+n*e.c,l=s*e.b+n*e.d;return Math.atan2(l,r)*nt.radDeg}copy(){const t=new Yx(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}};var J1=Object.defineProperty,Q1=(f,t,e)=>t in f?J1(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,j1=(f,t,e)=>Q1(f,typeof t!="symbol"?t+"":t,e);let uc=class{constructor(t){j1(this,"atlas"),this.atlas=t}newRegionAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);const r=new ic(e);return r.region=n,r}newMeshAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);const r=new lh(e);return r.region=n,r}newBoundingBoxAttachment(t,e){return new ng(e)}newPathAttachment(t,e){return new dl(e)}newPointAttachment(t,e){return new ig(e)}newClippingAttachment(t,e){return new rg(e)}};var $r=(f=>(f[f.Fixed=0]="Fixed",f[f.Percent=1]="Percent",f))($r||{}),Nr=(f=>(f[f.Tangent=0]="Tangent",f[f.Chain=1]="Chain",f[f.ChainScale=2]="ChainScale",f))(Nr||{});let hh=class{constructor(t,e,s){this.name=t,this.order=e,this.skinRequired=s}};var ty=Object.defineProperty,ey=(f,t,e)=>t in f?ty(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Vr=(f,t,e)=>ey(f,typeof t!="symbol"?t+"":t,e);let fc=class extends hh{constructor(t){super(t,0,!1),Vr(this,"bones",new Array),Vr(this,"target"),Vr(this,"positionMode"),Vr(this,"spacingMode"),Vr(this,"rotateMode"),Vr(this,"offsetRotation"),Vr(this,"position"),Vr(this,"spacing"),Vr(this,"rotateMix"),Vr(this,"translateMix")}};var ds=(f=>(f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f))(ds||{}),sy=Object.defineProperty,ny=(f,t,e)=>t in f?sy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,us=(f,t,e)=>ny(f,typeof t!="symbol"?t+"":t,e);const fl=class mo{constructor(t,e){if(us(this,"data"),us(this,"bones"),us(this,"target"),us(this,"position",0),us(this,"spacing",0),us(this,"rotateMix",0),us(this,"translateMix",0),us(this,"spaces",new Array),us(this,"positions",new Array),us(this,"world",new Array),us(this,"curves",new Array),us(this,"lengths",new Array),us(this,"segments",new Array),us(this,"active",!1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let s=0,n=t.bones.length;s<n;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix}isActive(){return this.active}apply(){this.update()}update(){let t=this.target.getAttachment();if(!(t instanceof dl))return;let e=this.rotateMix,s=this.translateMix,n=s>0,r=e>0;if(!n&&!r)return;let l=this.data,h=l.spacingMode,i=h==ds.Length,a=l.rotateMode,o=a==Nr.Tangent,d=a==Nr.ChainScale,u=this.bones.length,m=o?u:u+1,c=this.bones,g=dt.setArraySize(this.spaces,m),p=null,y=this.spacing;if(d||i){d&&(p=dt.setArraySize(this.lengths,u));for(let v=0,A=m-1;v<A;){let M=c[v],I=M.data.length;if(I<mo.epsilon)d&&(p[v]=0),g[++v]=0;else{let E=I*M.matrix.a,P=I*M.matrix.b,R=Math.sqrt(E*E+P*P);d&&(p[v]=R),g[++v]=(i?I+y:y)*R/I}}}else for(let v=1;v<m;v++)g[v]=y;let w=this.computeWorldPositions(t,m,o,l.positionMode==$r.Percent,h==ds.Percent),x=w[0],b=w[1],S=l.offsetRotation,C=!1;if(S==0)C=a==Nr.Chain;else{C=!1;let v=this.target.bone.matrix;S*=v.a*v.d-v.b*v.c>0?nt.degRad:-nt.degRad}for(let v=0,A=3;v<u;v++,A+=3){let M=c[v],I=M.matrix;I.tx+=(x-I.tx)*s,I.ty+=(b-I.ty)*s;let E=w[A],P=w[A+1],R=E-x,k=P-b;if(d){let Y=p[v];if(Y!=0){let F=(Math.sqrt(R*R+k*k)/Y-1)*e+1;I.a*=F,I.b*=F}}if(x=E,b=P,r){let Y=I.a,F=I.c,X=I.b,W=I.d,B=0,N=0,O=0;if(o?B=w[A-1]:g[v+1]==0?B=w[A+2]:B=Math.atan2(k,R),B-=Math.atan2(X,Y),C){N=Math.cos(B),O=Math.sin(B);let Z=M.data.length;x+=(Z*(N*Y-O*X)-R)*e,b+=(Z*(O*Y+N*X)-k)*e}else B+=S;B>nt.PI?B-=nt.PI2:B<-nt.PI&&(B+=nt.PI2),B*=e,N=Math.cos(B),O=Math.sin(B),I.a=N*Y-O*X,I.c=N*F-O*W,I.b=O*Y+N*X,I.d=O*F+N*W}M.appliedValid=!1}}computeWorldPositions(t,e,s,n,r){let l=this.target,h=this.position,i=this.spaces,a=dt.setArraySize(this.positions,e*3+2),o=null,d=t.closed,u=t.worldVerticesLength,m=u/6,c=mo.NONE;if(!t.constantSpeed){let B=t.lengths;m-=d?1:2;let N=B[m];if(n&&(h*=N),r)for(let O=0;O<e;O++)i[O]*=N;o=dt.setArraySize(this.world,8);for(let O=0,Z=0,$=0;O<e;O++,Z+=3){let D=i[O];h+=D;let _=h;if(d)_%=N,_<0&&(_+=N),$=0;else if(_<0){c!=mo.BEFORE&&(c=mo.BEFORE,t.computeWorldVertices(l,2,4,o,0,2)),this.addBeforePosition(_,o,0,a,Z);continue}else if(_>N){c!=mo.AFTER&&(c=mo.AFTER,t.computeWorldVertices(l,u-6,4,o,0,2)),this.addAfterPosition(_-N,o,0,a,Z);continue}for(;;$++){let lt=B[$];if(!(_>lt)){if($==0)_/=lt;else{let wt=B[$-1];_=(_-wt)/(lt-wt)}break}}$!=c&&(c=$,d&&$==m?(t.computeWorldVertices(l,u-4,4,o,0,2),t.computeWorldVertices(l,0,4,o,4,2)):t.computeWorldVertices(l,$*6+2,8,o,0,2)),this.addCurvePosition(_,o[0],o[1],o[2],o[3],o[4],o[5],o[6],o[7],a,Z,s||O>0&&D==0)}return a}d?(u+=2,o=dt.setArraySize(this.world,u),t.computeWorldVertices(l,2,u-4,o,0,2),t.computeWorldVertices(l,0,2,o,u-4,2),o[u-2]=o[0],o[u-1]=o[1]):(m--,u-=4,o=dt.setArraySize(this.world,u),t.computeWorldVertices(l,2,u,o,0,2));let g=dt.setArraySize(this.curves,m),p=0,y=o[0],w=o[1],x=0,b=0,S=0,C=0,v=0,A=0,M=0,I=0,E=0,P=0,R=0,k=0,Y=0,F=0;for(let B=0,N=2;B<m;B++,N+=6)x=o[N],b=o[N+1],S=o[N+2],C=o[N+3],v=o[N+4],A=o[N+5],M=(y-x*2+S)*.1875,I=(w-b*2+C)*.1875,E=((x-S)*3-y+v)*.09375,P=((b-C)*3-w+A)*.09375,R=M*2+E,k=I*2+P,Y=(x-y)*.75+M+E*.16666667,F=(b-w)*.75+I+P*.16666667,p+=Math.sqrt(Y*Y+F*F),Y+=R,F+=k,R+=E,k+=P,p+=Math.sqrt(Y*Y+F*F),Y+=R,F+=k,p+=Math.sqrt(Y*Y+F*F),Y+=R+E,F+=k+P,p+=Math.sqrt(Y*Y+F*F),g[B]=p,y=v,w=A;if(n&&(h*=p),r)for(let B=0;B<e;B++)i[B]*=p;let X=this.segments,W=0;for(let B=0,N=0,O=0,Z=0;B<e;B++,N+=3){let $=i[B];h+=$;let D=h;if(d)D%=p,D<0&&(D+=p),O=0;else if(D<0){this.addBeforePosition(D,o,0,a,N);continue}else if(D>p){this.addAfterPosition(D-p,o,u-4,a,N);continue}for(;;O++){let _=g[O];if(!(D>_)){if(O==0)D/=_;else{let lt=g[O-1];D=(D-lt)/(_-lt)}break}}if(O!=c){c=O;let _=O*6;for(y=o[_],w=o[_+1],x=o[_+2],b=o[_+3],S=o[_+4],C=o[_+5],v=o[_+6],A=o[_+7],M=(y-x*2+S)*.03,I=(w-b*2+C)*.03,E=((x-S)*3-y+v)*.006,P=((b-C)*3-w+A)*.006,R=M*2+E,k=I*2+P,Y=(x-y)*.3+M+E*.16666667,F=(b-w)*.3+I+P*.16666667,W=Math.sqrt(Y*Y+F*F),X[0]=W,_=1;_<8;_++)Y+=R,F+=k,R+=E,k+=P,W+=Math.sqrt(Y*Y+F*F),X[_]=W;Y+=R,F+=k,W+=Math.sqrt(Y*Y+F*F),X[8]=W,Y+=R+E,F+=k+P,W+=Math.sqrt(Y*Y+F*F),X[9]=W,Z=0}for(D*=W;;Z++){let _=X[Z];if(!(D>_)){if(Z==0)D/=_;else{let lt=X[Z-1];D=Z+(D-lt)/(_-lt)}break}}this.addCurvePosition(D*.1,y,w,x,b,S,C,v,A,a,N,s||B>0&&$==0)}return a}addBeforePosition(t,e,s,n,r){let l=e[s],h=e[s+1],i=e[s+2]-l,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){let l=e[s+2],h=e[s+3],i=l-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,l,h,i,a,o,d,u){(t==0||isNaN(t))&&(t=1e-4);let m=t*t,c=m*t,g=1-t,p=g*g,y=p*g,w=g*t,x=w*3,b=g*x,S=x*t,C=e*y+n*b+l*S+i*c,v=s*y+r*b+h*S+a*c;o[d]=C,o[d+1]=v,u&&(o[d+2]=Math.atan2(v-(s*p+r*w*2+h*m),C-(e*p+n*w*2+l*m)))}};us(fl,"NONE",-1),us(fl,"BEFORE",-2),us(fl,"AFTER",-3),us(fl,"epsilon",1e-5);let ag=fl;var ry=Object.defineProperty,iy=(f,t,e)=>t in f?ry(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ke=(f,t,e)=>iy(f,typeof t!="symbol"?t+"":t,e);let mc=class{constructor(t,e,s){if(ke(this,"matrix",new V.Matrix),ke(this,"data"),ke(this,"skeleton"),ke(this,"parent"),ke(this,"children",new Array),ke(this,"x",0),ke(this,"y",0),ke(this,"rotation",0),ke(this,"scaleX",0),ke(this,"scaleY",0),ke(this,"shearX",0),ke(this,"shearY",0),ke(this,"ax",0),ke(this,"ay",0),ke(this,"arotation",0),ke(this,"ascaleX",0),ke(this,"ascaleY",0),ke(this,"ashearX",0),ke(this,"ashearY",0),ke(this,"appliedValid",!1),ke(this,"sorted",!1),ke(this,"active",!1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,l,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=l,this.ashearY=h,this.appliedValid=!0;const i=this.parent,a=this.matrix,o=this.skeleton.scaleX,d=-this.skeleton.scaleY;if(i==null){const p=this.skeleton,y=s+90+h;a.a=nt.cosDeg(s+l)*n*o,a.c=nt.cosDeg(y)*r*o,a.b=nt.sinDeg(s+l)*n*d,a.d=nt.sinDeg(y)*r*d,a.tx=t*o+p.x,a.ty=e*d+p.y;return}let u=i.matrix.a,m=i.matrix.c,c=i.matrix.b,g=i.matrix.d;switch(a.tx=u*t+m*e+i.matrix.tx,a.ty=c*t+g*e+i.matrix.ty,this.data.transformMode){case Ie.Normal:{const p=s+90+h,y=nt.cosDeg(s+l)*n,w=nt.cosDeg(p)*r,x=nt.sinDeg(s+l)*n,b=nt.sinDeg(p)*r;a.a=u*y+m*x,a.c=u*w+m*b,a.b=c*y+g*x,a.d=c*w+g*b;return}case Ie.OnlyTranslation:{const p=s+90+h;a.a=nt.cosDeg(s+l)*n,a.c=nt.cosDeg(p)*r,a.b=nt.sinDeg(s+l)*n,a.d=nt.sinDeg(p)*r;break}case Ie.NoRotationOrReflection:{let p=u*u+c*c,y=0;p>1e-4?(p=Math.abs(u*g-m*c)/p,u/=this.skeleton.scaleX,c/=this.skeleton.scaleY,m=c*p,g=u*p,y=Math.atan2(c,u)*nt.radDeg):(u=0,c=0,y=90-Math.atan2(g,m)*nt.radDeg);const w=s+l-y,x=s+h-y+90,b=nt.cosDeg(w)*n,S=nt.cosDeg(x)*r,C=nt.sinDeg(w)*n,v=nt.sinDeg(x)*r;a.a=u*b-m*C,a.c=u*S-m*v,a.b=c*b+g*C,a.d=c*S+g*v;break}case Ie.NoScale:case Ie.NoScaleOrReflection:{const p=nt.cosDeg(s),y=nt.sinDeg(s);let w=(u*p+m*y)/o,x=(c*p+g*y)/d,b=Math.sqrt(w*w+x*x);b>1e-5&&(b=1/b),w*=b,x*=b,b=Math.sqrt(w*w+x*x),this.data.transformMode==Ie.NoScale&&u*g-m*c<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY>0)&&(b=-b);const S=Math.PI/2+Math.atan2(x,w),C=Math.cos(S)*b,v=Math.sin(S)*b,A=nt.cosDeg(l)*n,M=nt.cosDeg(90+h)*r,I=nt.sinDeg(l)*n,E=nt.sinDeg(90+h)*r;a.a=w*A+C*I,a.c=w*M+C*E,a.b=x*A+v*I,a.d=x*M+v*E;break}}a.a*=o,a.c*=o,a.b*=d,a.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*nt.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*nt.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.c*t.c)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.b*t.b+t.d*t.d)}updateAppliedTransform(){this.appliedValid=!0;const t=this.parent,e=this.matrix;if(t==null){this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*nt.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*nt.radDeg;return}const s=t.matrix,n=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,l=e.ty-s.ty;this.ax=r*s.d*n-l*s.c*n,this.ay=l*s.a*n-r*s.b*n;const h=n*s.d,i=n*s.a,a=n*s.c,o=n*s.b,d=h*e.a-a*e.b,u=h*e.c-a*e.d,m=i*e.b-o*e.a,c=i*e.d-o*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*c-u*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*u+m*c,g)*nt.radDeg,this.arotation=Math.atan2(m,d)*nt.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+c*c),this.ashearY=0,this.arotation=90-Math.atan2(c,u)*nt.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=1/(s*l-n*r),i=t.x-e.tx,a=t.y-e.ty;return t.x=i*l*h-a*n*h,t.y=a*s*h-i*r*h,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=nt.sinDeg(t),s=nt.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*s,n.d*s-n.c*e)*nt.radDeg}localToWorldRotation(t){const e=nt.sinDeg(t),s=nt.cosDeg(t),n=this.matrix;return Math.atan2(s*n.b+e*n.d,s*n.a+e*n.c)*nt.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=nt.cosDeg(t),i=nt.sinDeg(t);e.a=h*s-i*r,e.c=h*n-i*l,e.b=i*s+h*r,e.d=i*n+h*l,this.appliedValid=!1}};var ay=Object.defineProperty,oy=(f,t,e)=>t in f?ay(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ni=(f,t,e)=>oy(f,typeof t!="symbol"?t+"":t,e);let og=class{constructor(t,e){if(ni(this,"data"),ni(this,"bones"),ni(this,"target"),ni(this,"bendDirection",0),ni(this,"compress",!1),ni(this,"stretch",!1),ni(this,"mix",1),ni(this,"softness",0),ni(this,"active",!1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.softness,this.mix);break}}apply1(t,e,s,n,r,l,h){t.appliedValid||t.updateAppliedTransform();const i=t.parent.matrix,a=i.a;let o=i.c;const d=i.b;let u=i.d,m=-t.ashearX-t.arotation,c=0,g=0;switch(t.data.transformMode){case Ie.OnlyTranslation:c=e-t.worldX,g=s-t.worldY;break;case Ie.NoRotationOrReflection:const w=Math.abs(a*u-o*d)/(a*a+d*d),x=a/t.skeleton.scaleX,b=d/t.skeleton.scaleY;o=-b*w*t.skeleton.scaleX,u=x*w*t.skeleton.scaleY,m+=Math.atan2(b,x)*nt.radDeg;default:const S=e-i.tx,C=s-i.ty,v=a*u-o*d;c=(S*u-C*o)/v-t.ax,g=(C*a-S*d)/v-t.ay}m+=Math.atan2(g,c)*nt.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let p=t.ascaleX,y=t.ascaleY;if(n||r){switch(t.data.transformMode){case Ie.NoScale:case Ie.NoScaleOrReflection:c=e-t.worldX,g=s-t.worldY}const w=t.data.length*p,x=Math.sqrt(c*c+g*g);if(n&&x<w||r&&x>w&&w>1e-4){const b=(x/w-1)*h+1;p*=b,l&&(y*=b)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,p,y,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,l,h,i){if(i==0){e.updateWorldTransform();return}t.appliedValid||t.updateAppliedTransform(),e.appliedValid||e.updateAppliedTransform();const a=t.ax,o=t.ay;let d=t.ascaleX,u=d,m=t.ascaleY,c=e.ascaleX;const g=t.matrix;let p=0,y=0,w=0;d<0?(d=-d,p=180,w=-1):(p=0,w=1),m<0&&(m=-m,w=-w),c<0?(c=-c,y=180):y=0;const x=e.ax;let b=0,S=0,C=0,v=g.a,A=g.c,M=g.b,I=g.d;const E=Math.abs(d-m)<=1e-4;E?(b=e.ay,S=v*x+A*b+g.tx,C=M*x+I*b+g.ty):(b=0,S=v*x+g.tx,C=M*x+g.ty);const P=t.parent.matrix;v=P.a,A=P.c,M=P.b,I=P.d;const R=1/(v*I-A*M);let k=S-P.tx,Y=C-P.ty;const F=(k*I-Y*A)*R-a,X=(Y*v-k*M)*R-o,W=Math.sqrt(F*F+X*X);let B=e.data.length*c,N,O;if(W<1e-4){this.apply1(t,s,n,!1,l,!1,i),e.updateWorldTransformWith(x,b,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);return}k=s-P.tx,Y=n-P.ty;let Z=(k*I-Y*A)*R-a,$=(Y*v-k*M)*R-o,D=Z*Z+$*$;if(h!=0){h*=d*(c+1)/2;const wt=Math.sqrt(D),Tt=wt-W-B*d+h;if(Tt>0){let ct=Math.min(1,Tt/(h*2))-1;ct=(Tt-h*(1-ct*ct))/wt,Z-=ct*Z,$-=ct*$,D=Z*Z+$*$}}t:if(E){B*=d;let wt=(D-W*W-B*B)/(2*W*B);wt<-1?wt=-1:wt>1&&(wt=1,l&&(u*=(Math.sqrt(D)/(W+B)-1)*i+1)),O=Math.acos(wt)*r,v=W+B*wt,A=B*Math.sin(O),N=Math.atan2($*v-Z*A,Z*v+$*A)}else{v=d*B,A=m*B;const wt=v*v,Tt=A*A,ct=Math.atan2($,Z);M=Tt*W*W+wt*D-wt*Tt;const Mt=-2*Tt*W,Rt=Tt-wt;if(I=Mt*Mt-4*Rt*M,I>=0){let ye=Math.sqrt(I);Mt<0&&(ye=-ye),ye=-(Mt+ye)/2;const Ue=ye/Rt,Kt=M/ye,ps=Math.abs(Ue)<Math.abs(Kt)?Ue:Kt;if(ps*ps<=D){Y=Math.sqrt(D-ps*ps)*r,N=ct-Math.atan2(Y,ps),O=Math.atan2(Y/m,(ps-W)/d);break t}}let de=nt.PI,Ze=W-v,Je=Ze*Ze,we=0,Ye=0,Qe=W+v,je=Qe*Qe,ue=0;M=-v*W/(wt-Tt),M>=-1&&M<=1&&(M=Math.acos(M),k=v*Math.cos(M)+W,Y=A*Math.sin(M),I=k*k+Y*Y,I<Je&&(de=M,Je=I,Ze=k,we=Y),I>je&&(Ye=M,je=I,Qe=k,ue=Y)),D<=(Je+je)/2?(N=ct-Math.atan2(we*r,Ze),O=de*r):(N=ct-Math.atan2(ue*r,Qe),O=Ye*r)}const _=Math.atan2(b,x)*w;let lt=t.arotation;N=(N-_)*nt.radDeg+p-lt,N>180?N-=360:N<-180&&(N+=360),t.updateWorldTransformWith(a,o,lt+N*i,u,t.ascaleY,0,0),lt=e.arotation,O=((O+_)*nt.radDeg-e.ashearX)*w+y-lt,O>180?O-=360:O<-180&&(O+=360),e.updateWorldTransformWith(x,b,lt+O*i,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}};var ly=Object.defineProperty,hy=(f,t,e)=>t in f?ly(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ri=(f,t,e)=>hy(f,typeof t!="symbol"?t+"":t,e);let lg=class{constructor(t,e){if(ri(this,"data"),ri(this,"bones"),ri(this,"target"),ri(this,"rotateMix",0),ri(this,"translateMix",0),ri(this,"scaleMix",0),ri(this,"shearMix",0),ri(this,"temp",new p1),ri(this,"active",!1),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("skeleton cannot be null.");this.data=t,this.rotateMix=t.rotateMix,this.translateMix=t.translateMix,this.scaleMix=t.scaleMix,this.shearMix=t.shearMix,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}apply(){this.update()}update(){this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld()}applyAbsoluteWorld(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target,l=r.matrix,h=l.a,i=l.c,a=l.b,o=l.d,d=h*o-i*a>0?nt.degRad:-nt.degRad,u=this.data.offsetRotation*d,m=this.data.offsetShearY*d,c=this.bones;for(let g=0,p=c.length;g<p;g++){const y=c[g];let w=!1;const x=y.matrix;if(t!=0){const b=x.a,S=x.c,C=x.b,v=x.d;let A=Math.atan2(a,h)-Math.atan2(C,b)+u;A>nt.PI?A-=nt.PI2:A<-nt.PI&&(A+=nt.PI2),A*=t;const M=Math.cos(A),I=Math.sin(A);x.a=M*b-I*C,x.c=M*S-I*v,x.b=I*b+M*C,x.d=I*S+M*v,w=!0}if(e!=0){const b=this.temp;r.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),x.tx+=(b.x-x.tx)*e,x.ty+=(b.y-x.ty)*e,w=!0}if(s>0){let b=Math.sqrt(x.a*x.a+x.b*x.b),S=Math.sqrt(h*h+a*a);b>1e-5&&(b=(b+(S-b+this.data.offsetScaleX)*s)/b),x.a*=b,x.b*=b,b=Math.sqrt(x.c*x.c+x.d*x.d),S=Math.sqrt(i*i+o*o),b>1e-5&&(b=(b+(S-b+this.data.offsetScaleY)*s)/b),x.c*=b,x.d*=b,w=!0}if(n>0){const b=x.c,S=x.d,C=Math.atan2(S,b);let v=Math.atan2(o,i)-Math.atan2(a,h)-(C-Math.atan2(x.b,x.a));v>nt.PI?v-=nt.PI2:v<-nt.PI&&(v+=nt.PI2),v=C+(v+m)*n;const A=Math.sqrt(b*b+S*S);x.c=Math.cos(v)*A,x.d=Math.sin(v)*A,w=!0}w&&(y.appliedValid=!1)}}applyRelativeWorld(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target,l=r.matrix,h=l.a,i=l.c,a=l.b,o=l.d,d=h*o-i*a>0?nt.degRad:-nt.degRad,u=this.data.offsetRotation*d,m=this.data.offsetShearY*d,c=this.bones;for(let g=0,p=c.length;g<p;g++){const y=c[g];let w=!1;const x=y.matrix;if(t!=0){const b=x.a,S=x.c,C=x.b,v=x.d;let A=Math.atan2(a,h)+u;A>nt.PI?A-=nt.PI2:A<-nt.PI&&(A+=nt.PI2),A*=t;const M=Math.cos(A),I=Math.sin(A);x.a=M*b-I*C,x.c=M*S-I*v,x.b=I*b+M*C,x.d=I*S+M*v,w=!0}if(e!=0){const b=this.temp;r.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),x.tx+=b.x*e,x.ty+=b.y*e,w=!0}if(s>0){let b=(Math.sqrt(h*h+a*a)-1+this.data.offsetScaleX)*s+1;x.a*=b,x.b*=b,b=(Math.sqrt(i*i+o*o)-1+this.data.offsetScaleY)*s+1,x.c*=b,x.d*=b,w=!0}if(n>0){let b=Math.atan2(o,i)-Math.atan2(a,h);b>nt.PI?b-=nt.PI2:b<-nt.PI&&(b+=nt.PI2);const S=x.c,C=x.d;b=Math.atan2(C,S)+(b-nt.PI/2+m)*n;const v=Math.sqrt(S*S+C*C);x.c=Math.cos(b)*v,x.d=Math.sin(b)*v,w=!0}w&&(y.appliedValid=!1)}}applyAbsoluteLocal(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target;r.appliedValid||r.updateAppliedTransform();const l=this.bones;for(let h=0,i=l.length;h<i;h++){const a=l[h];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;if(t!=0){let p=r.arotation-o+this.data.offsetRotation;p-=(16384-(16384.499999999996-p/360|0))*360,o+=p*t}let d=a.ax,u=a.ay;e!=0&&(d+=(r.ax-d+this.data.offsetX)*e,u+=(r.ay-u+this.data.offsetY)*e);let m=a.ascaleX,c=a.ascaleY;s>0&&(m>1e-5&&(m=(m+(r.ascaleX-m+this.data.offsetScaleX)*s)/m),c>1e-5&&(c=(c+(r.ascaleY-c+this.data.offsetScaleY)*s)/c));const g=a.ashearY;if(n>0){let p=r.ashearY-g+this.data.offsetShearY;p-=(16384-(16384.499999999996-p/360|0))*360,a.shearY+=p*n}a.updateWorldTransformWith(d,u,o,m,c,a.ashearX,g)}}applyRelativeLocal(){const t=this.rotateMix,e=this.translateMix,s=this.scaleMix,n=this.shearMix,r=this.target;r.appliedValid||r.updateAppliedTransform();const l=this.bones;for(let h=0,i=l.length;h<i;h++){const a=l[h];a.appliedValid||a.updateAppliedTransform();let o=a.arotation;t!=0&&(o+=(r.arotation+this.data.offsetRotation)*t);let d=a.ax,u=a.ay;e!=0&&(d+=(r.ax+this.data.offsetX)*e,u+=(r.ay+this.data.offsetY)*e);let m=a.ascaleX,c=a.ascaleY;s>0&&(m>1e-5&&(m*=(r.ascaleX-1+this.data.offsetScaleX)*s+1),c>1e-5&&(c*=(r.ascaleY-1+this.data.offsetScaleY)*s+1));let g=a.ashearY;n>0&&(g+=(r.ashearY+this.data.offsetShearY)*n),a.updateWorldTransformWith(d,u,o,m,c,a.ashearX,g)}}};var cy=Object.defineProperty,dy=(f,t,e)=>t in f?cy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ps=(f,t,e)=>dy(f,typeof t!="symbol"?t+"":t,e);const hg=class Gl{constructor(t){if(Ps(this,"data"),Ps(this,"bones"),Ps(this,"slots"),Ps(this,"drawOrder"),Ps(this,"ikConstraints"),Ps(this,"transformConstraints"),Ps(this,"pathConstraints"),Ps(this,"_updateCache",new Array),Ps(this,"updateCacheReset",new Array),Ps(this,"skin"),Ps(this,"color"),Ps(this,"time",0),Ps(this,"scaleX",1),Ps(this,"scaleY",1),Ps(this,"x",0),Ps(this,"y",0),t==null)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(s.parent==null)n=new mc(s,this,null);else{const r=this.bones[s.parent.index];n=new mc(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new rc(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new og(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new lg(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new ag(s,this))}this.color=new ne(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0,this.updateCacheReset.length=0;const e=this.bones;for(let o=0,d=e.length;o<d;o++){const u=e[o];u.sorted=u.data.skinRequired,u.active=!u.sorted}if(this.skin!=null){const o=this.skin.bones;for(let d=0,u=this.skin.bones.length;d<u;d++){let m=this.bones[o[d].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m!=null)}}const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,l=s.length,h=n.length,i=r.length,a=l+h+i;t:for(let o=0;o<a;o++){for(let d=0;d<l;d++){const u=s[d];if(u.data.order==o){this.sortIkConstraint(u);continue t}}for(let d=0;d<h;d++){const u=n[d];if(u.data.order==o){this.sortTransformConstraint(u);continue t}}for(let d=0;d<i;d++){const u=r[d];if(u.data.order==o){this.sortPathConstraint(u);continue t}}}for(let o=0,d=e.length;o<d;o++)this.sortBone(e[o])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin!=null&&dt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length>1){const r=s[s.length-1];this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}this._updateCache.push(t),this.sortReset(n.children),s[s.length-1].sorted=!0}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin!=null&&dt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,s=e.data.index,n=e.bone;this.skin!=null&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin!=null&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof dl&&this.sortPathConstraintAttachmentWith(r,n);const l=t.bones,h=l.length;for(let i=0;i<h;i++)this.sortBone(l[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(l[i].children);for(let i=0;i<h;i++)l[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin!=null&&dt.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this._updateCache.indexOf(r)>-1||this.updateCacheReset.push(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof dl))return;const s=t.bones;if(s==null)this.sortBone(e);else{const n=this.bones;let r=0;for(;r<s.length;){const l=s[r++];for(let h=r+l;r<h;r++){const i=s[r];this.sortBone(n[i])}}}}sortBone(t){if(t.sorted)return;const e=t.parent;e!=null&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.updateCacheReset;for(let s=0,n=t.length;s<n;s++){const r=t[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY,r.appliedValid=!0}const e=this._updateCache;for(let s=0,n=e.length;s<n;s++)e[s].update()}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let r=0,l=t.length;r<l;r++)t[r].setToSetupPose();const e=this.ikConstraints;for(let r=0,l=e.length;r<l;r++){const h=e[r];h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}const s=this.transformConstraints;for(let r=0,l=s.length;r<l;r++){const h=s[r],i=h.data;h.rotateMix=i.rotateMix,h.translateMix=i.translateMix,h.scaleMix=i.scaleMix,h.shearMix=i.shearMix}const n=this.pathConstraints;for(let r=0,l=n.length;r<l;r++){const h=n[r],i=h.data;h.position=i.position,h.spacing=i.spacing,h.rotateMix=i.rotateMix,h.translateMix=i.translateMix}}setSlotsToSetupPose(){const t=this.slots;dt.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(e==null)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t!=null)if(this.skin!=null)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],l=r.data.attachmentName;if(l!=null){const h=t.getAttachment(s,l);h!=null&&r.setAttachment(h)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlotIndex(t),e)}getAttachment(t,e){if(e==null)throw new Error("attachmentName cannot be null.");if(this.skin!=null){const s=this.skin.getAttachment(t,e);if(s!=null)return s}return this.data.defaultSkin!=null?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(t==null)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.data.name==t){let h=null;if(e!=null&&(h=this.getAttachment(n,e),h==null))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);l.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}getBounds(t,e,s=new Array(2)){if(t==null)throw new Error("offset cannot be null.");if(e==null)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let a=0,o=n.length;a<o;a++){const d=n[a];if(!d.bone.active)continue;let u=0,m=null;const c=d.getAttachment();if(c instanceof ic)u=8,m=dt.setArraySize(s,u,0),c.computeWorldVertices(d.bone,m,0,2);else if(c instanceof lh){const g=c;u=g.worldVerticesLength,m=dt.setArraySize(s,u,0),g.computeWorldVertices(d,0,u,m,0,2)}if(m!=null)for(let g=0,p=m.length;g<p;g+=2){const y=m[g],w=m[g+1];r=Math.min(r,y),l=Math.min(l,w),h=Math.max(h,y),i=Math.max(i,w)}}t.set(r,l),e.set(h-r,i-l)}update(t){this.time+=t}get flipX(){return this.scaleX==-1}set flipX(t){Gl.deprecatedWarning1||(Gl.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){Gl.deprecatedWarning1||(Gl.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};Ps(hg,"deprecatedWarning1",!1);let cg=hg;var uy=Object.defineProperty,fy=(f,t,e)=>t in f?uy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Na=(f,t,e)=>fy(f,typeof t!="symbol"?t+"":t,e);let gc=class{constructor(t,e){if(Na(this,"data"),Na(this,"intValue"),Na(this,"floatValue"),Na(this,"stringValue"),Na(this,"time"),Na(this,"volume"),Na(this,"balance"),e==null)throw new Error("data cannot be null.");this.time=t,this.data=e}};var my=Object.defineProperty,gy=(f,t,e)=>t in f?my(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ss=(f,t,e)=>gy(f,typeof t!="symbol"?t+"":t,e);let pc=class{constructor(){ss(this,"name"),ss(this,"bones",new Array),ss(this,"slots",new Array),ss(this,"skins",new Array),ss(this,"defaultSkin"),ss(this,"events",new Array),ss(this,"animations",new Array),ss(this,"ikConstraints",new Array),ss(this,"transformConstraints",new Array),ss(this,"pathConstraints",new Array),ss(this,"x"),ss(this,"y"),ss(this,"width"),ss(this,"height"),ss(this,"version"),ss(this,"hash"),ss(this,"fps",0),ss(this,"imagesPath"),ss(this,"audioPath")}findBone(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(t==null)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(t==null)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(t==null)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(t==null)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(t==null)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(t==null)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}};var py=Object.defineProperty,xy=(f,t,e)=>t in f?py(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Va=(f,t,e)=>xy(f,typeof t!="symbol"?t+"":t,e);let xc=class{constructor(t,e,s){if(Va(this,"index"),Va(this,"name"),Va(this,"boneData"),Va(this,"color",new ne(1,1,1,1)),Va(this,"darkColor"),Va(this,"attachmentName"),Va(this,"blendMode"),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");if(s==null)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}};var by=Object.defineProperty,wy=(f,t,e)=>t in f?by(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,gn=(f,t,e)=>wy(f,typeof t!="symbol"?t+"":t,e);let bc=class{constructor(t,e,s){if(gn(this,"index"),gn(this,"name"),gn(this,"parent"),gn(this,"length"),gn(this,"x",0),gn(this,"y",0),gn(this,"rotation",0),gn(this,"scaleX",1),gn(this,"scaleY",1),gn(this,"shearX",0),gn(this,"shearY",0),gn(this,"transformMode",Ie.Normal),gn(this,"skinRequired",!1),gn(this,"color",new ne),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}};var yy=Object.defineProperty,Sy=(f,t,e)=>t in f?yy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ui=(f,t,e)=>Sy(f,typeof t!="symbol"?t+"":t,e);let wc=class extends hh{constructor(t){super(t,0,!1),Ui(this,"bones",new Array),Ui(this,"target"),Ui(this,"bendDirection",1),Ui(this,"compress",!1),Ui(this,"stretch",!1),Ui(this,"uniform",!1),Ui(this,"mix",1),Ui(this,"softness",0)}};var Cy=Object.defineProperty,vy=(f,t,e)=>t in f?Cy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,pn=(f,t,e)=>vy(f,typeof t!="symbol"?t+"":t,e);let yc=class extends hh{constructor(t){super(t,0,!1),pn(this,"bones",new Array),pn(this,"target"),pn(this,"rotateMix",0),pn(this,"translateMix",0),pn(this,"scaleMix",0),pn(this,"shearMix",0),pn(this,"offsetRotation",0),pn(this,"offsetX",0),pn(this,"offsetY",0),pn(this,"offsetScaleX",0),pn(this,"offsetScaleY",0),pn(this,"offsetShearY",0),pn(this,"relative",!1),pn(this,"local",!1)}};var Ay=Object.defineProperty,My=(f,t,e)=>t in f?Ay(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ch=(f,t,e)=>My(f,typeof t!="symbol"?t+"":t,e);let Sc=class{constructor(t,e,s){this.slotIndex=t,this.name=e,this.attachment=s}},dh=class{constructor(t){if(ch(this,"name"),ch(this,"attachments",new Array),ch(this,"bones",Array()),ch(this,"constraints",new Array),t==null)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(s==null)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let l=0;l<this.bones.length;l++)if(this.bones[l]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let l=0;l<this.constraints.length;l++)if(this.constraints[l]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let l=0;l<this.bones.length;l++)if(this.bones[l]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let l=0;l<this.constraints.length;l++)if(this.constraints[l]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];n.attachment!=null&&(n.attachment instanceof lh?(n.attachment=n.attachment.newLinkedMesh(),this.setAttachment(n.slotIndex,n.name,n.attachment)):(n.attachment=n.attachment.copy(),this.setAttachment(n.slotIndex,n.name,n.attachment)))}}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){const s=this.attachments[t];s&&(s[e]=null)}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const s=this.attachments[e];if(s)for(const n in s){const r=s[n];r&&t.push(new Sc(e,n,r))}}return t}getAttachmentsForSlot(t,e){const s=this.attachments[t];if(s)for(const n in s){const r=s[n];r&&e.push(new Sc(t,n,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],l=r.getAttachment();if(l&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(l==a){const o=this.getAttachment(s,i);o!=null&&r.setAttachment(o);break}}}s++}}};var Ty=Object.defineProperty,Ey=(f,t,e)=>t in f?Ty(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,_a=(f,t,e)=>Ey(f,typeof t!="symbol"?t+"":t,e);let Cc=class{constructor(t){_a(this,"name"),_a(this,"intValue"),_a(this,"floatValue"),_a(this,"stringValue"),_a(this,"audioPath"),_a(this,"volume"),_a(this,"balance"),this.name=t}},Iy=class{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<7,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<14,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<21,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}};var ky=Object.defineProperty,Py=(f,t,e)=>t in f?ky(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,me=(f,t,e)=>Py(f,typeof t!="symbol"?t+"":t,e);const Ge=class Fe{constructor(t){me(this,"attachmentLoader"),me(this,"scale",1),me(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new pc;s.name="";const n=new Iy(t);s.hash=n.readString(),s.version=n.readString(),s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat();const r=n.readBoolean();r&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let l=0;l=n.readInt(!0);for(let i=0;i<l;i++)n.strings.push(n.readString());l=n.readInt(!0);for(let i=0;i<l;i++){const a=n.readString(),o=i==0?null:s.bones[n.readInt(!0)],d=new bc(i,a,o);d.rotation=n.readFloat(),d.x=n.readFloat()*e,d.y=n.readFloat()*e,d.scaleX=n.readFloat(),d.scaleY=n.readFloat(),d.shearX=n.readFloat(),d.shearY=n.readFloat(),d.length=n.readFloat()*e,d.transformMode=Fe.TransformModeValues[n.readInt(!0)],d.skinRequired=n.readBoolean(),r&&ne.rgba8888ToColor(d.color,n.readInt32()),s.bones.push(d)}l=n.readInt(!0);for(let i=0;i<l;i++){const a=n.readString(),o=s.bones[n.readInt(!0)],d=new xc(i,a,o);ne.rgba8888ToColor(d.color,n.readInt32());const u=n.readInt32();u!=-1&&ne.rgb888ToColor(d.darkColor=new ne,u),d.attachmentName=n.readStringRef(),d.blendMode=Fe.BlendModeValues[n.readInt(!0)],s.slots.push(d)}l=n.readInt(!0);for(let i=0,a;i<l;i++){const o=new wc(n.readString());o.order=n.readInt(!0),o.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let d=0;d<a;d++)o.bones.push(s.bones[n.readInt(!0)]);o.target=s.bones[n.readInt(!0)],o.mix=n.readFloat(),o.softness=n.readFloat()*e,o.bendDirection=n.readByte(),o.compress=n.readBoolean(),o.stretch=n.readBoolean(),o.uniform=n.readBoolean(),s.ikConstraints.push(o)}l=n.readInt(!0);for(let i=0,a;i<l;i++){const o=new yc(n.readString());o.order=n.readInt(!0),o.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let d=0;d<a;d++)o.bones.push(s.bones[n.readInt(!0)]);o.target=s.bones[n.readInt(!0)],o.local=n.readBoolean(),o.relative=n.readBoolean(),o.offsetRotation=n.readFloat(),o.offsetX=n.readFloat()*e,o.offsetY=n.readFloat()*e,o.offsetScaleX=n.readFloat(),o.offsetScaleY=n.readFloat(),o.offsetShearY=n.readFloat(),o.rotateMix=n.readFloat(),o.translateMix=n.readFloat(),o.scaleMix=n.readFloat(),o.shearMix=n.readFloat(),s.transformConstraints.push(o)}l=n.readInt(!0);for(let i=0,a;i<l;i++){const o=new fc(n.readString());o.order=n.readInt(!0),o.skinRequired=n.readBoolean(),a=n.readInt(!0);for(let d=0;d<a;d++)o.bones.push(s.bones[n.readInt(!0)]);o.target=s.slots[n.readInt(!0)],o.positionMode=Fe.PositionModeValues[n.readInt(!0)],o.spacingMode=Fe.SpacingModeValues[n.readInt(!0)],o.rotateMode=Fe.RotateModeValues[n.readInt(!0)],o.offsetRotation=n.readFloat(),o.position=n.readFloat(),o.positionMode==$r.Fixed&&(o.position*=e),o.spacing=n.readFloat(),(o.spacingMode==ds.Length||o.spacingMode==ds.Fixed)&&(o.spacing*=e),o.rotateMix=n.readFloat(),o.translateMix=n.readFloat(),s.pathConstraints.push(o)}const h=this.readSkin(n,s,!0,r);h!=null&&(s.defaultSkin=h,s.skins.push(h));{let i=s.skins.length;for(dt.setArraySize(s.skins,l=i+n.readInt(!0));i<l;i++)s.skins[i]=this.readSkin(n,s,!1,r)}l=this.linkedMeshes.length;for(let i=0;i<l;i++){const a=this.linkedMeshes[i],o=a.skin==null?s.defaultSkin:s.findSkin(a.skin);if(o==null)throw new Error(`Skin not found: ${a.skin}`);const d=o.getAttachment(a.slotIndex,a.parent);if(d==null)throw new Error(`Parent mesh not found: ${a.parent}`);a.mesh.deformAttachment=a.inheritDeform?d:a.mesh,a.mesh.setParentMesh(d)}this.linkedMeshes.length=0,l=n.readInt(!0);for(let i=0;i<l;i++){const a=new Cc(n.readStringRef());a.intValue=n.readInt(!1),a.floatValue=n.readFloat(),a.stringValue=n.readString(),a.audioPath=n.readString(),a.audioPath!=null&&(a.volume=n.readFloat(),a.balance=n.readFloat()),s.events.push(a)}l=n.readInt(!0);for(let i=0;i<l;i++)s.animations.push(this.readAnimation(n,n.readString(),s));return s}readSkin(t,e,s,n){let r=null,l=0;if(s){if(l=t.readInt(!0),l==0)return null;r=new dh("default")}else{r=new dh(t.readStringRef()),r.bones.length=t.readInt(!0);for(let h=0,i=r.bones.length;h<i;h++)r.bones[h]=e.bones[t.readInt(!0)];for(let h=0,i=t.readInt(!0);h<i;h++)r.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let h=0,i=t.readInt(!0);h<i;h++)r.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let h=0,i=t.readInt(!0);h<i;h++)r.constraints.push(e.pathConstraints[t.readInt(!0)]);l=t.readInt(!0)}for(let h=0;h<l;h++){const i=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readStringRef(),u=this.readAttachment(t,e,r,i,d,n);u!=null&&r.setAttachment(i,d,u)}}return r}readAttachment(t,e,s,n,r,l){const h=this.scale;let i=t.readStringRef();i==null&&(i=r);const a=t.readByte();switch(Fe.AttachmentTypeValues[a]){case Be.Region:{let d=t.readStringRef();const u=t.readFloat(),m=t.readFloat(),c=t.readFloat(),g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),x=t.readInt32();d==null&&(d=i);const b=this.attachmentLoader.newRegionAttachment(s,i,d);return b==null?null:(b.path=d,b.x=m*h,b.y=c*h,b.scaleX=g,b.scaleY=p,b.rotation=u,b.width=y*h,b.height=w*h,ne.rgba8888ToColor(b.color,x),b)}case Be.BoundingBox:{const d=t.readInt(!0),u=this.readVertices(t,d),m=l?t.readInt32():0,c=this.attachmentLoader.newBoundingBoxAttachment(s,i);return c==null?null:(c.worldVerticesLength=d<<1,c.vertices=u.vertices,c.bones=u.bones,l&&ne.rgba8888ToColor(c.color,m),c)}case Be.Mesh:{let d=t.readStringRef();const u=t.readInt32(),m=t.readInt(!0),c=this.readFloatArray(t,m<<1,1),g=this.readShortArray(t),p=this.readVertices(t,m),y=t.readInt(!0);let w=null,x=0,b=0;l&&(w=this.readShortArray(t),x=t.readFloat(),b=t.readFloat()),d==null&&(d=i);const S=this.attachmentLoader.newMeshAttachment(s,i,d);return S==null?null:(S.path=d,ne.rgba8888ToColor(S.color,u),S.bones=p.bones,S.vertices=p.vertices,S.worldVerticesLength=m<<1,S.triangles=g,S.regionUVs=new Float32Array(c),S.hullLength=y<<1,l&&(S.edges=w,S.width=x*h,S.height=b*h),S)}case Be.LinkedMesh:{let d=t.readStringRef();const u=t.readInt32(),m=t.readStringRef(),c=t.readStringRef(),g=t.readBoolean();let p=0,y=0;l&&(p=t.readFloat(),y=t.readFloat()),d==null&&(d=i);const w=this.attachmentLoader.newMeshAttachment(s,i,d);return w==null?null:(w.path=d,ne.rgba8888ToColor(w.color,u),l&&(w.width=p*h,w.height=y*h),this.linkedMeshes.push(new Ry(w,m,n,c,g)),w)}case Be.Path:{const d=t.readBoolean(),u=t.readBoolean(),m=t.readInt(!0),c=this.readVertices(t,m),g=dt.newArray(m/3,0);for(let w=0,x=g.length;w<x;w++)g[w]=t.readFloat()*h;const p=l?t.readInt32():0,y=this.attachmentLoader.newPathAttachment(s,i);return y==null?null:(y.closed=d,y.constantSpeed=u,y.worldVerticesLength=m<<1,y.vertices=c.vertices,y.bones=c.bones,y.lengths=g,l&&ne.rgba8888ToColor(y.color,p),y)}case Be.Point:{const d=t.readFloat(),u=t.readFloat(),m=t.readFloat(),c=l?t.readInt32():0,g=this.attachmentLoader.newPointAttachment(s,i);return g==null?null:(g.x=u*h,g.y=m*h,g.rotation=d,l&&ne.rgba8888ToColor(g.color,c),g)}case Be.Clipping:{const d=t.readInt(!0),u=t.readInt(!0),m=this.readVertices(t,u),c=l?t.readInt32():0,g=this.attachmentLoader.newClippingAttachment(s,i);return g==null?null:(g.endSlot=e.slots[d],g.worldVerticesLength=u<<1,g.vertices=m.vertices,g.bones=m.bones,l&&ne.rgba8888ToColor(g.color,c),g)}}return null}readVertices(t,e){const s=e<<1,n=new Yy,r=this.scale;if(!t.readBoolean())return n.vertices=this.readFloatArray(t,s,r),n;const l=new Array,h=new Array;for(let i=0;i<e;i++){const a=t.readInt(!0);h.push(a);for(let o=0;o<a;o++)h.push(t.readInt(!0)),l.push(t.readFloat()*r),l.push(t.readFloat()*r),l.push(t.readFloat())}return n.vertices=dt.toFloatArray(l),n.bones=h,n}readFloatArray(t,e,s){const n=new Array(e);if(s==1)for(let r=0;r<e;r++)n[r]=t.readFloat();else for(let r=0;r<e;r++)n[r]=t.readFloat()*s;return n}readShortArray(t){const e=t.readInt(!0),s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readShort();return s}readAnimation(t,e,s){const n=new Array,r=this.scale;let l=0;const h=new ne,i=new ne;for(let d=0,u=t.readInt(!0);d<u;d++){const m=t.readInt(!0);for(let c=0,g=t.readInt(!0);c<g;c++){const p=t.readByte(),y=t.readInt(!0);switch(p){case Fe.SLOT_ATTACHMENT:{const w=new Xa(y);w.slotIndex=m;for(let x=0;x<y;x++)w.setFrame(x,t.readFloat(),t.readStringRef());n.push(w),l=Math.max(l,w.frames[y-1]);break}case Fe.SLOT_COLOR:{const w=new rl(y);w.slotIndex=m;for(let x=0;x<y;x++){const b=t.readFloat();ne.rgba8888ToColor(h,t.readInt32()),w.setFrame(x,b,h.r,h.g,h.b,h.a),x<y-1&&this.readCurve(t,x,w)}n.push(w),l=Math.max(l,w.frames[(y-1)*rl.ENTRIES]);break}case Fe.SLOT_TWO_COLOR:{const w=new il(y);w.slotIndex=m;for(let x=0;x<y;x++){const b=t.readFloat();ne.rgba8888ToColor(h,t.readInt32()),ne.rgb888ToColor(i,t.readInt32()),w.setFrame(x,b,h.r,h.g,h.b,h.a,i.r,i.g,i.b),x<y-1&&this.readCurve(t,x,w)}n.push(w),l=Math.max(l,w.frames[(y-1)*il.ENTRIES]);break}}}}for(let d=0,u=t.readInt(!0);d<u;d++){const m=t.readInt(!0);for(let c=0,g=t.readInt(!0);c<g;c++){const p=t.readByte(),y=t.readInt(!0);switch(p){case Fe.BONE_ROTATE:{const w=new Pn(y);w.boneIndex=m;for(let x=0;x<y;x++)w.setFrame(x,t.readFloat(),t.readFloat()),x<y-1&&this.readCurve(t,x,w);n.push(w),l=Math.max(l,w.frames[(y-1)*Pn.ENTRIES]);break}case Fe.BONE_TRANSLATE:case Fe.BONE_SCALE:case Fe.BONE_SHEAR:{let w,x=1;p==Fe.BONE_SCALE?w=new ac(y):p==Fe.BONE_SHEAR?w=new oc(y):(w=new Ba(y),x=r),w.boneIndex=m;for(let b=0;b<y;b++)w.setFrame(b,t.readFloat(),t.readFloat()*x,t.readFloat()*x),b<y-1&&this.readCurve(t,b,w);n.push(w),l=Math.max(l,w.frames[(y-1)*Ba.ENTRIES]);break}}}}for(let d=0,u=t.readInt(!0);d<u;d++){const m=t.readInt(!0),c=t.readInt(!0),g=new al(c);g.ikConstraintIndex=m;for(let p=0;p<c;p++)g.setFrame(p,t.readFloat(),t.readFloat(),t.readFloat()*r,t.readByte(),t.readBoolean(),t.readBoolean()),p<c-1&&this.readCurve(t,p,g);n.push(g),l=Math.max(l,g.frames[(c-1)*al.ENTRIES])}for(let d=0,u=t.readInt(!0);d<u;d++){const m=t.readInt(!0),c=t.readInt(!0),g=new ol(c);g.transformConstraintIndex=m;for(let p=0;p<c;p++)g.setFrame(p,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat()),p<c-1&&this.readCurve(t,p,g);n.push(g),l=Math.max(l,g.frames[(c-1)*ol.ENTRIES])}for(let d=0,u=t.readInt(!0);d<u;d++){const m=t.readInt(!0),c=s.pathConstraints[m];for(let g=0,p=t.readInt(!0);g<p;g++){const y=t.readByte(),w=t.readInt(!0);switch(y){case Fe.PATH_POSITION:case Fe.PATH_SPACING:{let x,b=1;y==Fe.PATH_SPACING?(x=new hc(w),(c.spacingMode==ds.Length||c.spacingMode==ds.Fixed)&&(b=r)):(x=new xo(w),c.positionMode==$r.Fixed&&(b=r)),x.pathConstraintIndex=m;for(let S=0;S<w;S++)x.setFrame(S,t.readFloat(),t.readFloat()*b),S<w-1&&this.readCurve(t,S,x);n.push(x),l=Math.max(l,x.frames[(w-1)*xo.ENTRIES]);break}case Fe.PATH_MIX:{const x=new hl(w);x.pathConstraintIndex=m;for(let b=0;b<w;b++)x.setFrame(b,t.readFloat(),t.readFloat(),t.readFloat()),b<w-1&&this.readCurve(t,b,x);n.push(x),l=Math.max(l,x.frames[(w-1)*hl.ENTRIES]);break}}}}for(let d=0,u=t.readInt(!0);d<u;d++){const m=s.skins[t.readInt(!0)];for(let c=0,g=t.readInt(!0);c<g;c++){const p=t.readInt(!0);for(let y=0,w=t.readInt(!0);y<w;y++){const x=m.getAttachment(p,t.readStringRef()),b=x.bones!=null,S=x.vertices,C=b?S.length/3*2:S.length,v=t.readInt(!0),A=new lc(v);A.slotIndex=p,A.attachment=x;for(let M=0;M<v;M++){const I=t.readFloat();let E,P=t.readInt(!0);if(P==0)E=b?dt.newFloatArray(C):S;else{E=dt.newFloatArray(C);const R=t.readInt(!0);if(P+=R,r==1)for(let k=R;k<P;k++)E[k]=t.readFloat();else for(let k=R;k<P;k++)E[k]=t.readFloat()*r;if(!b)for(let k=0,Y=E.length;k<Y;k++)E[k]+=S[k]}A.setFrame(M,I,E),M<v-1&&this.readCurve(t,M,A)}n.push(A),l=Math.max(l,A.frames[v-1])}}}const a=t.readInt(!0);if(a>0){const d=new po(a),u=s.slots.length;for(let m=0;m<a;m++){const c=t.readFloat(),g=t.readInt(!0),p=dt.newArray(u,0);for(let b=u-1;b>=0;b--)p[b]=-1;const y=dt.newArray(u-g,0);let w=0,x=0;for(let b=0;b<g;b++){const S=t.readInt(!0);for(;w!=S;)y[x++]=w++;p[w+t.readInt(!0)]=w++}for(;w<u;)y[x++]=w++;for(let b=u-1;b>=0;b--)p[b]==-1&&(p[b]=y[--x]);d.setFrame(m,c,p)}n.push(d),l=Math.max(l,d.frames[a-1])}const o=t.readInt(!0);if(o>0){const d=new ah(o);for(let u=0;u<o;u++){const m=t.readFloat(),c=s.events[t.readInt(!0)],g=new gc(m,c);g.intValue=t.readInt(!1),g.floatValue=t.readFloat(),g.stringValue=t.readBoolean()?t.readString():c.stringValue,g.data.audioPath!=null&&(g.volume=t.readFloat(),g.balance=t.readFloat()),d.setFrame(u,g)}n.push(d),l=Math.max(l,d.frames[o-1])}return new Xe(e,n,l)}readCurve(t,e,s){switch(t.readByte()){case Fe.CURVE_STEPPED:s.setStepped(e);break;case Fe.CURVE_BEZIER:this.setCurve(s,e,t.readFloat(),t.readFloat(),t.readFloat(),t.readFloat());break}}setCurve(t,e,s,n,r,l){t.setCurve(e,s,n,r,l)}};me(Ge,"AttachmentTypeValues",[0,1,2,3,4,5,6]),me(Ge,"TransformModeValues",[Ie.Normal,Ie.OnlyTranslation,Ie.NoRotationOrReflection,Ie.NoScale,Ie.NoScaleOrReflection]),me(Ge,"PositionModeValues",[$r.Fixed,$r.Percent]),me(Ge,"SpacingModeValues",[ds.Length,ds.Fixed,ds.Percent]),me(Ge,"RotateModeValues",[Nr.Tangent,Nr.Chain,Nr.ChainScale]),me(Ge,"BlendModeValues",[V.BLEND_MODES.NORMAL,V.BLEND_MODES.ADD,V.BLEND_MODES.MULTIPLY,V.BLEND_MODES.SCREEN]),me(Ge,"BONE_ROTATE",0),me(Ge,"BONE_TRANSLATE",1),me(Ge,"BONE_SCALE",2),me(Ge,"BONE_SHEAR",3),me(Ge,"SLOT_ATTACHMENT",0),me(Ge,"SLOT_COLOR",1),me(Ge,"SLOT_TWO_COLOR",2),me(Ge,"PATH_POSITION",0),me(Ge,"PATH_SPACING",1),me(Ge,"PATH_MIX",2),me(Ge,"CURVE_LINEAR",0),me(Ge,"CURVE_STEPPED",1),me(Ge,"CURVE_BEZIER",2);let dg=Ge,Ry=class{constructor(t,e,s,n,r){me(this,"parent"),me(this,"skin"),me(this,"slotIndex"),me(this,"mesh"),me(this,"inheritDeform"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritDeform=r}},Yy=class{constructor(t=null,e=null){this.bones=t,this.vertices=e}};var Fy=Object.defineProperty,By=(f,t,e)=>t in f?Fy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,qi=(f,t,e)=>By(f,typeof t!="symbol"?t+"":t,e);let ug=class Vo{constructor(t){qi(this,"attachmentLoader"),qi(this,"scale",1),qi(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new pc,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r!=null){if(s.hash=r.hash,s.version=r.spine,s.version.substr(0,3)!=="3.8"){const l=`Spine 3.8 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(l)}s.version==="3.8.75"&&console.error("Unsupported skeleton data, 3.8.75 is deprecated, please export with a newer version of Spine."),s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images}if(n.bones)for(let l=0;l<n.bones.length;l++){const h=n.bones[l];let i=null;const a=this.getValue(h,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const o=new bc(s.bones.length,h.name,i);o.length=this.getValue(h,"length",0)*e,o.x=this.getValue(h,"x",0)*e,o.y=this.getValue(h,"y",0)*e,o.rotation=this.getValue(h,"rotation",0),o.scaleX=this.getValue(h,"scaleX",1),o.scaleY=this.getValue(h,"scaleY",1),o.shearX=this.getValue(h,"shearX",0),o.shearY=this.getValue(h,"shearY",0),o.transformMode=Vo.transformModeFromString(this.getValue(h,"transform","normal")),o.skinRequired=this.getValue(h,"skin",!1),s.bones.push(o)}if(n.slots)for(let l=0;l<n.slots.length;l++){const h=n.slots[l],i=h.name,a=h.bone,o=s.findBone(a);if(o==null)throw new Error(`Slot bone not found: ${a}`);const d=new xc(s.slots.length,i,o),u=this.getValue(h,"color",null);u!=null&&d.color.setFromString(u);const m=this.getValue(h,"dark",null);m!=null&&(d.darkColor=new ne(1,1,1,1),d.darkColor.setFromString(m)),d.attachmentName=this.getValue(h,"attachment",null),d.blendMode=Vo.blendModeFromString(this.getValue(h,"blend","normal")),s.slots.push(d)}if(n.ik)for(let l=0;l<n.ik.length;l++){const h=n.ik[l],i=new wc(h.name);i.order=this.getValue(h,"order",0),i.skinRequired=this.getValue(h,"skin",!1);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],u=s.findBone(d);if(u==null)throw new Error(`IK bone not found: ${d}`);i.bones.push(u)}const a=h.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`IK target bone not found: ${a}`);i.mix=this.getValue(h,"mix",1),i.softness=this.getValue(h,"softness",0)*e,i.bendDirection=this.getValue(h,"bendPositive",!0)?1:-1,i.compress=this.getValue(h,"compress",!1),i.stretch=this.getValue(h,"stretch",!1),i.uniform=this.getValue(h,"uniform",!1),s.ikConstraints.push(i)}if(n.transform)for(let l=0;l<n.transform.length;l++){const h=n.transform[l],i=new yc(h.name);i.order=this.getValue(h,"order",0),i.skinRequired=this.getValue(h,"skin",!1);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],u=s.findBone(d);if(u==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(u)}const a=h.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);i.local=this.getValue(h,"local",!1),i.relative=this.getValue(h,"relative",!1),i.offsetRotation=this.getValue(h,"rotation",0),i.offsetX=this.getValue(h,"x",0)*e,i.offsetY=this.getValue(h,"y",0)*e,i.offsetScaleX=this.getValue(h,"scaleX",0),i.offsetScaleY=this.getValue(h,"scaleY",0),i.offsetShearY=this.getValue(h,"shearY",0),i.rotateMix=this.getValue(h,"rotateMix",1),i.translateMix=this.getValue(h,"translateMix",1),i.scaleMix=this.getValue(h,"scaleMix",1),i.shearMix=this.getValue(h,"shearMix",1),s.transformConstraints.push(i)}if(n.path)for(let l=0;l<n.path.length;l++){const h=n.path[l],i=new fc(h.name);i.order=this.getValue(h,"order",0),i.skinRequired=this.getValue(h,"skin",!1);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],u=s.findBone(d);if(u==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(u)}const a=h.target;if(i.target=s.findSlot(a),i.target==null)throw new Error(`Path target slot not found: ${a}`);i.positionMode=Vo.positionModeFromString(this.getValue(h,"positionMode","percent")),i.spacingMode=Vo.spacingModeFromString(this.getValue(h,"spacingMode","length")),i.rotateMode=Vo.rotateModeFromString(this.getValue(h,"rotateMode","tangent")),i.offsetRotation=this.getValue(h,"rotation",0),i.position=this.getValue(h,"position",0),i.positionMode==$r.Fixed&&(i.position*=e),i.spacing=this.getValue(h,"spacing",0),(i.spacingMode==ds.Length||i.spacingMode==ds.Fixed)&&(i.spacing*=e),i.rotateMix=this.getValue(h,"rotateMix",1),i.translateMix=this.getValue(h,"translateMix",1),s.pathConstraints.push(i)}if(n.skins)for(let l=0;l<n.skins.length;l++){const h=n.skins[l],i=new dh(h.name);if(h.bones)for(let a=0;a<h.bones.length;a++){const o=s.findBone(h.bones[a]);if(o==null)throw new Error(`Skin bone not found: ${h.bones[l]}`);i.bones.push(o)}if(h.ik)for(let a=0;a<h.ik.length;a++){const o=s.findIkConstraint(h.ik[a]);if(o==null)throw new Error(`Skin IK constraint not found: ${h.ik[l]}`);i.constraints.push(o)}if(h.transform)for(let a=0;a<h.transform.length;a++){const o=s.findTransformConstraint(h.transform[a]);if(o==null)throw new Error(`Skin transform constraint not found: ${h.transform[l]}`);i.constraints.push(o)}if(h.path)for(let a=0;a<h.path.length;a++){const o=s.findPathConstraint(h.path[a]);if(o==null)throw new Error(`Skin path constraint not found: ${h.path[l]}`);i.constraints.push(o)}for(const a in h.attachments){const o=s.findSlot(a);if(o==null)throw new Error(`Slot not found: ${a}`);const d=h.attachments[a];for(const u in d){const m=this.readAttachment(d[u],i,o.index,u,s);m!=null&&i.setAttachment(o.index,u,m)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let l=0,h=this.linkedMeshes.length;l<h;l++){const i=this.linkedMeshes[l],a=i.skin==null?s.defaultSkin:s.findSkin(i.skin);if(a==null)throw new Error(`Skin not found: ${i.skin}`);const o=a.getAttachment(i.slotIndex,i.parent);if(o==null)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.deformAttachment=i.inheritDeform?o:i.mesh,i.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,n.events)for(const l in n.events){const h=n.events[l],i=new Cc(l);i.intValue=this.getValue(h,"int",0),i.floatValue=this.getValue(h,"float",0),i.stringValue=this.getValue(h,"string",""),i.audioPath=this.getValue(h,"audio",null),i.audioPath!=null&&(i.volume=this.getValue(h,"volume",1),i.balance=this.getValue(h,"balance",0)),s.events.push(i)}if(n.animations)for(const l in n.animations){const h=n.animations[l];this.readAnimation(h,l,s)}return s}readAttachment(t,e,s,n,r){const l=this.scale;switch(n=this.getValue(t,"name",n),this.getValue(t,"type","region")){case"region":{const i=this.getValue(t,"path",n),a=this.attachmentLoader.newRegionAttachment(e,n,i);if(a==null)return null;a.path=i,a.x=this.getValue(t,"x",0)*l,a.y=this.getValue(t,"y",0)*l,a.scaleX=this.getValue(t,"scaleX",1),a.scaleY=this.getValue(t,"scaleY",1),a.rotation=this.getValue(t,"rotation",0),a.width=t.width*l,a.height=t.height*l;const o=this.getValue(t,"color",null);return o!=null&&a.color.setFromString(o),a}case"boundingbox":{const i=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(i==null)return null;this.readVertices(t,i,t.vertexCount<<1);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"mesh":case"linkedmesh":{const i=this.getValue(t,"path",n),a=this.attachmentLoader.newMeshAttachment(e,n,i);if(a==null)return null;a.path=i;const o=this.getValue(t,"color",null);o!=null&&a.color.setFromString(o),a.width=this.getValue(t,"width",0)*l,a.height=this.getValue(t,"height",0)*l;const d=this.getValue(t,"parent",null);if(d!=null)return this.linkedMeshes.push(new Xy(a,this.getValue(t,"skin",null),s,d,this.getValue(t,"deform",!0))),a;const u=t.uvs;return this.readVertices(t,a,u.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(u),a.edges=this.getValue(t,"edges",null),a.hullLength=this.getValue(t,"hull",0)*2,a}case"path":{const i=this.attachmentLoader.newPathAttachment(e,n);if(i==null)return null;i.closed=this.getValue(t,"closed",!1),i.constantSpeed=this.getValue(t,"constantSpeed",!0);const a=t.vertexCount;this.readVertices(t,i,a<<1);const o=dt.newArray(a/3,0);for(let u=0;u<t.lengths.length;u++)o[u]=t.lengths[u]*l;i.lengths=o;const d=this.getValue(t,"color",null);return d!=null&&i.color.setFromString(d),i}case"point":{const i=this.attachmentLoader.newPointAttachment(e,n);if(i==null)return null;i.x=this.getValue(t,"x",0)*l,i.y=this.getValue(t,"y",0)*l,i.rotation=this.getValue(t,"rotation",0);const a=this.getValue(t,"color",null);return a!=null&&i.color.setFromString(a),i}case"clipping":{const i=this.attachmentLoader.newClippingAttachment(e,n);if(i==null)return null;const a=this.getValue(t,"end",null);if(a!=null){const u=r.findSlot(a);if(u==null)throw new Error(`Clipping end slot not found: ${a}`);i.endSlot=u}const o=t.vertexCount;this.readVertices(t,i,o<<1);const d=this.getValue(t,"color",null);return d!=null&&i.color.setFromString(d),i}}return null}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=dt.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const l=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),l.push(r[i+1]*n),l.push(r[i+2]*n),l.push(r[i+3])}e.bones=h,e.vertices=dt.toFloatArray(l)}readAnimation(t,e,s){const n=this.scale,r=new Array;let l=0;if(t.slots)for(const i in t.slots){const a=t.slots[i],o=s.findSlotIndex(i);if(o==-1)throw new Error(`Slot not found: ${i}`);for(const d in a){const u=a[d];if(d=="attachment"){const m=new Xa(u.length);m.slotIndex=o;let c=0;for(let g=0;g<u.length;g++){const p=u[g];m.setFrame(c++,this.getValue(p,"time",0),p.name)}r.push(m),l=Math.max(l,m.frames[m.getFrameCount()-1])}else if(d=="color"){const m=new rl(u.length);m.slotIndex=o;let c=0;for(let g=0;g<u.length;g++){const p=u[g],y=new ne;y.setFromString(p.color||"ffffffff"),m.setFrame(c,this.getValue(p,"time",0),y.r,y.g,y.b,y.a),this.readCurve(p,m,c),c++}r.push(m),l=Math.max(l,m.frames[(m.getFrameCount()-1)*rl.ENTRIES])}else if(d=="twoColor"){const m=new il(u.length);m.slotIndex=o;let c=0;for(let g=0;g<u.length;g++){const p=u[g],y=new ne,w=new ne;y.setFromString(p.light),w.setFromString(p.dark),m.setFrame(c,this.getValue(p,"time",0),y.r,y.g,y.b,y.a,w.r,w.g,w.b),this.readCurve(p,m,c),c++}r.push(m),l=Math.max(l,m.frames[(m.getFrameCount()-1)*il.ENTRIES])}else throw new Error(`Invalid timeline type for a slot: ${d} (${i})`)}}if(t.bones)for(const i in t.bones){const a=t.bones[i],o=s.findBoneIndex(i);if(o==-1)throw new Error(`Bone not found: ${i}`);for(const d in a){const u=a[d];if(d==="rotate"){const m=new Pn(u.length);m.boneIndex=o;let c=0;for(let g=0;g<u.length;g++){const p=u[g];m.setFrame(c,this.getValue(p,"time",0),this.getValue(p,"angle",0)),this.readCurve(p,m,c),c++}r.push(m),l=Math.max(l,m.frames[(m.getFrameCount()-1)*Pn.ENTRIES])}else if(d==="translate"||d==="scale"||d==="shear"){let m=null,c=1,g=0;d==="scale"?(m=new ac(u.length),g=1):d==="shear"?m=new oc(u.length):(m=new Ba(u.length),c=n),m.boneIndex=o;let p=0;for(let y=0;y<u.length;y++){const w=u[y],x=this.getValue(w,"x",g),b=this.getValue(w,"y",g);m.setFrame(p,this.getValue(w,"time",0),x*c,b*c),this.readCurve(w,m,p),p++}r.push(m),l=Math.max(l,m.frames[(m.getFrameCount()-1)*Ba.ENTRIES])}else throw new Error(`Invalid timeline type for a bone: ${d} (${i})`)}}if(t.ik)for(const i in t.ik){const a=t.ik[i],o=s.findIkConstraint(i),d=new al(a.length);d.ikConstraintIndex=s.ikConstraints.indexOf(o);let u=0;for(let m=0;m<a.length;m++){const c=a[m];d.setFrame(u,this.getValue(c,"time",0),this.getValue(c,"mix",1),this.getValue(c,"softness",0)*n,this.getValue(c,"bendPositive",!0)?1:-1,this.getValue(c,"compress",!1),this.getValue(c,"stretch",!1)),this.readCurve(c,d,u),u++}r.push(d),l=Math.max(l,d.frames[(d.getFrameCount()-1)*al.ENTRIES])}if(t.transform)for(const i in t.transform){const a=t.transform[i],o=s.findTransformConstraint(i),d=new ol(a.length);d.transformConstraintIndex=s.transformConstraints.indexOf(o);let u=0;for(let m=0;m<a.length;m++){const c=a[m];d.setFrame(u,this.getValue(c,"time",0),this.getValue(c,"rotateMix",1),this.getValue(c,"translateMix",1),this.getValue(c,"scaleMix",1),this.getValue(c,"shearMix",1)),this.readCurve(c,d,u),u++}r.push(d),l=Math.max(l,d.frames[(d.getFrameCount()-1)*ol.ENTRIES])}if(t.path)for(const i in t.path){const a=t.path[i],o=s.findPathConstraintIndex(i);if(o==-1)throw new Error(`Path constraint not found: ${i}`);const d=s.pathConstraints[o];for(const u in a){const m=a[u];if(u==="position"||u==="spacing"){let c=null,g=1;u==="spacing"?(c=new hc(m.length),(d.spacingMode==ds.Length||d.spacingMode==ds.Fixed)&&(g=n)):(c=new xo(m.length),d.positionMode==$r.Fixed&&(g=n)),c.pathConstraintIndex=o;let p=0;for(let y=0;y<m.length;y++){const w=m[y];c.setFrame(p,this.getValue(w,"time",0),this.getValue(w,u,0)*g),this.readCurve(w,c,p),p++}r.push(c),l=Math.max(l,c.frames[(c.getFrameCount()-1)*xo.ENTRIES])}else if(u==="mix"){const c=new hl(m.length);c.pathConstraintIndex=o;let g=0;for(let p=0;p<m.length;p++){const y=m[p];c.setFrame(g,this.getValue(y,"time",0),this.getValue(y,"rotateMix",1),this.getValue(y,"translateMix",1)),this.readCurve(y,c,g),g++}r.push(c),l=Math.max(l,c.frames[(c.getFrameCount()-1)*hl.ENTRIES])}}}if(t.deform)for(const i in t.deform){const a=t.deform[i],o=s.findSkin(i);if(o!=null)for(const d in a){const u=a[d],m=s.findSlotIndex(d);if(m==-1)throw new Error(`Slot not found: ${u.name}`);for(const c in u){const g=u[c],p=o.getAttachment(m,c);if(p==null)throw new Error(`Deform attachment not found: ${g.name}`);const y=p.bones!=null,w=p.vertices,x=y?w.length/3*2:w.length,b=new lc(g.length);b.slotIndex=m,b.attachment=p;let S=0;for(let C=0;C<g.length;C++){const v=g[C];let A;const M=this.getValue(v,"vertices",null);if(M==null)A=y?dt.newFloatArray(x):w;else{A=dt.newFloatArray(x);const I=this.getValue(v,"offset",0);if(dt.arrayCopy(M,0,A,I,M.length),n!=1)for(let E=I,P=E+M.length;E<P;E++)A[E]*=n;if(!y)for(let E=0;E<x;E++)A[E]+=w[E]}b.setFrame(S,this.getValue(v,"time",0),A),this.readCurve(v,b,S),S++}r.push(b),l=Math.max(l,b.frames[b.getFrameCount()-1])}}}let h=t.drawOrder;if(h==null&&(h=t.draworder),h!=null){const i=new po(h.length),a=s.slots.length;let o=0;for(let d=0;d<h.length;d++){const u=h[d];let m=null;const c=this.getValue(u,"offsets",null);if(c!=null){m=dt.newArray(a,-1);const g=dt.newArray(a-c.length,0);let p=0,y=0;for(let w=0;w<c.length;w++){const x=c[w],b=s.findSlotIndex(x.slot);if(b==-1)throw new Error(`Slot not found: ${x.slot}`);for(;p!=b;)g[y++]=p++;m[p+x.offset]=p++}for(;p<a;)g[y++]=p++;for(let w=a-1;w>=0;w--)m[w]==-1&&(m[w]=g[--y])}i.setFrame(o++,this.getValue(u,"time",0),m)}r.push(i),l=Math.max(l,i.frames[i.getFrameCount()-1])}if(t.events){const i=new ah(t.events.length);let a=0;for(let o=0;o<t.events.length;o++){const d=t.events[o],u=s.findEvent(d.name);if(u==null)throw new Error(`Event not found: ${d.name}`);const m=new gc(dt.toSinglePrecision(this.getValue(d,"time",0)),u);m.intValue=this.getValue(d,"int",u.intValue),m.floatValue=this.getValue(d,"float",u.floatValue),m.stringValue=this.getValue(d,"string",u.stringValue),m.data.audioPath!=null&&(m.volume=this.getValue(d,"volume",1),m.balance=this.getValue(d,"balance",0)),i.setFrame(a++,m)}r.push(i),l=Math.max(l,i.frames[i.getFrameCount()-1])}if(isNaN(l))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new Xe(e,r,l))}readCurve(t,e,s){if(t.hasOwnProperty("curve"))if(t.curve==="stepped")e.setStepped(s);else{const n=t.curve;e.setCurve(s,n,this.getValue(t,"c2",0),this.getValue(t,"c3",1),this.getValue(t,"c4",1))}}getValue(t,e,s){return t[e]!==void 0?t[e]:s}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return V.BLEND_MODES.NORMAL;if(t=="additive")return V.BLEND_MODES.ADD;if(t=="multiply")return V.BLEND_MODES.MULTIPLY;if(t=="screen")return V.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}static positionModeFromString(t){if(t=t.toLowerCase(),t=="fixed")return $r.Fixed;if(t=="percent")return $r.Percent;throw new Error(`Unknown position mode: ${t}`)}static spacingModeFromString(t){if(t=t.toLowerCase(),t=="length")return ds.Length;if(t=="fixed")return ds.Fixed;if(t=="percent")return ds.Percent;throw new Error(`Unknown position mode: ${t}`)}static rotateModeFromString(t){if(t=t.toLowerCase(),t=="tangent")return Nr.Tangent;if(t=="chain")return Nr.Chain;if(t=="chainscale")return Nr.ChainScale;throw new Error(`Unknown rotate mode: ${t}`)}static transformModeFromString(t){if(t=t.toLowerCase(),t=="normal")return Ie.Normal;if(t=="onlytranslation")return Ie.OnlyTranslation;if(t=="norotationorreflection")return Ie.NoRotationOrReflection;if(t=="noscale")return Ie.NoScale;if(t=="noscaleorreflection")return Ie.NoScaleOrReflection;throw new Error(`Unknown transform mode: ${t}`)}},Xy=class{constructor(t,e,s,n,r){qi(this,"parent"),qi(this,"skin"),qi(this,"slotIndex"),qi(this,"mesh"),qi(this,"inheritDeform"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritDeform=r}};var $y=Object.defineProperty,Ny=(f,t,e)=>t in f?$y(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Rs=(f,t,e)=>Ny(f,typeof t!="symbol"?t+"":t,e);let fg=class{constructor(){Rs(this,"entries",{}),Rs(this,"size",0)}add(t){const e=this.entries[t];return this.entries[t]=!0,e?!1:(this.size++,!0)}addAll(t){const e=this.size;for(let s=0,n=t.length;s<n;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}};const sr=class Fx{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Fx().setFromString(t)}};Rs(sr,"WHITE",new sr(1,1,1,1)),Rs(sr,"RED",new sr(1,0,0,1)),Rs(sr,"GREEN",new sr(0,1,0,1)),Rs(sr,"BLUE",new sr(0,0,1,1)),Rs(sr,"MAGENTA",new sr(1,0,1,1));let Dt=sr;const xn=class Hl{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Hl.degRad)}static sinDeg(t){return Math.sin(t*Hl.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Hl.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Hl.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};Rs(xn,"PI",3.1415927),Rs(xn,"PI2",xn.PI*2),Rs(xn,"invPI2",1/xn.PI2),Rs(xn,"radiansToDegrees",180/xn.PI),Rs(xn,"radDeg",xn.radiansToDegrees),Rs(xn,"degreesToRadians",xn.PI/180),Rs(xn,"degRad",xn.degreesToRadians);let et=xn;const mg=class _o{static arrayCopy(t,e,s,n,r){for(let l=e,h=n;l<e+r;l++,h++)s[h]=t[l]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:_o.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(_o.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(_o.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return _o.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return _o.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};Rs(mg,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let mt=mg,gg=class{constructor(t){Rs(this,"items",new Array),Rs(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},vc=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};var $e=(f=>(f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping",f))($e||{}),Yn=(f=>(f[f.Normal=0]="Normal",f[f.OnlyTranslation=1]="OnlyTranslation",f[f.NoRotationOrReflection=2]="NoRotationOrReflection",f[f.NoScale=3]="NoScale",f[f.NoScaleOrReflection=4]="NoScaleOrReflection",f))(Yn||{}),pg=(f=>(f[f.none=0]="none",f[f.reset=1]="reset",f[f.update=2]="update",f[f.pose=3]="pose",f))(pg||{}),Vy=Object.defineProperty,_y=(f,t,e)=>t in f?Vy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ml=(f,t,e)=>_y(f,typeof t!="symbol"?t+"":t,e);let xg=class{constructor(){ml(this,"texture"),ml(this,"size",null),ml(this,"names",null),ml(this,"values",null),ml(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var bg=(f=>(f[f.UNKNOWN=0]="UNKNOWN",f[f.VER37=37]="VER37",f[f.VER38=38]="VER38",f[f.VER40=40]="VER40",f[f.VER41=41]="VER41",f[f.VER42=42]="VER42",f))(bg||{});function Dy(f){const t=f.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const Ly={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var Oy=Object.defineProperty,Wy=(f,t,e)=>t in f?Oy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ys=(f,t,e)=>Wy(f,typeof t!="symbol"?t+"":t,e);const zi=[0,0,0];let Uy=class extends $i.Sprite{constructor(){super(...arguments),Ys(this,"region",null),Ys(this,"attachment",null)}},qy=class extends Xi.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),Ys(this,"region",null),Ys(this,"attachment",null)}};const wg=class Bx extends Et.Container{constructor(t){if(super(),Ys(this,"tintRgb"),Ys(this,"spineData"),Ys(this,"skeleton"),Ys(this,"stateData"),Ys(this,"state"),Ys(this,"slotContainers"),Ys(this,"tempClipContainers"),Ys(this,"localDelayLimit"),Ys(this,"_autoUpdate"),Ys(this,"_visible"),Ys(this,"_debug"),Ys(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),l=this.newContainer();if(this.slotContainers.push(l),this.addChild(l),this.tempClipContainers.push(null),!!r)if(r.type===$e.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,l.addChild(i)}else if(r.type===$e.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,l.addChild(h)}else r.type===$e.Clipping&&(this.createGraphics(n,r),l.addChild(n.clippingContainer),l.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?Bx.prototype.autoUpdateTransform:Et.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=V.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:Ly.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=Dy(this.spineData.version||this.spineData.spine.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===bg.VER42&&pg.update);const n=this.skeleton.slots,r=this.color;let l=null,h=null;r?(l=r.light,h=r.dark):l=this.tintRgb;for(let u=0,m=n.length;u<m;u++){const c=n[u],g=c.getAttachment(),p=this.slotContainers[u];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(c,g);let w=g.region;const x=g.color;switch(g!=null&&g.type){case $e.Region:if(p.transform.setFromMatrix(c.bone.matrix),w=g.region,c.currentMesh&&(c.currentMesh.visible=!1,c.currentMesh=null,c.currentMeshId=void 0,c.currentMeshName=void 0),!w){c.currentSprite&&(c.currentSprite.renderable=!1);break}if(!c.currentSpriteName||c.currentSpriteName!==g.name){const C=g.name;if(c.currentSprite&&(c.currentSprite.visible=!1),c.sprites=c.sprites||{},c.sprites[C]!==void 0)c.sprites[C].visible=!0;else{const v=this.createSprite(c,g,C);p.addChild(v)}c.currentSprite=c.sprites[C],c.currentSpriteName=C}c.currentSprite.renderable=!0,c.hackRegion||this.setSpriteRegion(g,c.currentSprite,w),c.currentSprite.color?y=c.currentSprite.color:(zi[0]=l[0]*c.color.r*x.r,zi[1]=l[1]*c.color.g*x.g,zi[2]=l[2]*c.color.b*x.b,c.currentSprite.tint=V.utils.rgb2hex(zi)),c.currentSprite.blendMode=c.blendMode;break;case $e.Mesh:if(c.currentSprite){c.currentSprite.visible=!1,c.currentSprite=null,c.currentSpriteName=void 0;const C=new V.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){c.currentMesh&&(c.currentMesh.renderable=!1);break}const S=g.id;if(c.currentMeshId===void 0||c.currentMeshId!==S){const C=S;if(c.currentMesh&&(c.currentMesh.visible=!1),c.meshes=c.meshes||{},c.meshes[C]!==void 0)c.meshes[C].visible=!0;else{const v=this.createMesh(c,g);p.addChild(v)}c.currentMesh=c.meshes[C],c.currentMeshName=g.name,c.currentMeshId=C}c.currentMesh.renderable=!0,g.computeWorldVerticesOld(c,c.currentMesh.vertices),c.currentMesh.color?y=c.currentMesh.color:(zi[0]=l[0]*c.color.r*x.r,zi[1]=l[1]*c.color.g*x.g,zi[2]=l[2]*c.color.b*x.b,c.currentMesh.tint=V.utils.rgb2hex(zi)),c.currentMesh.blendMode=c.blendMode,c.hackRegion||this.setMeshRegion(g,c.currentMesh,w);break;case $e.Clipping:c.currentGraphics||(this.createGraphics(c,g),p.addChild(c.clippingContainer),p.addChild(c.currentGraphics)),this.updateGraphics(c,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let b=c.color.r*x.r,S=c.color.g*x.g,C=c.color.b*x.b;y.setLight(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C)),c.darkColor?(b=c.darkColor.r,S=c.darkColor.g,C=c.darkColor.b):(b=0,S=0,C=0),y.setDark(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C))}p.alpha=c.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let u=0,m=i.length;u<m;u++){const c=n[i[u].data.index],g=this.slotContainers[i[u].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),c.currentGraphics&&c.getAttachment())o=c.clippingContainer,a=c.getAttachment(),o.children.length=0,this.children[u]=g,a.endSlot===c.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[u];p||(p=this.tempClipContainers[u]=this.newContainer(),p.visible=!1),this.children[u]=p,g.parent=null,o.addChild(g),a.endSlot==c.data&&(o.renderable=!0,o=null,a=null)}else this.children[u]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*et.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Et.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,l=this.newSprite(r);return l.anchor.set(.5),n&&this.setSpriteRegion(e,l,e.region),t.sprites=t.sprites||{},t.sprites[s]=l,l}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),V.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new V.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let l=r.region;return e?(l=new xg,l.texture=e,l.size=s,n.hackRegion=l,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,l):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,l),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),l=this.skeleton.getAttachmentByName(t,e);l.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=l.region;return s?(a=new xg,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Et.Container}newSprite(t){return new Uy(t)}newGraphics(){return new le.Graphics}newMesh(t,e,s,n,r){return new qy(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let l=0,h=this.skeleton.slots.length;l<h;l++){const i=this.skeleton.slots[l],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};Ys(wg,"clippingPolygon",[]);let yg=wg;Object.defineProperty(yg.prototype,"visible",{get(){return this._visible},set(f){f!==this._visible&&(this._visible=f,f&&(this.lastTime=0))}});var zy=Object.defineProperty,Gy=(f,t,e)=>t in f?zy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Gi=(f,t,e)=>Gy(f,typeof t!="symbol"?t+"":t,e);let Ac=class{constructor(t){if(Gi(this,"name"),Gi(this,"type"),!t)throw new Error("name cannot be null.");this.name=t}};const Sg=class Xx extends Ac{constructor(t){super(t),Gi(this,"id",Xx.nextID++),Gi(this,"bones",null),Gi(this,"vertices",[]),Gi(this,"worldVerticesLength",0),Gi(this,"timelineAttachment",this)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,l){s=r+(s>>1)*l;const h=t.bone.skeleton,i=t.deform;let a=this.vertices;const o=this.bones;if(!o){i.length>0&&(a=i);const c=t.bone.matrix,g=c.tx,p=c.ty,y=c.a,w=c.c,x=c.b,b=c.d;for(let S=e,C=r;C<s;S+=2,C+=l){const v=a[S],A=a[S+1];n[C]=v*y+A*w+g,n[C+1]=v*x+A*b+p}return}let d=0,u=0;for(let c=0;c<e;c+=2){const g=o[d];d+=g+1,u+=g}const m=h.bones;if(i.length==0)for(let c=r,g=u*3;c<s;c+=l){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const x=m[o[d]].matrix,b=a[g],S=a[g+1],C=a[g+2];p+=(b*x.a+S*x.c+x.tx)*C,y+=(b*x.b+S*x.d+x.ty)*C}n[c]=p,n[c+1]=y}else{const c=i;for(let g=r,p=u*3,y=u<<1;g<s;g+=l){let w=0,x=0,b=o[d++];for(b+=d;d<b;d++,p+=3,y+=2){const S=m[o[d]].matrix,C=a[p]+c[y],v=a[p+1]+c[y+1],A=a[p+2];w+=(C*S.a+v*S.c+S.tx)*A,x+=(C*S.b+v*S.d+S.ty)*A}n[g]=w,n[g+1]=x}}}copyTo(t){this.bones?(t.bones=new Array(this.bones.length),mt.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices&&(t.vertices=mt.newFloatArray(this.vertices.length),mt.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)),t.worldVerticesLength=this.worldVerticesLength,t.timelineAttachment=this.timelineAttachment}};Gi(Sg,"nextID",0);let _r=Sg;var Hy=Object.defineProperty,Ky=(f,t,e)=>t in f?Hy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,kt=(f,t,e)=>Ky(f,typeof t!="symbol"?t+"":t,e);const re=class $x extends Ac{constructor(t,e){super(t),kt(this,"type",$e.Region),kt(this,"x",0),kt(this,"y",0),kt(this,"scaleX",1),kt(this,"scaleY",1),kt(this,"rotation",0),kt(this,"width",0),kt(this,"height",0),kt(this,"color",new Dt(1,1,1,1)),kt(this,"path"),kt(this,"rendererObject",null),kt(this,"region",null),kt(this,"sequence",null),kt(this,"offset",mt.newFloatArray(8)),kt(this,"uvs",mt.newFloatArray(8)),kt(this,"tempColor",new Dt(1,1,1,1)),this.path=e}updateRegion(){if(!this.region)throw new Error("Region not set.");const t=this.region,e=this.width/this.region.originalWidth*this.scaleX,s=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,r=-this.height/2*this.scaleY+this.region.offsetY*s,l=n+this.region.width*e,h=r+this.region.height*s,i=this.rotation*Math.PI/180,a=Math.cos(i),o=Math.sin(i),d=this.x,u=this.y,m=n*a+d,c=n*o,g=r*a+u,p=r*o,y=l*a+d,w=l*o,x=h*a+u,b=h*o,S=this.offset;S[0]=m-p,S[1]=g+c,S[2]=m-b,S[3]=x+c,S[4]=y-b,S[5]=x+w,S[6]=y-p,S[7]=g+w;const C=this.uvs;t.degrees==90?(C[2]=t.u,C[3]=t.v2,C[4]=t.u,C[5]=t.v,C[6]=t.u2,C[7]=t.v,C[0]=t.u2,C[1]=t.v2):(C[0]=t.u,C[1]=t.v2,C[2]=t.u,C[3]=t.v,C[4]=t.u2,C[5]=t.v,C[6]=t.u2,C[7]=t.v2)}computeWorldVertices(t,e,s,n){this.sequence!=null&&this.sequence.apply(t,this);const r=t.bone,l=this.offset,h=r.matrix,i=h.tx,a=h.ty,o=h.a,d=h.c,u=h.b,m=h.d;let c=0,g=0;c=l[0],g=l[1],e[s]=c*o+g*d+i,e[s+1]=c*u+g*m+a,s+=n,c=l[2],g=l[3],e[s]=c*o+g*d+i,e[s+1]=c*u+g*m+a,s+=n,c=l[4],g=l[5],e[s]=c*o+g*d+i,e[s+1]=c*u+g*m+a,s+=n,c=l[6],g=l[7],e[s]=c*o+g*d+i,e[s+1]=c*u+g*m+a}copy(){const t=new $x(this.name,this.path);return t.region=this.region,t.rendererObject=this.rendererObject,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,mt.arrayCopy(this.uvs,0,t.uvs,0,8),mt.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t.sequence=this.sequence!=null?this.sequence.copy():null,t}};kt(re,"X1",0),kt(re,"Y1",1),kt(re,"C1R",2),kt(re,"C1G",3),kt(re,"C1B",4),kt(re,"C1A",5),kt(re,"U1",6),kt(re,"V1",7),kt(re,"X2",8),kt(re,"Y2",9),kt(re,"C2R",10),kt(re,"C2G",11),kt(re,"C2B",12),kt(re,"C2A",13),kt(re,"U2",14),kt(re,"V2",15),kt(re,"X3",16),kt(re,"Y3",17),kt(re,"C3R",18),kt(re,"C3G",19),kt(re,"C3B",20),kt(re,"C3A",21),kt(re,"U3",22),kt(re,"V3",23),kt(re,"X4",24),kt(re,"Y4",25),kt(re,"C4R",26),kt(re,"C4G",27),kt(re,"C4B",28),kt(re,"C4A",29),kt(re,"U4",30),kt(re,"V4",31);let Mc=re;var Zy=Object.defineProperty,Jy=(f,t,e)=>t in f?Zy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,bo=(f,t,e)=>Jy(f,typeof t!="symbol"?t+"":t,e);const Cg=class Dh{constructor(t){bo(this,"id",Dh.nextID()),bo(this,"regions"),bo(this,"start",0),bo(this,"digits",0),bo(this,"setupIndex",0),this.regions=new Array(t)}copy(){const t=new Dh(this.regions.length);return mt.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,e){let s=t.sequenceIndex;s==-1&&(s=this.setupIndex),s>=this.regions.length&&(s=this.regions.length-1);const n=this.regions[s];e.region!=n&&(e.region=n)}getPath(t,e){let s=t;const n=(this.start+e).toString();for(let r=this.digits-n.length;r>0;r--)s+="0";return s+=n,s}static nextID(){return Dh._nextID++}};bo(Cg,"_nextID",0);let Tc=Cg;var Dr=(f=>(f[f.hold=0]="hold",f[f.once=1]="once",f[f.loop=2]="loop",f[f.pingpong=3]="pingpong",f[f.onceReverse=4]="onceReverse",f[f.loopReverse=5]="loopReverse",f[f.pingpongReverse=6]="pingpongReverse",f))(Dr||{});const Ec=[0,1,2,3,4,5,6];var G=(f=>(f[f.setup=0]="setup",f[f.first=1]="first",f[f.replace=2]="replace",f[f.add=3]="add",f))(G||{}),bn=(f=>(f[f.mixIn=0]="mixIn",f[f.mixOut=1]="mixOut",f))(bn||{}),Qy=Object.defineProperty,jy=(f,t,e)=>t in f?Qy(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Xt=(f,t,e)=>jy(f,typeof t!="symbol"?t+"":t,e);let uh=class{constructor(t,e,s){if(Xt(this,"name"),Xt(this,"timelines",[]),Xt(this,"timelineIds",new fg),Xt(this,"duration"),!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(e),this.duration=s}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,s,n,r,l,h,i){if(!t)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,l,h,i)}};const ae={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};let Pe=class{constructor(t,e){Xt(this,"propertyIds"),Xt(this,"frames"),this.propertyIds=e,this.frames=mt.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){const s=t.length;for(let n=1;n<s;n++)if(t[n]>e)return n-1;return s-1}static search(t,e,s){const n=t.length;for(let r=s;r<n;r+=s)if(t[r]>e)return r-s;return n-s}},nr=class extends Pe{constructor(t,e,s){super(t,s),Xt(this,"curves"),this.curves=mt.newFloatArray(t+e*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const e=this.getFrameCount()+t*18;if(this.curves.length>e){const s=mt.newFloatArray(e);mt.arrayCopy(this.curves,0,s,0,e),this.curves=s}}setBezier(t,e,s,n,r,l,h,i,a,o,d){const u=this.curves;let m=this.getFrameCount()+t*18;s==0&&(u[e]=2+m);const c=(n-l*2+i)*.03,g=(r-h*2+a)*.03,p=((l-i)*3-n+o)*.006,y=((h-a)*3-r+d)*.006;let w=c*2+p,x=g*2+y,b=(l-n)*.3+c+p*.16666667,S=(h-r)*.3+g+y*.16666667,C=n+b,v=r+S;for(let A=m+18;m<A;m+=2)u[m]=C,u[m+1]=v,b+=w,S+=x,w+=p,x+=y,C+=b,v+=S}getBezierValue(t,e,s,n){const r=this.curves;if(r[n]>t){const a=this.frames[e],o=this.frames[e+s];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}const l=n+18;for(n+=2;n<l;n+=2)if(r[n]>=t){const a=r[n-2],o=r[n-1];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}e+=this.getFrameEntries();const h=r[l-2],i=r[l-1];return i+(t-h)/(this.frames[e]-h)*(this.frames[e+s]-i)}},rr=class extends nr{constructor(t,e,s){super(t,e,[s])}getFrameEntries(){return 2}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+1]=s}getCurveValue(t){const e=this.frames;let s=e.length-2;for(let r=2;r<=s;r+=2)if(e[r]>t){s=r-2;break}const n=this.curves[s>>1];switch(n){case 0:const r=e[s],l=e[s+1];return l+(t-r)/(e[s+2]-r)*(e[s+2+1]-l);case 1:return e[s+1]}return this.getBezierValue(t,s,1,n-2)}},fh=class extends nr{constructor(t,e,s,n){super(t,e,[s,n])}getFrameEntries(){return 3}setFrame(t,e,s,n){t*=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n}},gl=class extends rr{constructor(t,e,s){super(t,e,`${ae.rotate}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.rotation=i.data.rotation;return;case G.first:i.rotation+=(i.data.rotation-i.rotation)*r}return}let o=this.getCurveValue(s);switch(l){case G.setup:i.rotation=i.data.rotation+o*r;break;case G.first:case G.replace:o+=i.data.rotation-i.rotation;case G.add:i.rotation+=o*r}}},Ic=class extends fh{constructor(t,e,s){super(t,e,`${ae.x}|${s}`,`${ae.y}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.x=i.data.x,i.y=i.data.y;return;case G.first:i.x+=(i.data.x-i.x)*r,i.y+=(i.data.y-i.y)*r}return}let o=0,d=0;const u=Pe.search(a,s,3),m=this.curves[u/3];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+3]-c);o+=(a[u+3+1]-o)*g,d+=(a[u+3+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}switch(l){case G.setup:i.x=i.data.x+o*r,i.y=i.data.y+d*r;break;case G.first:case G.replace:i.x+=(i.data.x+o-i.x)*r,i.y+=(i.data.y+d-i.y)*r;break;case G.add:i.x+=o*r,i.y+=d*r}}},kc=class extends rr{constructor(t,e,s){super(t,e,`${ae.x}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.x=i.data.x;return;case G.first:i.x+=(i.data.x-i.x)*r}return}const o=this.getCurveValue(s);switch(l){case G.setup:i.x=i.data.x+o*r;break;case G.first:case G.replace:i.x+=(i.data.x+o-i.x)*r;break;case G.add:i.x+=o*r}}},Pc=class extends rr{constructor(t,e,s){super(t,e,`${ae.y}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.y=i.data.y;return;case G.first:i.y+=(i.data.y-i.y)*r}return}const o=this.getCurveValue(s);switch(l){case G.setup:i.y=i.data.y+o*r;break;case G.first:case G.replace:i.y+=(i.data.y+o-i.y)*r;break;case G.add:i.y+=o*r}}},Rc=class extends fh{constructor(t,e,s){super(t,e,`${ae.scaleX}|${s}`,`${ae.scaleY}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case G.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r,i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}let o,d;const u=Pe.search(a,s,3),m=this.curves[u/3];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+3]-c);o+=(a[u+3+1]-o)*g,d+=(a[u+3+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}if(o*=i.data.scaleX,d*=i.data.scaleY,r==1)l==G.add?(i.scaleX+=o-i.data.scaleX,i.scaleY+=d-i.data.scaleY):(i.scaleX=o,i.scaleY=d);else{let c=0,g=0;if(h==bn.mixOut)switch(l){case G.setup:c=i.data.scaleX,g=i.data.scaleY,i.scaleX=c+(Math.abs(o)*et.signum(c)-c)*r,i.scaleY=g+(Math.abs(d)*et.signum(g)-g)*r;break;case G.first:case G.replace:c=i.scaleX,g=i.scaleY,i.scaleX=c+(Math.abs(o)*et.signum(c)-c)*r,i.scaleY=g+(Math.abs(d)*et.signum(g)-g)*r;break;case G.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}else switch(l){case G.setup:c=Math.abs(i.data.scaleX)*et.signum(o),g=Math.abs(i.data.scaleY)*et.signum(d),i.scaleX=c+(o-c)*r,i.scaleY=g+(d-g)*r;break;case G.first:case G.replace:c=Math.abs(i.scaleX)*et.signum(o),g=Math.abs(i.scaleY)*et.signum(d),i.scaleX=c+(o-c)*r,i.scaleY=g+(d-g)*r;break;case G.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}}}},Yc=class extends rr{constructor(t,e,s){super(t,e,`${ae.scaleX}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.scaleX=i.data.scaleX;return;case G.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r}return}const o=this.getCurveValue(s)*i.data.scaleX;if(r==1)l==G.add?i.scaleX+=o-i.data.scaleX:i.scaleX=o;else{let d=0;if(h==bn.mixOut)switch(l){case G.setup:d=i.data.scaleX,i.scaleX=d+(Math.abs(o)*et.signum(d)-d)*r;break;case G.first:case G.replace:d=i.scaleX,i.scaleX=d+(Math.abs(o)*et.signum(d)-d)*r;break;case G.add:i.scaleX+=(o-i.data.scaleX)*r}else switch(l){case G.setup:d=Math.abs(i.data.scaleX)*et.signum(o),i.scaleX=d+(o-d)*r;break;case G.first:case G.replace:d=Math.abs(i.scaleX)*et.signum(o),i.scaleX=d+(o-d)*r;break;case G.add:i.scaleX+=(o-i.data.scaleX)*r}}}},Fc=class extends rr{constructor(t,e,s){super(t,e,`${ae.scaleY}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.scaleY=i.data.scaleY;return;case G.first:i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}const o=this.getCurveValue(s)*i.data.scaleY;if(r==1)l==G.add?i.scaleY+=o-i.data.scaleY:i.scaleY=o;else{let d=0;if(h==bn.mixOut)switch(l){case G.setup:d=i.data.scaleY,i.scaleY=d+(Math.abs(o)*et.signum(d)-d)*r;break;case G.first:case G.replace:d=i.scaleY,i.scaleY=d+(Math.abs(o)*et.signum(d)-d)*r;break;case G.add:i.scaleY+=(o-i.data.scaleY)*r}else switch(l){case G.setup:d=Math.abs(i.data.scaleY)*et.signum(o),i.scaleY=d+(o-d)*r;break;case G.first:case G.replace:d=Math.abs(i.scaleY)*et.signum(o),i.scaleY=d+(o-d)*r;break;case G.add:i.scaleY+=(o-i.data.scaleY)*r}}}},Bc=class extends fh{constructor(t,e,s){super(t,e,`${ae.shearX}|${s}`,`${ae.shearY}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case G.first:i.shearX+=(i.data.shearX-i.shearX)*r,i.shearY+=(i.data.shearY-i.shearY)*r}return}let o=0,d=0;const u=Pe.search(a,s,3),m=this.curves[u/3];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+3]-c);o+=(a[u+3+1]-o)*g,d+=(a[u+3+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}switch(l){case G.setup:i.shearX=i.data.shearX+o*r,i.shearY=i.data.shearY+d*r;break;case G.first:case G.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r,i.shearY+=(i.data.shearY+d-i.shearY)*r;break;case G.add:i.shearX+=o*r,i.shearY+=d*r}}},Xc=class extends rr{constructor(t,e,s){super(t,e,`${ae.shearX}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.shearX=i.data.shearX;return;case G.first:i.shearX+=(i.data.shearX-i.shearX)*r}return}const o=this.getCurveValue(s);switch(l){case G.setup:i.shearX=i.data.shearX+o*r;break;case G.first:case G.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r;break;case G.add:i.shearX+=o*r}}},$c=class extends rr{constructor(t,e,s){super(t,e,`${ae.shearY}|${s}`),Xt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.shearY=i.data.shearY;return;case G.first:i.shearY+=(i.data.shearY-i.shearY)*r}return}const o=this.getCurveValue(s);switch(l){case G.setup:i.shearY=i.data.shearY+o*r;break;case G.first:case G.replace:i.shearY+=(i.data.shearY+o-i.shearY)*r;break;case G.add:i.shearY+=o*r}}},Nc=class extends nr{constructor(t,e,s){super(t,e,[`${ae.rgb}|${s}`,`${ae.alpha}|${s}`]),Xt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 5}setFrame(t,e,s,n,r,l){t*=5,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const y=i.data.color;switch(l){case G.setup:o.setFromColor(y);return;case G.first:o.add((y.r-o.r)*r,(y.g-o.g)*r,(y.b-o.b)*r,(y.a-o.a)*r)}return}let d=0,u=0,m=0,c=0;const g=Pe.search(a,s,5),p=this.curves[g/5];switch(p){case 0:const y=a[g];d=a[g+1],u=a[g+2],m=a[g+3],c=a[g+4];const w=(s-y)/(a[g+5]-y);d+=(a[g+5+1]-d)*w,u+=(a[g+5+2]-u)*w,m+=(a[g+5+3]-m)*w,c+=(a[g+5+4]-c)*w;break;case 1:d=a[g+1],u=a[g+2],m=a[g+3],c=a[g+4];break;default:d=this.getBezierValue(s,g,1,p-2),u=this.getBezierValue(s,g,2,p+18-2),m=this.getBezierValue(s,g,3,p+18*2-2),c=this.getBezierValue(s,g,4,p+18*3-2)}r==1?o.set(d,u,m,c):(l==G.setup&&o.setFromColor(i.data.color),o.add((d-o.r)*r,(u-o.g)*r,(m-o.b)*r,(c-o.a)*r))}},Vc=class extends nr{constructor(t,e,s){super(t,e,[`${ae.rgb}|${s}`]),Xt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){t<<=2,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const p=i.data.color;switch(l){case G.setup:o.r=p.r,o.g=p.g,o.b=p.b;return;case G.first:o.r+=(p.r-o.r)*r,o.g+=(p.g-o.g)*r,o.b+=(p.b-o.b)*r}return}let d=0,u=0,m=0;const c=Pe.search(a,s,4),g=this.curves[c>>2];switch(g){case 0:const p=a[c];d=a[c+1],u=a[c+2],m=a[c+3];const y=(s-p)/(a[c+4]-p);d+=(a[c+4+1]-d)*y,u+=(a[c+4+2]-u)*y,m+=(a[c+4+3]-m)*y;break;case 1:d=a[c+1],u=a[c+2],m=a[c+3];break;default:d=this.getBezierValue(s,c,1,g-2),u=this.getBezierValue(s,c,2,g+18-2),m=this.getBezierValue(s,c,3,g+18*2-2)}if(r==1)o.r=d,o.g=u,o.b=m;else{if(l==G.setup){const p=i.data.color;o.r=p.r,o.g=p.g,o.b=p.b}o.r+=(d-o.r)*r,o.g+=(u-o.g)*r,o.b+=(m-o.b)*r}}},_c=class extends rr{constructor(t,e,s){super(t,e,`${ae.alpha}|${s}`),Xt(this,"slotIndex",0),this.slotIndex=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.color;if(s<this.frames[0]){const d=i.data.color;switch(l){case G.setup:a.a=d.a;return;case G.first:a.a+=(d.a-a.a)*r}return}const o=this.getCurveValue(s);r==1?a.a=o:(l==G.setup&&(a.a=i.data.color.a),a.a+=(o-a.a)*r)}},Dc=class extends nr{constructor(t,e,s){super(t,e,[`${ae.rgb}|${s}`,`${ae.alpha}|${s}`,`${ae.rgb2}|${s}`]),Xt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 8}setFrame(t,e,s,n,r,l,h,i,a){t<<=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l,this.frames[t+5]=h,this.frames[t+6]=i,this.frames[t+7]=a}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const S=i.data.color,C=i.data.darkColor;switch(l){case G.setup:o.setFromColor(S),d.r=C.r,d.g=C.g,d.b=C.b;return;case G.first:o.add((S.r-o.r)*r,(S.g-o.g)*r,(S.b-o.b)*r,(S.a-o.a)*r),d.r+=(C.r-d.r)*r,d.g+=(C.g-d.g)*r,d.b+=(C.b-d.b)*r}return}let u=0,m=0,c=0,g=0,p=0,y=0,w=0;const x=Pe.search(a,s,8),b=this.curves[x>>3];switch(b){case 0:const S=a[x];u=a[x+1],m=a[x+2],c=a[x+3],g=a[x+4],p=a[x+5],y=a[x+6],w=a[x+7];const C=(s-S)/(a[x+8]-S);u+=(a[x+8+1]-u)*C,m+=(a[x+8+2]-m)*C,c+=(a[x+8+3]-c)*C,g+=(a[x+8+4]-g)*C,p+=(a[x+8+5]-p)*C,y+=(a[x+8+6]-y)*C,w+=(a[x+8+7]-w)*C;break;case 1:u=a[x+1],m=a[x+2],c=a[x+3],g=a[x+4],p=a[x+5],y=a[x+6],w=a[x+7];break;default:u=this.getBezierValue(s,x,1,b-2),m=this.getBezierValue(s,x,2,b+18-2),c=this.getBezierValue(s,x,3,b+18*2-2),g=this.getBezierValue(s,x,4,b+18*3-2),p=this.getBezierValue(s,x,5,b+18*4-2),y=this.getBezierValue(s,x,6,b+18*5-2),w=this.getBezierValue(s,x,7,b+18*6-2)}if(r==1)o.set(u,m,c,g),d.r=p,d.g=y,d.b=w;else{if(l==G.setup){o.setFromColor(i.data.color);const S=i.data.darkColor;d.r=S.r,d.g=S.g,d.b=S.b}o.add((u-o.r)*r,(m-o.g)*r,(c-o.b)*r,(g-o.a)*r),d.r+=(p-d.r)*r,d.g+=(y-d.g)*r,d.b+=(w-d.b)*r}}},Lc=class extends nr{constructor(t,e,s){super(t,e,[`${ae.rgb}|${s}`,`${ae.rgb2}|${s}`]),Xt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,l,h,i){t*=7,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l,this.frames[t+5]=h,this.frames[t+6]=i}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const b=i.data.color,S=i.data.darkColor;switch(l){case G.setup:o.r=b.r,o.g=b.g,o.b=b.b,d.r=S.r,d.g=S.g,d.b=S.b;return;case G.first:o.r+=(b.r-o.r)*r,o.g+=(b.g-o.g)*r,o.b+=(b.b-o.b)*r,d.r+=(S.r-d.r)*r,d.g+=(S.g-d.g)*r,d.b+=(S.b-d.b)*r}return}let u=0,m=0,c=0,g=0,p=0,y=0;const w=Pe.search(a,s,7),x=this.curves[w/7];switch(x){case 0:const b=a[w];u=a[w+1],m=a[w+2],c=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];const S=(s-b)/(a[w+7]-b);u+=(a[w+7+1]-u)*S,m+=(a[w+7+2]-m)*S,c+=(a[w+7+3]-c)*S,g+=(a[w+7+4]-g)*S,p+=(a[w+7+5]-p)*S,y+=(a[w+7+6]-y)*S;break;case 1:u=a[w+1],m=a[w+2],c=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];break;default:u=this.getBezierValue(s,w,1,x-2),m=this.getBezierValue(s,w,2,x+18-2),c=this.getBezierValue(s,w,3,x+18*2-2),g=this.getBezierValue(s,w,4,x+18*3-2),p=this.getBezierValue(s,w,5,x+18*4-2),y=this.getBezierValue(s,w,6,x+18*5-2)}if(r==1)o.r=u,o.g=m,o.b=c,d.r=g,d.g=p,d.b=y;else{if(l==G.setup){const b=i.data.color,S=i.data.darkColor;o.r=b.r,o.g=b.g,o.b=b.b,d.r=S.r,d.g=S.g,d.b=S.b}o.r+=(u-o.r)*r,o.g+=(m-o.g)*r,o.b+=(c-o.b)*r,d.r+=(g-d.r)*r,d.g+=(p-d.g)*r,d.b+=(y-d.b)*r}}},Da=class extends Pe{constructor(t,e){super(t,[`${ae.attachment}|${e}`]),Xt(this,"slotIndex",0),Xt(this,"attachmentNames"),this.slotIndex=e,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(i.bone.active){if(h==bn.mixOut){l==G.setup&&this.setAttachment(t,i,i.data.attachmentName);return}if(s<this.frames[0]){(l==G.setup||l==G.first)&&this.setAttachment(t,i,i.data.attachmentName);return}this.setAttachment(t,i,this.attachmentNames[Pe.search1(this.frames,s)])}}setAttachment(t,e,s){e.setAttachment(s?t.getAttachment(this.slotIndex,s):null)}},Oc=class extends nr{constructor(t,e,s,n){super(t,e,[`${ae.deform}|${s}|${n.id}`]),Xt(this,"slotIndex",0),Xt(this,"attachment"),Xt(this,"vertices"),this.slotIndex=s,this.attachment=n,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.vertices[t]=s}setBezier(t,e,s,n,r,l,h,i,a,o,d){const u=this.curves;let m=this.getFrameCount()+t*18;s==0&&(u[e]=2+m);const c=(n-l*2+i)*.03,g=a*.03-h*.06,p=((l-i)*3-n+o)*.006,y=(h-a+.33333333)*.018;let w=c*2+p,x=g*2+y,b=(l-n)*.3+c+p*.16666667,S=h*.3+g+y*.16666667,C=n+b,v=S;for(let A=m+18;m<A;m+=2)u[m]=C,u[m+1]=v,b+=w,S+=x,w+=p,x+=y,C+=b,v+=S}getCurvePercent(t,e){const s=this.curves;let n=s[e];switch(n){case 0:const i=this.frames[e];return(t-i)/(this.frames[e+this.getFrameEntries()]-i);case 1:return 0}if(n-=2,s[n]>t){const i=this.frames[e];return s[n+1]*(t-i)/(s[n]-i)}const r=n+18;for(n+=2;n<r;n+=2)if(s[n]>=t){const i=s[n-2],a=s[n-1];return a+(t-i)/(s[n]-i)*(s[n+1]-a)}const l=s[r-2],h=s[r-1];return h+(1-h)*(t-l)/(this.frames[e+this.getFrameEntries()]-l)}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.getAttachment();if(!a||!(a instanceof _r)||a.timelineAttachment!=this.attachment)return;const o=i.deform;o.length==0&&(l=G.setup);const d=this.vertices,u=d[0].length,m=this.frames;if(s<m[0]){switch(l){case G.setup:o.length=0;return;case G.first:if(r==1){o.length=0;return}o.length=u;const w=a;if(w.bones){r=1-r;for(let x=0;x<u;x++)o[x]*=r}else{const x=w.vertices;for(let b=0;b<u;b++)o[b]+=(x[b]-o[b])*r}}return}if(o.length=u,s>=m[m.length-1]){const w=d[m.length-1];if(r==1)if(l==G.add){const x=a;if(x.bones)for(let b=0;b<u;b++)o[b]+=w[b];else{const b=x.vertices;for(let S=0;S<u;S++)o[S]+=w[S]-b[S]}}else mt.arrayCopy(w,0,o,0,u);else switch(l){case G.setup:{const b=a;if(b.bones)for(let S=0;S<u;S++)o[S]=w[S]*r;else{const S=b.vertices;for(let C=0;C<u;C++){const v=S[C];o[C]=v+(w[C]-v)*r}}break}case G.first:case G.replace:for(let b=0;b<u;b++)o[b]+=(w[b]-o[b])*r;break;case G.add:const x=a;if(x.bones)for(let b=0;b<u;b++)o[b]+=w[b]*r;else{const b=x.vertices;for(let S=0;S<u;S++)o[S]+=(w[S]-b[S])*r}}return}const c=Pe.search1(m,s),g=this.getCurvePercent(s,c),p=d[c],y=d[c+1];if(r==1)if(l==G.add){const w=a;if(w.bones)for(let x=0;x<u;x++){const b=p[x];o[x]+=b+(y[x]-b)*g}else{const x=w.vertices;for(let b=0;b<u;b++){const S=p[b];o[b]+=S+(y[b]-S)*g-x[b]}}}else for(let w=0;w<u;w++){const x=p[w];o[w]=x+(y[w]-x)*g}else switch(l){case G.setup:{const x=a;if(x.bones)for(let b=0;b<u;b++){const S=p[b];o[b]=(S+(y[b]-S)*g)*r}else{const b=x.vertices;for(let S=0;S<u;S++){const C=p[S],v=b[S];o[S]=v+(C+(y[S]-C)*g-v)*r}}break}case G.first:case G.replace:for(let x=0;x<u;x++){const b=p[x];o[x]+=(b+(y[x]-b)*g-o[x])*r}break;case G.add:const w=a;if(w.bones)for(let x=0;x<u;x++){const b=p[x];o[x]+=(b+(y[x]-b)*g)*r}else{const x=w.vertices;for(let b=0;b<u;b++){const S=p[b];o[b]+=(S+(y[b]-S)*g-x[b])*r}}}}};const vg=class Nx extends Pe{constructor(t){super(t,Nx.propertyIds),Xt(this,"events"),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,l,h){if(!n)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,l,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=Pe.search1(i,e)+1;const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}};Xt(vg,"propertyIds",[`${ae.event}`]);let mh=vg;const Ag=class Vx extends Pe{constructor(t){super(t,Vx.propertyIds),Xt(this,"drawOrders"),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,l,h){if(h==bn.mixOut){l==G.setup&&mt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(s<this.frames[0]){(l==G.setup||l==G.first)&&mt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const i=Pe.search1(this.frames,s),a=this.drawOrders[i];if(!a)mt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const o=t.drawOrder,d=t.slots;for(let u=0,m=a.length;u<m;u++)o[u]=d[a[u]]}}};Xt(Ag,"propertyIds",[`${ae.drawOrder}`]);let wo=Ag,Wc=class extends nr{constructor(t,e,s){super(t,e,[`${ae.ikConstraint}|${s}`]),Xt(this,"ikConstraintIndex",0),this.ikConstraintIndex=s}getFrameEntries(){return 6}setFrame(t,e,s,n,r,l,h){t*=6,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l?1:0,this.frames[t+5]=h?1:0}apply(t,e,s,n,r,l,h){const i=t.ikConstraints[this.ikConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.mix=i.data.mix,i.softness=i.data.softness,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch;return;case G.first:i.mix+=(i.data.mix-i.mix)*r,i.softness+=(i.data.softness-i.softness)*r,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch}return}let o=0,d=0;const u=Pe.search(a,s,6),m=this.curves[u/6];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+6]-c);o+=(a[u+6+1]-o)*g,d+=(a[u+6+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}l==G.setup?(i.mix=i.data.mix+(o-i.data.mix)*r,i.softness=i.data.softness+(d-i.data.softness)*r,h==bn.mixOut?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=a[u+3],i.compress=a[u+4]!=0,i.stretch=a[u+5]!=0)):(i.mix+=(o-i.mix)*r,i.softness+=(d-i.softness)*r,h==bn.mixIn&&(i.bendDirection=a[u+3],i.compress=a[u+4]!=0,i.stretch=a[u+5]!=0))}},Uc=class extends nr{constructor(t,e,s){super(t,e,[`${ae.transformConstraint}|${s}`]),Xt(this,"transformConstraintIndex",0),this.transformConstraintIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,l,h,i){const a=this.frames;t*=7,a[t]=e,a[t+1]=s,a[t+2]=n,a[t+3]=r,a[t+4]=l,a[t+5]=h,a[t+6]=i}apply(t,e,s,n,r,l,h){const i=t.transformConstraints[this.transformConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){const w=i.data;switch(l){case G.setup:i.mixRotate=w.mixRotate,i.mixX=w.mixX,i.mixY=w.mixY,i.mixScaleX=w.mixScaleX,i.mixScaleY=w.mixScaleY,i.mixShearY=w.mixShearY;return;case G.first:i.mixRotate+=(w.mixRotate-i.mixRotate)*r,i.mixX+=(w.mixX-i.mixX)*r,i.mixY+=(w.mixY-i.mixY)*r,i.mixScaleX+=(w.mixScaleX-i.mixScaleX)*r,i.mixScaleY+=(w.mixScaleY-i.mixScaleY)*r,i.mixShearY+=(w.mixShearY-i.mixShearY)*r}return}let o,d,u,m,c,g;const p=Pe.search(a,s,7),y=this.curves[p/7];switch(y){case 0:const w=a[p];o=a[p+1],d=a[p+2],u=a[p+3],m=a[p+4],c=a[p+5],g=a[p+6];const x=(s-w)/(a[p+7]-w);o+=(a[p+7+1]-o)*x,d+=(a[p+7+2]-d)*x,u+=(a[p+7+3]-u)*x,m+=(a[p+7+4]-m)*x,c+=(a[p+7+5]-c)*x,g+=(a[p+7+6]-g)*x;break;case 1:o=a[p+1],d=a[p+2],u=a[p+3],m=a[p+4],c=a[p+5],g=a[p+6];break;default:o=this.getBezierValue(s,p,1,y-2),d=this.getBezierValue(s,p,2,y+18-2),u=this.getBezierValue(s,p,3,y+18*2-2),m=this.getBezierValue(s,p,4,y+18*3-2),c=this.getBezierValue(s,p,5,y+18*4-2),g=this.getBezierValue(s,p,6,y+18*5-2)}if(l==G.setup){const w=i.data;i.mixRotate=w.mixRotate+(o-w.mixRotate)*r,i.mixX=w.mixX+(d-w.mixX)*r,i.mixY=w.mixY+(u-w.mixY)*r,i.mixScaleX=w.mixScaleX+(m-w.mixScaleX)*r,i.mixScaleY=w.mixScaleY+(c-w.mixScaleY)*r,i.mixShearY=w.mixShearY+(g-w.mixShearY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(u-i.mixY)*r,i.mixScaleX+=(m-i.mixScaleX)*r,i.mixScaleY+=(c-i.mixScaleY)*r,i.mixShearY+=(g-i.mixShearY)*r}},qc=class extends rr{constructor(t,e,s){super(t,e,`${ae.pathConstraintPosition}|${s}`),Xt(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,l,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.position=i.data.position;return;case G.first:i.position+=(i.data.position-i.position)*r}return}const o=this.getCurveValue(s);l==G.setup?i.position=i.data.position+(o-i.data.position)*r:i.position+=(o-i.position)*r}},zc=class extends rr{constructor(t,e,s){super(t,e,`${ae.pathConstraintSpacing}|${s}`),Xt(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,l,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.spacing=i.data.spacing;return;case G.first:i.spacing+=(i.data.spacing-i.spacing)*r}return}const o=this.getCurveValue(s);l==G.setup?i.spacing=i.data.spacing+(o-i.data.spacing)*r:i.spacing+=(o-i.spacing)*r}},Gc=class extends nr{constructor(t,e,s){super(t,e,[`${ae.pathConstraintMix}|${s}`]),Xt(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){const l=this.frames;t<<=2,l[t]=e,l[t+1]=s,l[t+2]=n,l[t+3]=r}apply(t,e,s,n,r,l,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case G.setup:i.mixRotate=i.data.mixRotate,i.mixX=i.data.mixX,i.mixY=i.data.mixY;return;case G.first:i.mixRotate+=(i.data.mixRotate-i.mixRotate)*r,i.mixX+=(i.data.mixX-i.mixX)*r,i.mixY+=(i.data.mixY-i.mixY)*r}return}let o,d,u;const m=Pe.search(a,s,4),c=this.curves[m>>2];switch(c){case 0:const g=a[m];o=a[m+1],d=a[m+2],u=a[m+3];const p=(s-g)/(a[m+4]-g);o+=(a[m+4+1]-o)*p,d+=(a[m+4+2]-d)*p,u+=(a[m+4+3]-u)*p;break;case 1:o=a[m+1],d=a[m+2],u=a[m+3];break;default:o=this.getBezierValue(s,m,1,c-2),d=this.getBezierValue(s,m,2,c+18-2),u=this.getBezierValue(s,m,3,c+18*2-2)}if(l==G.setup){const g=i.data;i.mixRotate=g.mixRotate+(o-g.mixRotate)*r,i.mixX=g.mixX+(d-g.mixX)*r,i.mixY=g.mixY+(u-g.mixY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(u-i.mixY)*r}};const gh=class ma extends Pe{constructor(t,e,s){super(t,[`${ae.sequence}|${e}|${s.sequence.id}`]),Xt(this,"slotIndex"),Xt(this,"attachment"),this.slotIndex=e,this.attachment=s}getFrameEntries(){return ma.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(t,e,s,n,r){const l=this.frames;t*=ma.ENTRIES,l[t]=e,l[t+ma.MODE]=s|n<<4,l[t+ma.DELAY]=r}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.attachment,o=this.attachment;if(a!=o&&(!(a instanceof _r)||a.timelineAttachment!=o))return;const d=this.frames;if(s<d[0]){(l==G.setup||l==G.first)&&(i.sequenceIndex=-1);return}const u=Pe.search(d,s,ma.ENTRIES),m=d[u],c=d[u+ma.MODE],g=d[u+ma.DELAY];if(!this.attachment.sequence)return;let p=c>>4;const y=this.attachment.sequence.regions.length,w=Ec[c&15];if(w!=Dr.hold)switch(p+=(s-m)/g+1e-5|0,w){case Dr.once:p=Math.min(y-1,p);break;case Dr.loop:p%=y;break;case Dr.pingpong:{const x=(y<<1)-2;p=x==0?0:p%x,p>=y&&(p=x-p);break}case Dr.onceReverse:p=Math.max(y-1-p,0);break;case Dr.loopReverse:p=y-1-p%y;break;case Dr.pingpongReverse:{const x=(y<<1)-2;p=x==0?0:(p+y-1)%x,p>=y&&(p=x-p)}}i.sequenceIndex=p}};Xt(gh,"ENTRIES",3),Xt(gh,"MODE",1),Xt(gh,"DELAY",2);let Hc=gh;var tS=Object.defineProperty,eS=(f,t,e)=>t in f?tS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,gt=(f,t,e)=>eS(f,typeof t!="symbol"?t+"":t,e);const pl=class Qr{constructor(t){gt(this,"data"),gt(this,"tracks",new Array),gt(this,"timeScale",1),gt(this,"unkeyedState",0),gt(this,"events",new Array),gt(this,"listeners",new Array),gt(this,"queue",new Eg(this)),gt(this,"propertyIDs",new fg),gt(this,"animationsChanged",!1),gt(this,"trackEntryPool",new gg(()=>new Tg)),gt(this,"onComplete"),gt(this,"onEvent"),gt(this,"onStart"),gt(this,"onEnd"),this.data=t}static emptyAnimation(){return Qr._emptyAnimation}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let l=t*r.timeScale;if(r.delay>0){if(r.delay-=l,r.delay>0)continue;l=-r.delay,r.delay=0}let h=r.next;if(h){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=l,this.setCurrent(s,h,!0);h.mixingFrom;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){e[s]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i&&(i.mixingTo=null);i;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=l}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(!s)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let h=0,i=s.length;h<i;h++){const a=s[h];if(!a||a.delay>0)continue;n=!0;const o=h==0?G.first:a.mixBlend;let d=a.alpha;a.mixingFrom?d*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&!a.next&&(d=0);const u=a.animationLast,m=a.getAnimationTime();let c=m,g=e;a.reverse&&(c=a.animation.duration-c,g=null);const p=a.animation.timelines,y=p.length;if(h==0&&d==1||o==G.add)for(let w=0;w<y;w++){mt.webkit602BugfixHelper(d,o);const x=p[w];x instanceof Da?this.applyAttachmentTimeline(x,t,c,o,!0):x.apply(t,u,c,g,d,o,bn.mixIn)}else{const w=a.timelineMode,x=a.shortestRotation,b=!x&&a.timelinesRotation.length!=y<<1;b&&(a.timelinesRotation.length=y<<1);for(let S=0;S<y;S++){const C=p[S],v=w[S]==Zc?o:G.setup;!x&&C instanceof gl?this.applyRotateTimeline(C,t,c,d,v,a.timelinesRotation,S<<1,b):C instanceof Da?this.applyAttachmentTimeline(C,t,c,o,!0):(mt.webkit602BugfixHelper(d,o),C.apply(t,u,c,g,d,v,bn.mixIn))}}this.queueEvents(a,m),e.length=0,a.nextAnimationLast=m,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+Rg,l=t.slots;for(let h=0,i=t.slots.length;h<i;h++){const a=l[h];if(a.attachmentState==r){const o=a.data.attachmentName;a.setAttachment(o?t.getAttachment(a.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==G.first&&(s=G.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=G.first&&(s=n.mixBlend));const l=r<n.attachmentThreshold,h=r<n.drawOrderThreshold,i=n.animation.timelines,a=i.length,o=n.alpha*t.interruptAlpha,d=o*(1-r),u=n.animationLast,m=n.getAnimationTime();let c=m,g=null;if(n.reverse?c=n.animation.duration-c:r<n.eventThreshold&&(g=this.events),s==G.add)for(let p=0;p<a;p++)i[p].apply(e,u,c,g,d,s,bn.mixOut);else{const p=n.timelineMode,y=n.timelineHoldMix,w=n.shortestRotation,x=!w&&n.timelinesRotation.length!=a<<1;x&&(n.timelinesRotation.length=a<<1),n.totalAlpha=0;for(let b=0;b<a;b++){const S=i[b];let C=bn.mixOut,v,A=0;switch(p[b]){case Zc:if(!h&&S instanceof wo)continue;v=s,A=d;break;case kg:v=G.setup,A=d;break;case Pg:v=s,A=o;break;case Jc:v=G.setup,A=o;break;default:v=G.setup;const M=y[b];A=o*Math.max(0,1-M.mixTime/M.mixDuration);break}n.totalAlpha+=A,!w&&S instanceof gl?this.applyRotateTimeline(S,e,c,A,v,n.timelinesRotation,b<<1,x):S instanceof Da?this.applyAttachmentTimeline(S,e,c,v,l):(mt.webkit602BugfixHelper(A,s),h&&S instanceof wo&&v==G.setup&&(C=bn.mixIn),S.apply(e,u,c,g,A,v,C))}}return t.mixDuration>0&&this.queueEvents(n,m),this.events.length=0,n.nextAnimationLast=m,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(t,e,s,n,r){const l=e.slots[t.slotIndex];l.bone.active&&(s<t.frames[0]?(n==G.setup||n==G.first)&&this.setAttachment(e,l,l.data.attachmentName,r):this.setAttachment(e,l,t.attachmentNames[Pe.search1(t.frames,s)],r),l.attachmentState<=this.unkeyedState&&(l.attachmentState=this.unkeyedState+Rg))}setAttachment(t,e,s,n){e.setAttachment(s?t.getAttachment(e.data.index,s):null),n&&(e.attachmentState=this.unkeyedState+rS)}applyRotateTimeline(t,e,s,n,r,l,h,i){if(i&&(l[h]=0),n==1){t.apply(e,0,s,null,1,r,bn.mixIn);return}const a=e.bones[t.boneIndex];if(!a.active)return;const o=t.frames;let d=0,u=0;if(s<o[0])switch(r){case G.setup:a.rotation=a.data.rotation;default:return;case G.first:d=a.rotation,u=a.data.rotation}else d=r==G.setup?a.data.rotation:a.rotation,u=a.data.rotation+t.getCurveValue(s);let m=0,c=u-d;if(c-=(16384-(16384.499999999996-c/360|0))*360,c==0)m=l[h];else{let g=0,p=0;i?(g=0,p=c):(g=l[h],p=l[h+1]);const y=c>0;let w=g>=0;et.signum(p)!=et.signum(c)&&Math.abs(p)<=90&&(Math.abs(g)>180&&(g+=360*et.signum(g)),w=y),m=c+g-g%360,w!=y&&(m+=360*et.signum(g)),l[h]=m}l[h+1]=c,a.rotation=d+m*n}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,l=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<l)break;d.time>n||this.queue.event(t,d)}let o=!1;for(t.loop?o=r==0||l>t.trackTime%r:o=e>=n&&t.animationLast<n,o&&this.queue.complete(t);i<a;i++){const d=h[i];d.time<s||this.queue.event(t,d)}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let s=e;for(;;){const n=s.mixingFrom;if(!n)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,n&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s=!1){const n=this.data.skeletonData.findAnimation(e);if(!n)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s=!1){if(!e)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,n=!1):this.clearNext(r));const l=this.trackEntry(t,e,s,r);return this.setCurrent(t,l,n),this.queue.drain(),l}addAnimation(t,e,s=!1,n=0){const r=this.data.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s=!1,n=0){if(!e)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r)for(;r.next;)r=r.next;const l=this.trackEntry(t,e,s,r);return r?(r.next=l,l.previous=r,n<=0&&(n+=r.getTrackComplete()-l.mixDuration)):(this.setCurrent(t,l,!0),this.queue.drain()),l.delay=n,l}setEmptyAnimation(t,e=0){const s=this.setAnimationWith(t,Qr.emptyAnimation(),!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e=0,s=0){const n=this.addAnimationWith(t,Qr.emptyAnimation(),!1,s);return s<=0&&(n.delay+=n.mixDuration-e),n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t=0){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(mt.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.reverse=!1,r.shortestRotation=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.mixTime=0,r.mixDuration=n?this.data.getMix(n.animation,e):0,r.interruptAlpha=1,r.totalAlpha=0,r.mixBlend=G.replace,r}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const t=this.tracks;for(let e=0,s=t.length;e<s;e++){let n=t[e];if(n){for(;n.mixingFrom;)n=n.mixingFrom;do(!n.mixingTo||n.mixBlend!=G.add)&&this.computeHold(n),n=n.mixingTo;while(n)}}}computeHold(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=t.timelineMode;r.length=n;const l=t.timelineHoldMix;l.length=0;const h=this.propertyIDs;if(e&&e.holdPrevious){for(let i=0;i<n;i++)r[i]=h.addAll(s[i].getPropertyIds())?Jc:Pg;return}t:for(let i=0;i<n;i++){const a=s[i],o=a.getPropertyIds();if(!h.addAll(o))r[i]=Zc;else if(!e||a instanceof Da||a instanceof wo||a instanceof mh||!e.animation.hasTimeline(o))r[i]=kg;else{for(let d=e.mixingTo;d;d=d.mixingTo)if(!d.animation.hasTimeline(o)){if(t.mixDuration>0){r[i]=nS,l[i]=d;continue t}break}r[i]=Jc}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){Qr.deprecatedWarning1||(Qr.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){Qr.deprecatedWarning2||(Qr.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return Qr.deprecatedWarning3||(Qr.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};gt(pl,"_emptyAnimation",new uh("<empty>",[],0)),gt(pl,"deprecatedWarning1",!1),gt(pl,"deprecatedWarning2",!1),gt(pl,"deprecatedWarning3",!1);let Mg=pl;const Kc=class Ii{constructor(){gt(this,"animation",null),gt(this,"previous",null),gt(this,"next",null),gt(this,"mixingFrom",null),gt(this,"mixingTo",null),gt(this,"listener",null),gt(this,"trackIndex",0),gt(this,"loop",!1),gt(this,"holdPrevious",!1),gt(this,"reverse",!1),gt(this,"shortestRotation",!1),gt(this,"eventThreshold",0),gt(this,"attachmentThreshold",0),gt(this,"drawOrderThreshold",0),gt(this,"animationStart",0),gt(this,"animationEnd",0),gt(this,"animationLast",0),gt(this,"nextAnimationLast",0),gt(this,"delay",0),gt(this,"trackTime",0),gt(this,"trackLast",0),gt(this,"nextTrackLast",0),gt(this,"trackEnd",0),gt(this,"timeScale",0),gt(this,"alpha",0),gt(this,"mixTime",0),gt(this,"mixDuration",0),gt(this,"interruptAlpha",0),gt(this,"totalAlpha",0),gt(this,"mixBlend",G.replace),gt(this,"timelineMode",new Array),gt(this,"timelineHoldMix",new Array),gt(this,"timelinesRotation",new Array),gt(this,"onComplete"),gt(this,"onEvent"),gt(this,"onStart"),gt(this,"onEnd")}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return Ii.deprecatedWarning1||(Ii.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Ii.deprecatedWarning1||(Ii.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Ii.deprecatedWarning2||(Ii.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Ii.deprecatedWarning2||(Ii.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};gt(Kc,"deprecatedWarning1",!1),gt(Kc,"deprecatedWarning2",!1);let Tg=Kc,Eg=class{constructor(t){gt(this,"objects",[]),gt(this,"drainDisabled",!1),gt(this,"animState"),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener&&r.listener.start&&r.listener.start(r);for(let h=0;h<e.length;h++){const i=e[h];i.start&&i.start(r)}break;case 1:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let h=0;h<e.length;h++){const i=e[h];i.interrupt&&i.interrupt(r)}break;case 2:r.listener&&r.listener.end&&r.listener.end(r);for(let h=0;h<e.length;h++){const i=e[h];i.end&&i.end(r)}case 3:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let h=0;h<e.length;h++){const i=e[h];i.dispose&&i.dispose(r)}this.animState.trackEntryPool.free(r);break;case 4:r.listener&&r.listener.complete&&r.listener.complete(r);for(let h=0;h<e.length;h++){const i=e[h];i.complete&&i.complete(r)}break;case 5:const l=t[s+++2];r.listener&&r.listener.event&&r.listener.event(r,l);for(let h=0;h<e.length;h++){const i=e[h];i.event&&i.event(r,l)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};var Ig=(f=>(f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event",f))(Ig||{});let sS=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}};const Zc=0,kg=1,Pg=2,Jc=3,nS=4,Rg=1,rS=2;var iS=Object.defineProperty,aS=(f,t,e)=>t in f?iS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Yg=(f,t,e)=>aS(f,typeof t!="symbol"?t+"":t,e);let Fg=class _x extends _r{constructor(t){super(t),Yg(this,"type",$e.BoundingBox),Yg(this,"color",new Dt(1,1,1,1))}copy(){const t=new _x(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}};var oS=Object.defineProperty,lS=(f,t,e)=>t in f?oS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Qc=(f,t,e)=>lS(f,typeof t!="symbol"?t+"":t,e);let Bg=class Dx extends _r{constructor(t){super(t),Qc(this,"type",$e.Clipping),Qc(this,"endSlot",null),Qc(this,"color",new Dt(.2275,.2275,.8078,1))}copy(){const t=new Dx(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}};var hS=Object.defineProperty,cS=(f,t,e)=>t in f?hS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Fn=(f,t,e)=>cS(f,typeof t!="symbol"?t+"":t,e);let ph=class Ff extends _r{constructor(t,e){super(t),Fn(this,"type",$e.Mesh),Fn(this,"region",null),Fn(this,"path"),Fn(this,"regionUVs"),Fn(this,"triangles",[]),Fn(this,"color",new Dt(1,1,1,1)),Fn(this,"width",0),Fn(this,"height",0),Fn(this,"hullLength",0),Fn(this,"edges",[]),Fn(this,"parentMesh",null),Fn(this,"sequence",null),Fn(this,"tempColor",new Dt(0,0,0,0)),this.path=e}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new Ff(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),mt.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),mt.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),mt.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,e,s,n,r,l){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,e,s,n,r,l)}newLinkedMesh(){const t=new Ff(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}};var dS=Object.defineProperty,uS=(f,t,e)=>t in f?dS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,xl=(f,t,e)=>uS(f,typeof t!="symbol"?t+"":t,e);let bl=class Lx extends _r{constructor(t){super(t),xl(this,"type",$e.Path),xl(this,"lengths",[]),xl(this,"closed",!1),xl(this,"constantSpeed",!1),xl(this,"color",new Dt(1,1,1,1))}copy(){const t=new Lx(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),mt.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}};var fS=Object.defineProperty,mS=(f,t,e)=>t in f?fS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,wl=(f,t,e)=>mS(f,typeof t!="symbol"?t+"":t,e);let Xg=class Ox extends _r{constructor(t){super(t),wl(this,"type",$e.Point),wl(this,"x",0),wl(this,"y",0),wl(this,"rotation",0),wl(this,"color",new Dt(.38,.94,0,1))}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=et.cosDeg(this.rotation),n=et.sinDeg(this.rotation),r=s*e.a+n*e.c,l=s*e.b+n*e.d;return Math.atan2(l,r)*et.radDeg}copy(){const t=new Ox(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}};var gS=Object.defineProperty,pS=(f,t,e)=>t in f?gS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,xS=(f,t,e)=>pS(f,typeof t!="symbol"?t+"":t,e);let jc=class{constructor(t){xS(this,"atlas"),this.atlas=t}loadSequence(t,e,s){const n=s.regions;for(let r=0,l=n.length;r<l;r++){const h=s.getPath(e,r),i=this.atlas.findRegion(h);if(i==null)throw new Error(`Region not found in atlas: ${h} (sequence: ${t})`);n[r]=i,n[r].renderObject=n[r]}}newRegionAttachment(t,e,s,n){const r=new Mc(e,s);if(n!=null)this.loadSequence(e,s,n);else{const l=this.atlas.findRegion(s);if(!l)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);l.renderObject=l,r.region=l}return r}newMeshAttachment(t,e,s,n){const r=new ph(e,s);if(n!=null)this.loadSequence(e,s,n);else{const l=this.atlas.findRegion(s);if(!l)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);l.renderObject=l,r.region=l}return r}newBoundingBoxAttachment(t,e){return new Fg(e)}newPathAttachment(t,e){return new bl(e)}newPointAttachment(t,e){return new Xg(e)}newClippingAttachment(t,e){return new Bg(e)}};var ii=(f=>(f[f.Fixed=0]="Fixed",f[f.Percent=1]="Percent",f))(ii||{}),yo=(f=>(f[f.Tangent=0]="Tangent",f[f.Chain=1]="Chain",f[f.ChainScale=2]="ChainScale",f))(yo||{});let xh=class{constructor(t,e,s){this.name=t,this.order=e,this.skinRequired=s}};var bS=Object.defineProperty,wS=(f,t,e)=>t in f?bS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ir=(f,t,e)=>wS(f,typeof t!="symbol"?t+"":t,e);let td=class extends xh{constructor(t){super(t,0,!1),ir(this,"bones",new Array),ir(this,"_target",null),ir(this,"positionMode",ii.Fixed),ir(this,"spacingMode",1),ir(this,"rotateMode",yo.Chain),ir(this,"offsetRotation",0),ir(this,"position",0),ir(this,"spacing",0),ir(this,"mixRotate",0),ir(this,"mixX",0),ir(this,"mixY",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}};var fs=(f=>(f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f[f.Proportional=3]="Proportional",f))(fs||{}),yS=Object.defineProperty,SS=(f,t,e)=>t in f?yS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ns=(f,t,e)=>SS(f,typeof t!="symbol"?t+"":t,e);const yl=class ki{constructor(t,e){if(ns(this,"data"),ns(this,"bones"),ns(this,"target"),ns(this,"position",0),ns(this,"spacing",0),ns(this,"mixRotate",0),ns(this,"mixX",0),ns(this,"mixY",0),ns(this,"spaces",new Array),ns(this,"positions",new Array),ns(this,"world",new Array),ns(this,"curves",new Array),ns(this,"lengths",new Array),ns(this,"segments",new Array),ns(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,r=t.bones.length;n<r;n++){const l=e.findBone(t.bones[n].name);if(!l)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(l)}const s=e.findSlot(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}`);this.target=s,this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}update(){const t=this.target.getAttachment();if(!(t instanceof bl))return;const e=this.mixRotate,s=this.mixX,n=this.mixY;if(e==0&&s==0&&n==0)return;const r=this.data,l=r.rotateMode==yo.Tangent,h=r.rotateMode==yo.ChainScale,i=this.bones,a=i.length,o=l?a:a+1,d=mt.setArraySize(this.spaces,o),u=h?this.lengths=mt.setArraySize(this.lengths,a):[],m=this.spacing;switch(r.spacingMode){case fs.Percent:if(h)for(let S=0,C=o-1;S<C;S++){const v=i[S],A=v.data.length;if(A<ki.epsilon)u[S]=0;else{const M=A*v.matrix.a,I=A*v.matrix.b;u[S]=Math.sqrt(M*M+I*I)}}mt.arrayFill(d,1,o,m);break;case fs.Proportional:let x=0;for(let S=0,C=o-1;S<C;){const v=i[S],A=v.data.length;if(A<ki.epsilon)h&&(u[S]=0),d[++S]=m;else{const M=A*v.matrix.a,I=A*v.matrix.b,E=Math.sqrt(M*M+I*I);h&&(u[S]=E),d[++S]=E,x+=E}}if(x>0){x=o/x*m;for(let S=1;S<o;S++)d[S]*=x}break;default:const b=r.spacingMode==fs.Length;for(let S=0,C=o-1;S<C;){const v=i[S],A=v.data.length;if(A<ki.epsilon)h&&(u[S]=0),d[++S]=m;else{const M=A*v.matrix.a,I=A*v.matrix.b,E=Math.sqrt(M*M+I*I);h&&(u[S]=E),d[++S]=(b?A+m:m)*E/A}}}const c=this.computeWorldPositions(t,o,l);let g=c[0],p=c[1],y=r.offsetRotation,w=!1;if(y==0)w=r.rotateMode==yo.Chain;else{w=!1;const x=this.target.bone.matrix;y*=x.a*x.d-x.b*x.c>0?et.degRad:-et.degRad}for(let x=0,b=3;x<a;x++,b+=3){const S=i[x],C=S.matrix;C.tx+=(g-C.tx)*s,C.ty+=(p-C.ty)*n;const v=c[b],A=c[b+1],M=v-g,I=A-p;if(h){const E=u[x];if(E!=0){const P=(Math.sqrt(M*M+I*I)/E-1)*e+1;C.a*=P,C.b*=P}}if(g=v,p=A,e>0){const E=C.a,P=C.c,R=C.b,k=C.d;let Y=0,F=0,X=0;if(l?Y=c[b-1]:d[x+1]==0?Y=c[b+2]:Y=Math.atan2(I,M),Y-=Math.atan2(R,E),w){F=Math.cos(Y),X=Math.sin(Y);const W=S.data.length;g+=(W*(F*E-X*R)-M)*e,p+=(W*(X*E+F*R)-I)*e}else Y+=y;Y>et.PI?Y-=et.PI2:Y<-et.PI&&(Y+=et.PI2),Y*=e,F=Math.cos(Y),X=Math.sin(Y),C.a=F*E-X*R,C.c=F*P-X*k,C.b=X*E+F*R,C.d=X*P+F*k}S.updateAppliedTransform()}}computeWorldPositions(t,e,s){const n=this.target;let r=this.position;const l=this.spaces,h=mt.setArraySize(this.positions,e*3+2);let i=this.world;const a=t.closed;let o=t.worldVerticesLength,d=o/6,u=ki.NONE;if(!t.constantSpeed){const W=t.lengths;d-=a?1:2;const B=W[d];this.data.positionMode==ii.Percent&&(r*=B);let N;switch(this.data.spacingMode){case fs.Percent:N=B;break;case fs.Proportional:N=B/e;break;default:N=1}i=mt.setArraySize(this.world,8);for(let O=0,Z=0,$=0;O<e;O++,Z+=3){const D=l[O]*N;r+=D;let _=r;if(a)_%=B,_<0&&(_+=B),$=0;else if(_<0){u!=ki.BEFORE&&(u=ki.BEFORE,t.computeWorldVertices(n,2,4,i,0,2)),this.addBeforePosition(_,i,0,h,Z);continue}else if(_>B){u!=ki.AFTER&&(u=ki.AFTER,t.computeWorldVertices(n,o-6,4,i,0,2)),this.addAfterPosition(_-B,i,0,h,Z);continue}for(;;$++){const lt=W[$];if(!(_>lt)){if($==0)_/=lt;else{const wt=W[$-1];_=(_-wt)/(lt-wt)}break}}$!=u&&(u=$,a&&$==d?(t.computeWorldVertices(n,o-4,4,i,0,2),t.computeWorldVertices(n,0,4,i,4,2)):t.computeWorldVertices(n,$*6+2,8,i,0,2)),this.addCurvePosition(_,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],h,Z,s||O>0&&D==0)}return h}a?(o+=2,i=mt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o-4,i,0,2),t.computeWorldVertices(n,0,2,i,o-4,2),i[o-2]=i[0],i[o-1]=i[1]):(d--,o-=4,i=mt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o,i,0,2));const m=mt.setArraySize(this.curves,d);let c=0,g=i[0],p=i[1],y=0,w=0,x=0,b=0,S=0,C=0,v=0,A=0,M=0,I=0,E=0,P=0,R=0,k=0;for(let W=0,B=2;W<d;W++,B+=6)y=i[B],w=i[B+1],x=i[B+2],b=i[B+3],S=i[B+4],C=i[B+5],v=(g-y*2+x)*.1875,A=(p-w*2+b)*.1875,M=((y-x)*3-g+S)*.09375,I=((w-b)*3-p+C)*.09375,E=v*2+M,P=A*2+I,R=(y-g)*.75+v+M*.16666667,k=(w-p)*.75+A+I*.16666667,c+=Math.sqrt(R*R+k*k),R+=E,k+=P,E+=M,P+=I,c+=Math.sqrt(R*R+k*k),R+=E,k+=P,c+=Math.sqrt(R*R+k*k),R+=E+M,k+=P+I,c+=Math.sqrt(R*R+k*k),m[W]=c,g=S,p=C;this.data.positionMode==ii.Percent&&(r*=c);let Y;switch(this.data.spacingMode){case fs.Percent:Y=c;break;case fs.Proportional:Y=c/e;break;default:Y=1}const F=this.segments;let X=0;for(let W=0,B=0,N=0,O=0;W<e;W++,B+=3){const Z=l[W]*Y;r+=Z;let $=r;if(a)$%=c,$<0&&($+=c),N=0;else if($<0){this.addBeforePosition($,i,0,h,B);continue}else if($>c){this.addAfterPosition($-c,i,o-4,h,B);continue}for(;;N++){const D=m[N];if(!($>D)){if(N==0)$/=D;else{const _=m[N-1];$=($-_)/(D-_)}break}}if(N!=u){u=N;let D=N*6;for(g=i[D],p=i[D+1],y=i[D+2],w=i[D+3],x=i[D+4],b=i[D+5],S=i[D+6],C=i[D+7],v=(g-y*2+x)*.03,A=(p-w*2+b)*.03,M=((y-x)*3-g+S)*.006,I=((w-b)*3-p+C)*.006,E=v*2+M,P=A*2+I,R=(y-g)*.3+v+M*.16666667,k=(w-p)*.3+A+I*.16666667,X=Math.sqrt(R*R+k*k),F[0]=X,D=1;D<8;D++)R+=E,k+=P,E+=M,P+=I,X+=Math.sqrt(R*R+k*k),F[D]=X;R+=E,k+=P,X+=Math.sqrt(R*R+k*k),F[8]=X,R+=E+M,k+=P+I,X+=Math.sqrt(R*R+k*k),F[9]=X,O=0}for($*=X;;O++){const D=F[O];if(!($>D)){if(O==0)$/=D;else{const _=F[O-1];$=O+($-_)/(D-_)}break}}this.addCurvePosition($*.1,g,p,y,w,x,b,S,C,h,B,s||W>0&&Z==0)}return h}addBeforePosition(t,e,s,n,r){const l=e[s],h=e[s+1],i=e[s+2]-l,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){const l=e[s+2],h=e[s+3],i=l-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,l,h,i,a,o,d,u){if(t==0||isNaN(t)){o[d]=e,o[d+1]=s,o[d+2]=Math.atan2(r-s,n-e);return}const m=t*t,c=m*t,g=1-t,p=g*g,y=p*g,w=g*t,x=w*3,b=g*x,S=x*t,C=e*y+n*b+l*S+i*c,v=s*y+r*b+h*S+a*c;o[d]=C,o[d+1]=v,u&&(t<.001?o[d+2]=Math.atan2(r-s,n-e):o[d+2]=Math.atan2(v-(s*p+r*w*2+h*m),C-(e*p+n*w*2+l*m)))}};ns(yl,"NONE",-1),ns(yl,"BEFORE",-2),ns(yl,"AFTER",-3),ns(yl,"epsilon",1e-5);let $g=yl;var CS=Object.defineProperty,vS=(f,t,e)=>t in f?CS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ne=(f,t,e)=>vS(f,typeof t!="symbol"?t+"":t,e);let ed=class{constructor(t,e,s){if(Ne(this,"matrix",new V.Matrix),Ne(this,"data"),Ne(this,"skeleton"),Ne(this,"parent",null),Ne(this,"children",new Array),Ne(this,"x",0),Ne(this,"y",0),Ne(this,"rotation",0),Ne(this,"scaleX",0),Ne(this,"scaleY",0),Ne(this,"shearX",0),Ne(this,"shearY",0),Ne(this,"ax",0),Ne(this,"ay",0),Ne(this,"arotation",0),Ne(this,"ascaleX",0),Ne(this,"ascaleY",0),Ne(this,"ashearX",0),Ne(this,"ashearY",0),Ne(this,"sorted",!1),Ne(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,l,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=l,this.ashearY=h;const i=this.parent,a=this.matrix,o=this.skeleton.scaleX,d=-this.skeleton.scaleY;if(!i){const p=this.skeleton,y=s+90+h;a.a=et.cosDeg(s+l)*n*o,a.c=et.cosDeg(y)*r*o,a.b=et.sinDeg(s+l)*n*d,a.d=et.sinDeg(y)*r*d,a.tx=t*o+p.x,a.ty=e*d+p.y;return}let u=i.matrix.a,m=i.matrix.c,c=i.matrix.b,g=i.matrix.d;switch(a.tx=u*t+m*e+i.matrix.tx,a.ty=c*t+g*e+i.matrix.ty,this.data.transformMode){case Yn.Normal:{const p=s+90+h,y=et.cosDeg(s+l)*n,w=et.cosDeg(p)*r,x=et.sinDeg(s+l)*n,b=et.sinDeg(p)*r;a.a=u*y+m*x,a.c=u*w+m*b,a.b=c*y+g*x,a.d=c*w+g*b;return}case Yn.OnlyTranslation:{const p=s+90+h;a.a=et.cosDeg(s+l)*n,a.c=et.cosDeg(p)*r,a.b=et.sinDeg(s+l)*n,a.d=et.sinDeg(p)*r;break}case Yn.NoRotationOrReflection:{let p=u*u+c*c,y=0;p>1e-4?(p=Math.abs(u*g-m*c)/p,u/=o,c/=d,m=c*p,g=u*p,y=Math.atan2(c,u)*et.radDeg):(u=0,c=0,y=90-Math.atan2(g,m)*et.radDeg);const w=s+l-y,x=s+h-y+90,b=et.cosDeg(w)*n,S=et.cosDeg(x)*r,C=et.sinDeg(w)*n,v=et.sinDeg(x)*r;a.a=u*b-m*C,a.c=u*S-m*v,a.b=c*b+g*C,a.d=c*S+g*v;break}case Yn.NoScale:case Yn.NoScaleOrReflection:{const p=et.cosDeg(s),y=et.sinDeg(s);let w=(u*p+m*y)/o,x=(c*p+g*y)/d,b=Math.sqrt(w*w+x*x);b>1e-5&&(b=1/b),w*=b,x*=b,b=Math.sqrt(w*w+x*x),this.data.transformMode==Yn.NoScale&&u*g-m*c<0!=(o<0!=d<0)&&(b=-b);const S=Math.PI/2+Math.atan2(x,w),C=Math.cos(S)*b,v=Math.sin(S)*b,A=et.cosDeg(l)*n,M=et.cosDeg(90+h)*r,I=et.sinDeg(l)*n,E=et.sinDeg(90+h)*r;a.a=w*A+C*I,a.c=w*M+C*E,a.b=x*A+v*I,a.d=x*M+v*E;break}}a.a*=o,a.c*=o,a.b*=d,a.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*et.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*et.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,e=this.matrix;if(!t){this.ax=e.tx-this.skeleton.x,this.ay=e.ty-this.skeleton.y,this.arotation=Math.atan2(e.b,e.a)*et.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*et.radDeg;return}const s=t.matrix,n=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,l=e.ty-s.ty;this.ax=r*s.d*n-l*s.c*n,this.ay=l*s.a*n-r*s.b*n;const h=n*s.d,i=n*s.a,a=n*s.c,o=n*s.b,d=h*e.a-a*e.b,u=h*e.c-a*e.d,m=i*e.b-o*e.a,c=i*e.d-o*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*c-u*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*u+m*c,g)*et.radDeg,this.arotation=Math.atan2(m,d)*et.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+c*c),this.ashearY=0,this.arotation=90-Math.atan2(c,u)*et.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=1/(s*l-n*r),i=t.x-e.tx,a=t.y-e.ty;return t.x=i*l*h-a*n*h,t.y=a*s*h-i*r*h,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=et.sinDeg(t),s=et.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*s,n.d*s-n.c*e)*et.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const e=et.sinDeg(t),s=et.cosDeg(t),n=this.matrix;return Math.atan2(s*n.b+e*n.d,s*n.a+e*n.c)*et.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=et.cosDeg(t),i=et.sinDeg(t);e.a=h*s-i*r,e.c=h*n-i*l,e.b=i*s+h*r,e.d=i*n+h*l}};var AS=Object.defineProperty,MS=(f,t,e)=>t in f?AS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ai=(f,t,e)=>MS(f,typeof t!="symbol"?t+"":t,e);let Ng=class{constructor(t,e){if(ai(this,"blendMode"),ai(this,"data"),ai(this,"bone"),ai(this,"color"),ai(this,"darkColor",null),ai(this,"attachment",null),ai(this,"attachmentState",0),ai(this,"sequenceIndex",-1),ai(this,"deform",new Array),!t)throw new Error("data cannot be null.");if(!e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new Dt,this.darkColor=t.darkColor?new Dt:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof _r)||!(this.attachment instanceof _r)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}};var TS=Object.defineProperty,ES=(f,t,e)=>t in f?TS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,oi=(f,t,e)=>ES(f,typeof t!="symbol"?t+"":t,e);let Vg=class{constructor(t,e){if(oi(this,"data"),oi(this,"bones"),oi(this,"target"),oi(this,"bendDirection",0),oi(this,"compress",!1),oi(this,"stretch",!1),oi(this,"mix",1),oi(this,"softness",0),oi(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=s}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,e,s,n,r,l,h){const i=t.parent.matrix;if(!i)throw new Error("IK bone must have parent.");const a=i.a;let o=i.c;const d=i.b;let u=i.d,m=-t.ashearX-t.arotation,c=0,g=0;const p=t.skeleton.scaleX,y=-t.skeleton.scaleY;switch(t.data.transformMode){case Yn.OnlyTranslation:c=e-t.worldX,g=s-t.worldY,g=-g;break;case Yn.NoRotationOrReflection:const b=Math.abs(a*u-o*d)/(a*a+d*d),S=a/p,C=d/y;o=-C*b*p,u=S*b*y,m+=Math.atan2(C,S)*et.radDeg;default:const v=e-i.tx,A=s-i.ty,M=a*u-o*d;c=(v*u-A*o)/M-t.ax,g=(A*a-v*d)/M-t.ay}m+=Math.atan2(g,c)*et.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let w=t.ascaleX,x=t.ascaleY;if(n||r){switch(t.data.transformMode){case Yn.NoScale:case Yn.NoScaleOrReflection:c=e-t.worldX,g=s-t.worldY}const b=t.data.length*w,S=Math.sqrt(c*c+g*g);if(n&&S<b||r&&S>b&&b>1e-4){const C=(S/b-1)*h+1;w*=C,l&&(x*=C)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,w,x,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,l,h,i,a){const o=t.ax,d=t.ay;let u=t.ascaleX,m=t.ascaleY,c=u,g=m,p=e.ascaleX;const y=t.matrix;let w=0,x=0,b=0;u<0?(u=-u,w=180,b=-1):(w=0,b=1),m<0&&(m=-m,b=-b),p<0?(p=-p,x=180):x=0;const S=e.ax;let C=0,v=0,A=0,M=y.a,I=y.c,E=y.b,P=y.d;const R=Math.abs(u-m)<=1e-4;!R||l?(C=0,v=M*S+y.tx,A=E*S+y.ty):(C=e.ay,v=M*S+I*C+y.tx,A=E*S+P*C+y.ty);const k=t.parent.matrix;if(!k)throw new Error("IK parent must itself have a parent.");M=k.a,I=k.c,E=k.b,P=k.d;const Y=1/(M*P-I*E);let F=v-k.tx,X=A-k.ty;const W=(F*P-X*I)*Y-o,B=(X*M-F*E)*Y-d,N=Math.sqrt(W*W+B*B);let O=e.data.length*p,Z,$;if(N<1e-4){this.apply1(t,s,n,!1,l,!1,a),e.updateWorldTransformWith(S,C,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);return}F=s-k.tx,X=n-k.ty;let D=(F*P-X*I)*Y-o,_=(X*M-F*E)*Y-d,lt=D*D+_*_;if(i!=0){i*=u*(p+1)*.5;const ct=Math.sqrt(lt),Mt=ct-N-O*u+i;if(Mt>0){let Rt=Math.min(1,Mt/(i*2))-1;Rt=(Mt-i*(1-Rt*Rt))/ct,D-=Rt*D,_-=Rt*_,lt=D*D+_*_}}t:if(R){O*=u;let ct=(lt-N*N-O*O)/(2*N*O);ct<-1?(ct=-1,$=Math.PI*r):ct>1?(ct=1,$=0,l&&(M=(Math.sqrt(lt)/(N+O)-1)*a+1,c*=M,h&&(g*=M))):$=Math.acos(ct)*r,M=N+O*ct,I=O*Math.sin($),Z=Math.atan2(_*M-D*I,D*M+_*I)}else{M=u*O,I=m*O;const ct=M*M,Mt=I*I,Rt=Math.atan2(_,D);E=Mt*N*N+ct*lt-ct*Mt;const de=-2*Mt*N,Ze=Mt-ct;if(P=de*de-4*Ze*E,P>=0){let Kt=Math.sqrt(P);de<0&&(Kt=-Kt),Kt=-(de+Kt)*.5;const ps=Kt/Ze,Vn=E/Kt,ts=Math.abs(ps)<Math.abs(Vn)?ps:Vn;if(ts*ts<=lt){X=Math.sqrt(lt-ts*ts)*r,Z=Rt-Math.atan2(X,ts),$=Math.atan2(X/m,(ts-N)/u);break t}}let Je=et.PI,we=N-M,Ye=we*we,Qe=0,je=0,ue=N+M,ye=ue*ue,Ue=0;E=-M*N/(ct-Mt),E>=-1&&E<=1&&(E=Math.acos(E),F=M*Math.cos(E)+N,X=I*Math.sin(E),P=F*F+X*X,P<Ye&&(Je=E,Ye=P,we=F,Qe=X),P>ye&&(je=E,ye=P,ue=F,Ue=X)),lt<=(Ye+ye)*.5?(Z=Rt-Math.atan2(Qe*r,we),$=Je*r):(Z=Rt-Math.atan2(Ue*r,ue),$=je*r)}const wt=Math.atan2(C,S)*b;let Tt=t.arotation;Z=(Z-wt)*et.radDeg+w-Tt,Z>180?Z-=360:Z<-180&&(Z+=360),t.updateWorldTransformWith(o,d,Tt+Z*a,c,g,0,0),Tt=e.arotation,$=(($+wt)*et.radDeg-e.ashearX)*b+x-Tt,$>180?$-=360:$<-180&&($+=360),e.updateWorldTransformWith(S,C,Tt+$*a,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}};var IS=Object.defineProperty,kS=(f,t,e)=>t in f?IS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ar=(f,t,e)=>kS(f,typeof t!="symbol"?t+"":t,e);let _g=class{constructor(t,e){if(ar(this,"data"),ar(this,"bones"),ar(this,"target"),ar(this,"mixRotate",0),ar(this,"mixX",0),ar(this,"mixY",0),ar(this,"mixScaleX",0),ar(this,"mixScaleY",0),ar(this,"mixShearY",0),ar(this,"temp",new vc),ar(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=s}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,u=a.b,m=a.d,c=o*m-d*u>0?et.degRad:-et.degRad,g=this.data.offsetRotation*c,p=this.data.offsetShearY*c,y=this.bones;for(let w=0,x=y.length;w<x;w++){const b=y[w],S=b.matrix;if(t!=0){const C=S.a,v=S.c,A=S.b,M=S.d;let I=Math.atan2(u,o)-Math.atan2(A,C)+g;I>et.PI?I-=et.PI2:I<-et.PI&&(I+=et.PI2),I*=t;const E=Math.cos(I),P=Math.sin(I);S.a=E*C-P*A,S.c=E*v-P*M,S.b=P*C+E*A,S.d=P*v+E*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=(C.x-S.tx)*e,S.ty+=(C.y-S.ty)*s}if(n!=0){let C=Math.sqrt(S.a*S.a+S.b*S.b);C!=0&&(C=(C+(Math.sqrt(o*o+u*u)-C+this.data.offsetScaleX)*n)/C),S.a*=C,S.b*=C}if(r!=0){let C=Math.sqrt(S.c*S.c+S.d*S.d);C!=0&&(C=(C+(Math.sqrt(d*d+m*m)-C+this.data.offsetScaleY)*r)/C),S.c*=C,S.d*=C}if(l>0){const C=S.c,v=S.d,A=Math.atan2(v,C);let M=Math.atan2(m,d)-Math.atan2(u,o)-(A-Math.atan2(S.b,S.a));M>et.PI?M-=et.PI2:M<-et.PI&&(M+=et.PI2),M=A+(M+p)*l;const I=Math.sqrt(C*C+v*v);S.c=Math.cos(M)*I,S.d=Math.sin(M)*I}b.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,u=a.b,m=a.d,c=o*m-d*u>0?et.degRad:-et.degRad,g=this.data.offsetRotation*c,p=this.data.offsetShearY*c,y=this.bones;for(let w=0,x=y.length;w<x;w++){const b=y[w],S=b.matrix;if(t!=0){const C=S.a,v=S.c,A=S.b,M=S.d;let I=Math.atan2(u,o)+g;I>et.PI?I-=et.PI2:I<-et.PI&&(I+=et.PI2),I*=t;const E=Math.cos(I),P=Math.sin(I);S.a=E*C-P*A,S.c=E*v-P*M,S.b=P*C+E*A,S.d=P*v+E*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=C.x*e,S.ty+=C.y*s}if(n!=0){const C=(Math.sqrt(o*o+u*u)-1+this.data.offsetScaleX)*n+1;S.a*=C,S.b*=C}if(r!=0){const C=(Math.sqrt(d*d+m*m)-1+this.data.offsetScaleY)*r+1;S.c*=C,S.d*=C}if(l>0){let C=Math.atan2(m,d)-Math.atan2(u,o);C>et.PI?C-=et.PI2:C<-et.PI&&(C+=et.PI2);const v=S.c,A=S.d;C=Math.atan2(A,v)+(C-et.PI/2+p)*l;const M=Math.sqrt(v*v+A*A);S.c=Math.cos(C)*M,S.d=Math.sin(C)*M}b.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a];let u=d.arotation;if(t!=0){let w=h.arotation-u+this.data.offsetRotation;w-=(16384-(16384.499999999996-w/360|0))*360,u+=w*t}let m=d.ax,c=d.ay;m+=(h.ax-m+this.data.offsetX)*e,c+=(h.ay-c+this.data.offsetY)*s;let g=d.ascaleX,p=d.ascaleY;n!=0&&g!=0&&(g=(g+(h.ascaleX-g+this.data.offsetScaleX)*n)/g),r!=0&&p!=0&&(p=(p+(h.ascaleY-p+this.data.offsetScaleY)*r)/p);let y=d.ashearY;if(l!=0){let w=h.ashearY-y+this.data.offsetShearY;w-=(16384-(16384.499999999996-w/360|0))*360,y+=w*l}d.updateWorldTransformWith(m,c,u,g,p,d.ashearX,y)}}applyRelativeLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a],u=d.arotation+(h.arotation+this.data.offsetRotation)*t,m=d.ax+(h.ax+this.data.offsetX)*e,c=d.ay+(h.ay+this.data.offsetY)*s,g=d.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*n+1),p=d.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*r+1),y=d.ashearY+(h.ashearY+this.data.offsetShearY)*l;d.updateWorldTransformWith(m,c,u,g,p,d.ashearX,y)}}};var PS=Object.defineProperty,RS=(f,t,e)=>t in f?PS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,js=(f,t,e)=>RS(f,typeof t!="symbol"?t+"":t,e);const Dg=class Kl{constructor(t){if(js(this,"data"),js(this,"bones"),js(this,"slots"),js(this,"drawOrder"),js(this,"ikConstraints"),js(this,"transformConstraints"),js(this,"pathConstraints"),js(this,"_updateCache",new Array),js(this,"skin",null),js(this,"color"),js(this,"scaleX",1),js(this,"scaleY",1),js(this,"x",0),js(this,"y",0),!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(!s.parent)n=new ed(s,this,null);else{const r=this.bones[s.parent.index];n=new ed(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new Ng(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new Vg(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new _g(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new $g(s,this))}this.color=new Dt(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0;const e=this.bones;for(let o=0,d=e.length;o<d;o++){const u=e[o];u.sorted=u.data.skinRequired,u.active=!u.sorted}if(this.skin){const o=this.skin.bones;for(let d=0,u=this.skin.bones.length;d<u;d++){let m=this.bones[o[d].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m)}}const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,l=s.length,h=n.length,i=r.length,a=l+h+i;t:for(let o=0;o<a;o++){for(let d=0;d<l;d++){const u=s[d];if(u.data.order==o){this.sortIkConstraint(u);continue t}}for(let d=0;d<h;d++){const u=n[d];if(u.data.order==o){this.sortTransformConstraint(u);continue t}}for(let d=0;d<i;d++){const u=r[d];if(u.data.order==o){this.sortPathConstraint(u);continue t}}}for(let o=0,d=e.length;o<d;o++)this.sortBone(e[o])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&mt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length==1)this._updateCache.push(t),this.sortReset(n.children);else{const r=s[s.length-1];this.sortBone(r),this._updateCache.push(t),this.sortReset(n.children),r.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&mt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,s=e.data.index,n=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof bl&&this.sortPathConstraintAttachmentWith(r,n);const l=t.bones,h=l.length;for(let i=0;i<h;i++)this.sortBone(l[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(l[i].children);for(let i=0;i<h;i++)l[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&mt.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this.sortBone(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof bl))return;const s=t.bones;if(!s)this.sortBone(e);else{const n=this.bones;for(let r=0,l=s.length;r<l;){let h=s[r++];for(h+=r;r<h;)this.sortBone(n[s[r++]])}}}sortBone(t){if(!t||t.sorted)return;const e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.bones;for(let s=0,n=t.length;s<n;s++){const r=t[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const e=this._updateCache;for(let s=0,n=e.length;s<n;s++)e[s].update()}updateWorldTransformWith(t){const e=this.getRootBone(),s=t.matrix.a,n=t.matrix.c,r=t.matrix.b,l=t.matrix.d;e.matrix.tx=s*this.x+n*this.y+t.worldX,e.matrix.ty=r*this.x+l*this.y+t.worldY;const h=e.rotation+90+e.shearY,i=et.cosDeg(e.rotation+e.shearX)*e.scaleX,a=et.cosDeg(h)*e.scaleY,o=et.sinDeg(e.rotation+e.shearX)*e.scaleX,d=et.sinDeg(h)*e.scaleY,u=this.scaleX,m=-this.scaleY;e.matrix.a=(s*i+n*o)*u,e.matrix.c=(s*a+n*d)*u,e.matrix.b=(r*i+l*o)*m,e.matrix.d=(r*a+l*d)*m;const c=this._updateCache;for(let g=0,p=c.length;g<p;g++){const y=c[g];y!=e&&y.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let r=0,l=t.length;r<l;r++)t[r].setToSetupPose();const e=this.ikConstraints;for(let r=0,l=e.length;r<l;r++){const h=e[r];h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}const s=this.transformConstraints;for(let r=0,l=s.length;r<l;r++){const h=s[r],i=h.data;h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY,h.mixScaleX=i.mixScaleX,h.mixScaleY=i.mixScaleY,h.mixShearY=i.mixShearY}const n=this.pathConstraints;for(let r=0,l=n.length;r<l;r++){const h=n[r],i=h.data;h.position=i.position,h.spacing=i.spacing,h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY}}setSlotsToSetupPose(){const t=this.slots;mt.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(!e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],l=r.data.attachmentName;if(l){const h=t.getAttachment(s,l);h&&r.setAttachment(h)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){const s=this.data.findSlot(t);if(!s)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(s.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){const s=this.skin.getAttachment(t,e);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.data.name==t){let h=null;if(e&&(h=this.getAttachment(n,e),!h))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);l.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}getBoundsRect(){const t=new vc,e=new vc;return this.getBounds(t,e),{x:t.x,y:t.y,width:e.x,height:e.y}}getBounds(t,e,s=new Array(2)){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let a=0,o=n.length;a<o;a++){const d=n[a];if(!d.bone.active)continue;let u=0,m=null;const c=d.getAttachment();if(c instanceof Mc)u=8,m=mt.setArraySize(s,u,0),c.computeWorldVertices(d,m,0,2);else if(c instanceof ph){const g=c;u=g.worldVerticesLength,m=mt.setArraySize(s,u,0),g.computeWorldVertices(d,0,u,m,0,2)}if(m)for(let g=0,p=m.length;g<p;g+=2){const y=m[g],w=m[g+1];r=Math.min(r,y),l=Math.min(l,w),h=Math.max(h,y),i=Math.max(i,w)}}t.set(r,l),e.set(h-r,i-l)}get flipX(){return this.scaleX==-1}set flipX(t){Kl.deprecatedWarning1||(Kl.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){Kl.deprecatedWarning1||(Kl.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};js(Dg,"deprecatedWarning1",!1);let Lg=Dg;var YS=Object.defineProperty,FS=(f,t,e)=>t in f?YS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,La=(f,t,e)=>FS(f,typeof t!="symbol"?t+"":t,e);let sd=class{constructor(t,e){if(La(this,"data"),La(this,"intValue",0),La(this,"floatValue",0),La(this,"stringValue",null),La(this,"time",0),La(this,"volume",0),La(this,"balance",0),!e)throw new Error("data cannot be null.");this.time=t,this.data=e}};var BS=Object.defineProperty,XS=(f,t,e)=>t in f?BS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,rs=(f,t,e)=>XS(f,typeof t!="symbol"?t+"":t,e);let nd=class{constructor(){rs(this,"name",null),rs(this,"bones",new Array),rs(this,"slots",new Array),rs(this,"skins",new Array),rs(this,"defaultSkin",null),rs(this,"events",new Array),rs(this,"animations",new Array),rs(this,"ikConstraints",new Array),rs(this,"transformConstraints",new Array),rs(this,"pathConstraints",new Array),rs(this,"x",0),rs(this,"y",0),rs(this,"width",0),rs(this,"height",0),rs(this,"version",null),rs(this,"hash",null),rs(this,"fps",0),rs(this,"imagesPath",null),rs(this,"audioPath",null)}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}};var $S=Object.defineProperty,NS=(f,t,e)=>t in f?$S(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Oa=(f,t,e)=>NS(f,typeof t!="symbol"?t+"":t,e);let rd=class{constructor(t,e,s){if(Oa(this,"index",0),Oa(this,"name"),Oa(this,"boneData"),Oa(this,"color",new Dt(1,1,1,1)),Oa(this,"darkColor",null),Oa(this,"attachmentName",null),Oa(this,"blendMode",V.BLEND_MODES.NORMAL),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");if(!s)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}};var VS=Object.defineProperty,_S=(f,t,e)=>t in f?VS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,wn=(f,t,e)=>_S(f,typeof t!="symbol"?t+"":t,e);let id=class{constructor(t,e,s){if(wn(this,"index",0),wn(this,"name"),wn(this,"parent",null),wn(this,"length",0),wn(this,"x",0),wn(this,"y",0),wn(this,"rotation",0),wn(this,"scaleX",1),wn(this,"scaleY",1),wn(this,"shearX",0),wn(this,"shearY",0),wn(this,"transformMode",Yn.Normal),wn(this,"skinRequired",!1),wn(this,"color",new Dt),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}};var DS=Object.defineProperty,LS=(f,t,e)=>t in f?DS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Hi=(f,t,e)=>LS(f,typeof t!="symbol"?t+"":t,e);let ad=class extends xh{constructor(t){super(t,0,!1),Hi(this,"bones",new Array),Hi(this,"_target",null),Hi(this,"bendDirection",1),Hi(this,"compress",!1),Hi(this,"stretch",!1),Hi(this,"uniform",!1),Hi(this,"mix",1),Hi(this,"softness",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}};var OS=Object.defineProperty,WS=(f,t,e)=>t in f?OS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Us=(f,t,e)=>WS(f,typeof t!="symbol"?t+"":t,e);let od=class extends xh{constructor(t){super(t,0,!1),Us(this,"bones",new Array),Us(this,"_target",null),Us(this,"mixRotate",0),Us(this,"mixX",0),Us(this,"mixY",0),Us(this,"mixScaleX",0),Us(this,"mixScaleY",0),Us(this,"mixShearY",0),Us(this,"offsetRotation",0),Us(this,"offsetX",0),Us(this,"offsetY",0),Us(this,"offsetScaleX",0),Us(this,"offsetScaleY",0),Us(this,"offsetShearY",0),Us(this,"relative",!1),Us(this,"local",!1)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}};var US=Object.defineProperty,qS=(f,t,e)=>t in f?US(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,bh=(f,t,e)=>qS(f,typeof t!="symbol"?t+"":t,e);let ld=class{constructor(t,e,s){this.slotIndex=t,this.name=e,this.attachment=s}},wh=class{constructor(t){if(bh(this,"name"),bh(this,"attachments",new Array),bh(this,"bones",Array()),bh(this,"constraints",new Array),!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(!s)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let l=0;l<this.bones.length;l++)if(this.bones[l]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let l=0;l<this.constraints.length;l++)if(this.constraints[l]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let l=0;l<this.bones.length;l++)if(this.bones[l]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let l=0;l<this.constraints.length;l++)if(this.constraints[l]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];n.attachment&&(n.attachment instanceof ph?(n.attachment=n.attachment.newLinkedMesh(),this.setAttachment(n.slotIndex,n.name,n.attachment)):(n.attachment=n.attachment.copy(),this.setAttachment(n.slotIndex,n.name,n.attachment)))}}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){const s=this.attachments[t];s&&delete s[e]}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const s=this.attachments[e];if(s)for(const n in s){const r=s[n];r&&t.push(new ld(e,n,r))}}return t}getAttachmentsForSlot(t,e){const s=this.attachments[t];if(s)for(const n in s){const r=s[n];r&&e.push(new ld(t,n,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],l=r.getAttachment();if(l&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(l==a){const o=this.getAttachment(s,i);o&&r.setAttachment(o);break}}}s++}}};var zS=Object.defineProperty,GS=(f,t,e)=>t in f?zS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Wa=(f,t,e)=>GS(f,typeof t!="symbol"?t+"":t,e);let hd=class{constructor(t){Wa(this,"name"),Wa(this,"intValue",0),Wa(this,"floatValue",0),Wa(this,"stringValue",null),Wa(this,"audioPath",null),Wa(this,"volume",0),Wa(this,"balance",0),this.name=t}},HS=class{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<7,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<14,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<21,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}};var KS=Object.defineProperty,ZS=(f,t,e)=>t in f?KS(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Lr=(f,t,e)=>ZS(f,typeof t!="symbol"?t+"":t,e);let cd=class{constructor(t){Lr(this,"ver40",!1),Lr(this,"scale",1),Lr(this,"attachmentLoader"),Lr(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new nd;s.name="";const n=new HS(t),r=n.readInt32(),l=n.readInt32();s.hash=l==0&&r==0?null:l.toString(16)+r.toString(16),s.version=n.readString();const h=s.version.substr(0,3);if(h!=="4.0"&&h!=="4.1"){const d=`Spine 4.1 loader cant load version ${s.version}. Please configure your pixi-spine bundle`;console.error(d)}this.ver40=h==="4.0",s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat();const i=n.readBoolean();i&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let a=0;a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readString();if(!u)throw new Error("String in string table must not be null.");n.strings.push(u)}a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readString();if(!u)throw new Error("Bone name must not be null.");const m=d==0?null:s.bones[n.readInt(!0)],c=new id(d,u,m);c.rotation=n.readFloat(),c.x=n.readFloat()*e,c.y=n.readFloat()*e,c.scaleX=n.readFloat(),c.scaleY=n.readFloat(),c.shearX=n.readFloat(),c.shearY=n.readFloat(),c.length=n.readFloat()*e,c.transformMode=n.readInt(!0),c.skinRequired=n.readBoolean(),i&&Dt.rgba8888ToColor(c.color,n.readInt32()),s.bones.push(c)}a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readString();if(!u)throw new Error("Slot name must not be null.");const m=s.bones[n.readInt(!0)],c=new rd(d,u,m);Dt.rgba8888ToColor(c.color,n.readInt32());const g=n.readInt32();g!=-1&&Dt.rgb888ToColor(c.darkColor=new Dt,g),c.attachmentName=n.readStringRef(),c.blendMode=n.readInt(!0),s.slots.push(c)}a=n.readInt(!0);for(let d=0,u;d<a;d++){const m=n.readString();if(!m)throw new Error("IK constraint data name must not be null.");const c=new ad(m);c.order=n.readInt(!0),c.skinRequired=n.readBoolean(),u=n.readInt(!0);for(let g=0;g<u;g++)c.bones.push(s.bones[n.readInt(!0)]);c.target=s.bones[n.readInt(!0)],c.mix=n.readFloat(),c.softness=n.readFloat()*e,c.bendDirection=n.readByte(),c.compress=n.readBoolean(),c.stretch=n.readBoolean(),c.uniform=n.readBoolean(),s.ikConstraints.push(c)}a=n.readInt(!0);for(let d=0,u;d<a;d++){const m=n.readString();if(!m)throw new Error("Transform constraint data name must not be null.");const c=new od(m);c.order=n.readInt(!0),c.skinRequired=n.readBoolean(),u=n.readInt(!0);for(let g=0;g<u;g++)c.bones.push(s.bones[n.readInt(!0)]);c.target=s.bones[n.readInt(!0)],c.local=n.readBoolean(),c.relative=n.readBoolean(),c.offsetRotation=n.readFloat(),c.offsetX=n.readFloat()*e,c.offsetY=n.readFloat()*e,c.offsetScaleX=n.readFloat(),c.offsetScaleY=n.readFloat(),c.offsetShearY=n.readFloat(),c.mixRotate=n.readFloat(),c.mixX=n.readFloat(),c.mixY=n.readFloat(),c.mixScaleX=n.readFloat(),c.mixScaleY=n.readFloat(),c.mixShearY=n.readFloat(),s.transformConstraints.push(c)}a=n.readInt(!0);for(let d=0,u;d<a;d++){const m=n.readString();if(!m)throw new Error("Path constraint data name must not be null.");const c=new td(m);c.order=n.readInt(!0),c.skinRequired=n.readBoolean(),u=n.readInt(!0);for(let g=0;g<u;g++)c.bones.push(s.bones[n.readInt(!0)]);c.target=s.slots[n.readInt(!0)],c.positionMode=n.readInt(!0),c.spacingMode=n.readInt(!0),c.rotateMode=n.readInt(!0),c.offsetRotation=n.readFloat(),c.position=n.readFloat(),c.positionMode==ii.Fixed&&(c.position*=e),c.spacing=n.readFloat(),(c.spacingMode==fs.Length||c.spacingMode==fs.Fixed)&&(c.spacing*=e),c.mixRotate=n.readFloat(),c.mixX=n.readFloat(),c.mixY=n.readFloat(),s.pathConstraints.push(c)}const o=this.readSkin(n,s,!0,i);o&&(s.defaultSkin=o,s.skins.push(o));{let d=s.skins.length;for(mt.setArraySize(s.skins,a=d+n.readInt(!0));d<a;d++){const u=this.readSkin(n,s,!1,i);if(!u)throw new Error("readSkin() should not have returned null.");s.skins[d]=u}}a=this.linkedMeshes.length;for(let d=0;d<a;d++){const u=this.linkedMeshes[d],m=u.skin?s.findSkin(u.skin):s.defaultSkin;if(!m)throw new Error("Not skin found for linked mesh.");if(!u.parent)throw new Error("Linked mesh parent must not be null");const c=m.getAttachment(u.slotIndex,u.parent);if(!c)throw new Error(`Parent mesh not found: ${u.parent}`);u.mesh.timelineAttachment=u.inheritTimeline?c:u.mesh,u.mesh.setParentMesh(c)}this.linkedMeshes.length=0,a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readStringRef();if(!u)throw new Error;const m=new hd(u);m.intValue=n.readInt(!1),m.floatValue=n.readFloat(),m.stringValue=n.readString(),m.audioPath=n.readString(),m.audioPath&&(m.volume=n.readFloat(),m.balance=n.readFloat()),s.events.push(m)}a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readString();if(!u)throw new Error("Animatio name must not be null.");s.animations.push(this.readAnimation(n,u,s))}return s}readSkin(t,e,s,n){let r=null,l=0;if(s){if(l=t.readInt(!0),l==0)return null;r=new wh("default")}else{const h=t.readStringRef();if(!h)throw new Error("Skin name must not be null.");r=new wh(h),r.bones.length=t.readInt(!0);for(let i=0,a=r.bones.length;i<a;i++)r.bones[i]=e.bones[t.readInt(!0)];for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.pathConstraints[t.readInt(!0)]);l=t.readInt(!0)}for(let h=0;h<l;h++){const i=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readStringRef();if(!d)throw new Error("Attachment name must not be null");const u=this.readAttachment(t,e,r,i,d,n);u&&r.setAttachment(i,d,u)}}return r}readAttachment(t,e,s,n,r,l){const h=this.scale;let i=t.readStringRef();switch(i||(i=r),t.readByte()){case $e.Region:{let a=t.readStringRef();const o=t.readFloat(),d=t.readFloat(),u=t.readFloat(),m=t.readFloat(),c=t.readFloat(),g=t.readFloat(),p=t.readFloat(),y=t.readInt32(),w=this.readSequence(t);a||(a=i);const x=this.attachmentLoader.newRegionAttachment(s,i,a,w);return x?(x.path=a,x.x=d*h,x.y=u*h,x.scaleX=m,x.scaleY=c,x.rotation=o,x.width=g*h,x.height=p*h,Dt.rgba8888ToColor(x.color,y),x.sequence=w,w==null&&x.updateRegion(),x):null}case $e.BoundingBox:{const a=t.readInt(!0),o=this.readVertices(t,a),d=l?t.readInt32():0,u=this.attachmentLoader.newBoundingBoxAttachment(s,i);return u?(u.worldVerticesLength=a<<1,u.vertices=o.vertices,u.bones=o.bones,l&&Dt.rgba8888ToColor(u.color,d),u):null}case $e.Mesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readInt(!0),u=this.readFloatArray(t,d<<1,1),m=this.readShortArray(t),c=this.readVertices(t,d),g=t.readInt(!0),p=this.readSequence(t);let y=[],w=0,x=0;l&&(y=this.readShortArray(t),w=t.readFloat(),x=t.readFloat()),a||(a=i);const b=this.attachmentLoader.newMeshAttachment(s,i,a,p);return b?(b.path=a,Dt.rgba8888ToColor(b.color,o),b.bones=c.bones,b.vertices=c.vertices,b.worldVerticesLength=d<<1,b.triangles=m,b.regionUVs=new Float32Array(u),b.hullLength=g<<1,b.sequence=p,l&&(b.edges=y,b.width=w*h,b.height=x*h),b):null}case $e.LinkedMesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readStringRef(),u=t.readStringRef(),m=t.readBoolean(),c=this.readSequence(t);let g=0,p=0;l&&(g=t.readFloat(),p=t.readFloat()),a||(a=i);const y=this.attachmentLoader.newMeshAttachment(s,i,a,c);return y?(y.path=a,Dt.rgba8888ToColor(y.color,o),y.sequence=c,l&&(y.width=g*h,y.height=p*h),this.linkedMeshes.push(new JS(y,d,n,u,m)),y):null}case $e.Path:{const a=t.readBoolean(),o=t.readBoolean(),d=t.readInt(!0),u=this.readVertices(t,d),m=mt.newArray(d/3,0);for(let p=0,y=m.length;p<y;p++)m[p]=t.readFloat()*h;const c=l?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(s,i);return g?(g.closed=a,g.constantSpeed=o,g.worldVerticesLength=d<<1,g.vertices=u.vertices,g.bones=u.bones,g.lengths=m,l&&Dt.rgba8888ToColor(g.color,c),g):null}case $e.Point:{const a=t.readFloat(),o=t.readFloat(),d=t.readFloat(),u=l?t.readInt32():0,m=this.attachmentLoader.newPointAttachment(s,i);return m?(m.x=o*h,m.y=d*h,m.rotation=a,l&&Dt.rgba8888ToColor(m.color,u),m):null}case $e.Clipping:{const a=t.readInt(!0),o=t.readInt(!0),d=this.readVertices(t,o),u=l?t.readInt32():0,m=this.attachmentLoader.newClippingAttachment(s,i);return m?(m.endSlot=e.slots[a],m.worldVerticesLength=o<<1,m.vertices=d.vertices,m.bones=d.bones,l&&Dt.rgba8888ToColor(m.color,u),m):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const e=new Tc(t.readInt(!0));return e.start=t.readInt(!0),e.digits=t.readInt(!0),e.setupIndex=t.readInt(!0),e}readDeformTimelineType(t){return this.ver40?Og:t.readByte()}readVertices(t,e){const s=this.scale,n=e<<1,r=new QS;if(!t.readBoolean())return r.vertices=this.readFloatArray(t,n,s),r;const l=new Array,h=new Array;for(let i=0;i<e;i++){const a=t.readInt(!0);h.push(a);for(let o=0;o<a;o++)h.push(t.readInt(!0)),l.push(t.readFloat()*s),l.push(t.readFloat()*s),l.push(t.readFloat())}return r.vertices=mt.toFloatArray(l),r.bones=h,r}readFloatArray(t,e,s){const n=new Array(e);if(s==1)for(let r=0;r<e;r++)n[r]=t.readFloat();else for(let r=0;r<e;r++)n[r]=t.readFloat()*s;return n}readShortArray(t){const e=t.readInt(!0),s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readShort();return s}readAnimation(t,e,s){t.readInt(!0);const n=new Array,r=this.scale;for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readByte(),g=t.readInt(!0),p=g-1;switch(c){case hC:{const y=new Da(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat(),t.readStringRef());n.push(y);break}case cC:{const y=t.readInt(!0),w=new Nc(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255;for(let A=0,M=0;w.setFrame(A,x,b,S,C,v),A!=p;A++){const I=t.readFloat(),E=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255;switch(t.readByte()){case or:w.setStepped(A);break;case lr:Wt(t,w,M++,A,0,x,I,b,E,1),Wt(t,w,M++,A,1,x,I,S,P,1),Wt(t,w,M++,A,2,x,I,C,R,1),Wt(t,w,M++,A,3,x,I,v,k,1)}x=I,b=E,S=P,C=R,v=k}n.push(w);break}case dC:{const y=t.readInt(!0),w=new Vc(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let v=0,A=0;w.setFrame(v,x,b,S,C),v!=p;v++){const M=t.readFloat(),I=t.readUnsignedByte()/255,E=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255;switch(t.readByte()){case or:w.setStepped(v);break;case lr:Wt(t,w,A++,v,0,x,M,b,I,1),Wt(t,w,A++,v,1,x,M,S,E,1),Wt(t,w,A++,v,2,x,M,C,P,1)}x=M,b=I,S=E,C=P}n.push(w);break}case uC:{const y=t.readInt(!0),w=new Dc(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255;for(let E=0,P=0;w.setFrame(E,x,b,S,C,v,A,M,I),E!=p;E++){const R=t.readFloat(),k=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255;switch(t.readByte()){case or:w.setStepped(E);break;case lr:Wt(t,w,P++,E,0,x,R,b,k,1),Wt(t,w,P++,E,1,x,R,S,Y,1),Wt(t,w,P++,E,2,x,R,C,F,1),Wt(t,w,P++,E,3,x,R,v,X,1),Wt(t,w,P++,E,4,x,R,A,W,1),Wt(t,w,P++,E,5,x,R,M,B,1),Wt(t,w,P++,E,6,x,R,I,N,1)}x=R,b=k,S=Y,C=F,v=X,A=W,M=B,I=N}n.push(w);break}case fC:{const y=t.readInt(!0),w=new Lc(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let I=0,E=0;w.setFrame(I,x,b,S,C,v,A,M),I!=p;I++){const P=t.readFloat(),R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255;switch(t.readByte()){case or:w.setStepped(I);break;case lr:Wt(t,w,E++,I,0,x,P,b,R,1),Wt(t,w,E++,I,1,x,P,S,k,1),Wt(t,w,E++,I,2,x,P,C,Y,1),Wt(t,w,E++,I,3,x,P,v,F,1),Wt(t,w,E++,I,4,x,P,A,X,1),Wt(t,w,E++,I,5,x,P,M,W,1)}x=P,b=R,S=k,C=Y,v=F,A=X,M=W}n.push(w);break}case mC:{const y=new _c(g,t.readInt(!0),d);let w=t.readFloat(),x=t.readUnsignedByte()/255;for(let b=0,S=0;y.setFrame(b,w,x),b!=p;b++){const C=t.readFloat(),v=t.readUnsignedByte()/255;switch(t.readByte()){case or:y.setStepped(b);break;case lr:Wt(t,y,S++,b,0,w,C,x,v,1)}w=C,x=v}n.push(y)}}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readByte(),g=t.readInt(!0),p=t.readInt(!0);switch(c){case jS:n.push(li(t,new gl(g,p,d),1));break;case tC:n.push(dd(t,new Ic(g,p,d),r));break;case eC:n.push(li(t,new kc(g,p,d),r));break;case sC:n.push(li(t,new Pc(g,p,d),r));break;case nC:n.push(dd(t,new Rc(g,p,d),1));break;case rC:n.push(li(t,new Yc(g,p,d),1));break;case iC:n.push(li(t,new Fc(g,p,d),1));break;case aC:n.push(dd(t,new Bc(g,p,d),1));break;case oC:n.push(li(t,new Xc(g,p,d),1));break;case lC:n.push(li(t,new $c(g,p,d),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),u=t.readInt(!0),m=u-1,c=new Wc(u,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat()*r;for(let w=0,x=0;c.setFrame(w,g,p,y,t.readByte(),t.readBoolean(),t.readBoolean()),w!=m;w++){const b=t.readFloat(),S=t.readFloat(),C=t.readFloat()*r;switch(t.readByte()){case or:c.setStepped(w);break;case lr:Wt(t,c,x++,w,0,g,b,p,S,1),Wt(t,c,x++,w,1,g,b,y,C,r)}g=b,p=S,y=C}n.push(c)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),u=t.readInt(!0),m=u-1,c=new Uc(u,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),x=t.readFloat(),b=t.readFloat(),S=t.readFloat();for(let C=0,v=0;c.setFrame(C,g,p,y,w,x,b,S),C!=m;C++){const A=t.readFloat(),M=t.readFloat(),I=t.readFloat(),E=t.readFloat(),P=t.readFloat(),R=t.readFloat(),k=t.readFloat();switch(t.readByte()){case or:c.setStepped(C);break;case lr:Wt(t,c,v++,C,0,g,A,p,M,1),Wt(t,c,v++,C,1,g,A,y,I,1),Wt(t,c,v++,C,2,g,A,w,E,1),Wt(t,c,v++,C,3,g,A,x,P,1),Wt(t,c,v++,C,4,g,A,b,R,1),Wt(t,c,v++,C,5,g,A,S,k,1)}g=A,p=M,y=I,w=E,x=P,b=R,S=k}n.push(c)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),u=s.pathConstraints[d];for(let m=0,c=t.readInt(!0);m<c;m++)switch(t.readByte()){case pC:n.push(li(t,new qc(t.readInt(!0),t.readInt(!0),d),u.positionMode==ii.Fixed?r:1));break;case xC:n.push(li(t,new zc(t.readInt(!0),t.readInt(!0),d),u.spacingMode==fs.Length||u.spacingMode==fs.Fixed?r:1));break;case bC:const g=new Gc(t.readInt(!0),t.readInt(!0),d);let p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),x=t.readFloat();for(let b=0,S=0,C=g.getFrameCount()-1;g.setFrame(b,p,y,w,x),b!=C;b++){const v=t.readFloat(),A=t.readFloat(),M=t.readFloat(),I=t.readFloat();switch(t.readByte()){case or:g.setStepped(b);break;case lr:Wt(t,g,S++,b,0,p,v,y,A,1),Wt(t,g,S++,b,1,p,v,w,M,1),Wt(t,g,S++,b,2,p,v,x,I,1)}p=v,y=A,w=M,x=I}n.push(g)}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=s.skins[t.readInt(!0)];for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readInt(!0);for(let g=0,p=t.readInt(!0);g<p;g++){const y=t.readStringRef();if(!y)throw new Error("attachmentName must not be null.");const w=d.getAttachment(c,y),x=this.readDeformTimelineType(t),b=t.readInt(!0),S=b-1;switch(x){case Og:{const C=w,v=C.bones,A=C.vertices,M=v?A.length/3*2:A.length,I=t.readInt(!0),E=new Oc(b,I,c,C);let P=t.readFloat();for(let R=0,k=0;;R++){let Y,F=t.readInt(!0);if(F==0)Y=v?mt.newFloatArray(M):A;else{Y=mt.newFloatArray(M);const W=t.readInt(!0);if(F+=W,r==1)for(let B=W;B<F;B++)Y[B]=t.readFloat();else for(let B=W;B<F;B++)Y[B]=t.readFloat()*r;if(!v)for(let B=0,N=Y.length;B<N;B++)Y[B]+=A[B]}if(E.setFrame(R,P,Y),R==S)break;const X=t.readFloat();switch(t.readByte()){case or:E.setStepped(R);break;case lr:Wt(t,E,k++,R,0,P,X,0,1,1)}P=X}n.push(E);break}case gC:{const C=new Hc(b,c,w);for(let v=0;v<b;v++){const A=t.readFloat(),M=t.readInt32();C.setFrame(v,A,Ec[M&15],M>>4,t.readFloat())}n.push(C);break}}}}}const l=t.readInt(!0);if(l>0){const a=new wo(l),o=s.slots.length;for(let d=0;d<l;d++){const u=t.readFloat(),m=t.readInt(!0),c=mt.newArray(o,0);for(let w=o-1;w>=0;w--)c[w]=-1;const g=mt.newArray(o-m,0);let p=0,y=0;for(let w=0;w<m;w++){const x=t.readInt(!0);for(;p!=x;)g[y++]=p++;c[p+t.readInt(!0)]=p++}for(;p<o;)g[y++]=p++;for(let w=o-1;w>=0;w--)c[w]==-1&&(c[w]=g[--y]);a.setFrame(d,u,c)}n.push(a)}const h=t.readInt(!0);if(h>0){const a=new mh(h);for(let o=0;o<h;o++){const d=t.readFloat(),u=s.events[t.readInt(!0)],m=new sd(d,u);m.intValue=t.readInt(!1),m.floatValue=t.readFloat(),m.stringValue=t.readBoolean()?t.readString():u.stringValue,m.data.audioPath&&(m.volume=t.readFloat(),m.balance=t.readFloat()),a.setFrame(o,m)}n.push(a)}let i=0;for(let a=0,o=n.length;a<o;a++)i=Math.max(i,n[a].getDuration());return new uh(e,n,i)}};Lr(cd,"BlendModeValues",[V.BLEND_MODES.NORMAL,V.BLEND_MODES.ADD,V.BLEND_MODES.MULTIPLY,V.BLEND_MODES.SCREEN]);let JS=class{constructor(t,e,s,n,r){Lr(this,"parent"),Lr(this,"skin"),Lr(this,"slotIndex"),Lr(this,"mesh"),Lr(this,"inheritTimeline"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}},QS=class{constructor(t=null,e=null){this.bones=t,this.vertices=e}};function li(f,t,e){let s=f.readFloat(),n=f.readFloat()*e;for(let r=0,l=0,h=t.getFrameCount()-1;t.setFrame(r,s,n),r!=h;r++){const i=f.readFloat(),a=f.readFloat()*e;switch(f.readByte()){case or:t.setStepped(r);break;case lr:Wt(f,t,l++,r,0,s,i,n,a,e)}s=i,n=a}return t}function dd(f,t,e){let s=f.readFloat(),n=f.readFloat()*e,r=f.readFloat()*e;for(let l=0,h=0,i=t.getFrameCount()-1;t.setFrame(l,s,n,r),l!=i;l++){const a=f.readFloat(),o=f.readFloat()*e,d=f.readFloat()*e;switch(f.readByte()){case or:t.setStepped(l);break;case lr:Wt(f,t,h++,l,0,s,a,n,o,e),Wt(f,t,h++,l,1,s,a,r,d,e)}s=a,n=o,r=d}return t}function Wt(f,t,e,s,n,r,l,h,i,a){t.setBezier(e,s,n,r,h,f.readFloat(),f.readFloat()*a,f.readFloat(),f.readFloat()*a,l,i)}const jS=0,tC=1,eC=2,sC=3,nC=4,rC=5,iC=6,aC=7,oC=8,lC=9,hC=0,cC=1,dC=2,uC=3,fC=4,mC=5,Og=0,gC=1,pC=0,xC=1,bC=2,or=1,lr=2;var wC=Object.defineProperty,yC=(f,t,e)=>t in f?wC(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ki=(f,t,e)=>yC(f,typeof t!="symbol"?t+"":t,e);let Wg=class Wx{constructor(t){Ki(this,"attachmentLoader"),Ki(this,"scale",1),Ki(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new nd,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r){s.hash=r.hash,s.version=r.spine;const l=s.version.substr(0,3);if(l!=="4.0"&&l!=="4.1"){const h=`Spine 4.1 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(h)}s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images}if(n.bones)for(let l=0;l<n.bones.length;l++){const h=n.bones[l];let i=null;const a=U(h,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const o=new id(s.bones.length,h.name,i);o.length=U(h,"length",0)*e,o.x=U(h,"x",0)*e,o.y=U(h,"y",0)*e,o.rotation=U(h,"rotation",0),o.scaleX=U(h,"scaleX",1),o.scaleY=U(h,"scaleY",1),o.shearX=U(h,"shearX",0),o.shearY=U(h,"shearY",0),o.transformMode=mt.enumValue(Yn,U(h,"transform","Normal")),o.skinRequired=U(h,"skin",!1);const d=U(h,"color",null);d&&o.color.setFromString(d),s.bones.push(o)}if(n.slots)for(let l=0;l<n.slots.length;l++){const h=n.slots[l],i=s.findBone(h.bone);if(!i)throw new Error(`Couldn't find bone ${h.bone} for slot ${h.name}`);const a=new rd(s.slots.length,h.name,i),o=U(h,"color",null);o&&a.color.setFromString(o);const d=U(h,"dark",null);d&&(a.darkColor=Dt.fromString(d)),a.attachmentName=U(h,"attachment",null),a.blendMode=Wx.blendModeFromString(U(h,"blend","normal")),s.slots.push(a)}if(n.ik)for(let l=0;l<n.ik.length;l++){const h=n.ik[l],i=new ad(h.name);i.order=U(h,"order",0),i.skinRequired=U(h,"skin",!1);for(let a=0;a<h.bones.length;a++){const o=h.bones[a],d=s.findBone(o);if(d==null)throw new Error(`IK bone not found: ${o}`);i.bones.push(d)}i.target=s.findBone(h.target),i.mix=U(h,"mix",1),i.softness=U(h,"softness",0)*e,i.bendDirection=U(h,"bendPositive",!0)?1:-1,i.compress=U(h,"compress",!1),i.stretch=U(h,"stretch",!1),i.uniform=U(h,"uniform",!1),s.ikConstraints.push(i)}if(n.transform)for(let l=0;l<n.transform.length;l++){const h=n.transform[l],i=new od(h.name);i.order=U(h,"order",0),i.skinRequired=U(h,"skin",!1);for(let d=0;d<h.bones.length;d++){const u=h.bones[d],m=s.findBone(u);if(!m)throw new Error(`Couldn't find bone ${u} for transform constraint ${h.name}.`);i.bones.push(m)}const a=h.target,o=s.findBone(a);if(!o)throw new Error(`Couldn't find target bone ${a} for transform constraint ${h.name}.`);i.target=o,i.local=U(h,"local",!1),i.relative=U(h,"relative",!1),i.offsetRotation=U(h,"rotation",0),i.offsetX=U(h,"x",0)*e,i.offsetY=U(h,"y",0)*e,i.offsetScaleX=U(h,"scaleX",0),i.offsetScaleY=U(h,"scaleY",0),i.offsetShearY=U(h,"shearY",0),i.mixRotate=U(h,"mixRotate",1),i.mixX=U(h,"mixX",1),i.mixY=U(h,"mixY",i.mixX),i.mixScaleX=U(h,"mixScaleX",1),i.mixScaleY=U(h,"mixScaleY",i.mixScaleX),i.mixShearY=U(h,"mixShearY",1),s.transformConstraints.push(i)}if(n.path)for(let l=0;l<n.path.length;l++){const h=n.path[l],i=new td(h.name);i.order=U(h,"order",0),i.skinRequired=U(h,"skin",!1);for(let d=0;d<h.bones.length;d++){const u=h.bones[d],m=s.findBone(u);if(!m)throw new Error(`Couldn't find bone ${u} for path constraint ${h.name}.`);i.bones.push(m)}const a=h.target,o=s.findSlot(a);if(!o)throw new Error(`Couldn't find target slot ${a} for path constraint ${h.name}.`);i.target=o,i.positionMode=mt.enumValue(ii,U(h,"positionMode","Percent")),i.spacingMode=mt.enumValue(fs,U(h,"spacingMode","Length")),i.rotateMode=mt.enumValue(yo,U(h,"rotateMode","Tangent")),i.offsetRotation=U(h,"rotation",0),i.position=U(h,"position",0),i.positionMode==ii.Fixed&&(i.position*=e),i.spacing=U(h,"spacing",0),(i.spacingMode==fs.Length||i.spacingMode==fs.Fixed)&&(i.spacing*=e),i.mixRotate=U(h,"mixRotate",1),i.mixX=U(h,"mixX",1),i.mixY=U(h,"mixY",i.mixX),s.pathConstraints.push(i)}if(n.skins)for(let l=0;l<n.skins.length;l++){const h=n.skins[l],i=new wh(h.name);if(h.bones)for(let a=0;a<h.bones.length;a++){const o=h.bones[a],d=s.findBone(o);if(!d)throw new Error(`Couldn't find bone ${o} for skin ${h.name}.`);i.bones.push(d)}if(h.ik)for(let a=0;a<h.ik.length;a++){const o=h.ik[a],d=s.findIkConstraint(o);if(!d)throw new Error(`Couldn't find IK constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}if(h.transform)for(let a=0;a<h.transform.length;a++){const o=h.transform[a],d=s.findTransformConstraint(o);if(!d)throw new Error(`Couldn't find transform constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}if(h.path)for(let a=0;a<h.path.length;a++){const o=h.path[a],d=s.findPathConstraint(o);if(!d)throw new Error(`Couldn't find path constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}for(const a in h.attachments){const o=s.findSlot(a);if(!o)throw new Error(`Couldn't find slot ${a} for skin ${h.name}.`);const d=h.attachments[a];for(const u in d){const m=this.readAttachment(d[u],i,o.index,u,s);m&&i.setAttachment(o.index,u,m)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let l=0,h=this.linkedMeshes.length;l<h;l++){const i=this.linkedMeshes[l],a=i.skin?s.findSkin(i.skin):s.defaultSkin;if(!a)throw new Error(`Skin not found: ${i.skin}`);const o=a.getAttachment(i.slotIndex,i.parent);if(!o)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.timelineAttachment=i.inheritTimeline?o:i.mesh,i.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,n.events)for(const l in n.events){const h=n.events[l],i=new hd(l);i.intValue=U(h,"int",0),i.floatValue=U(h,"float",0),i.stringValue=U(h,"string",""),i.audioPath=U(h,"audio",null),i.audioPath&&(i.volume=U(h,"volume",1),i.balance=U(h,"balance",0)),s.events.push(i)}if(n.animations)for(const l in n.animations){const h=n.animations[l];this.readAnimation(h,l,s)}return s}readAttachment(t,e,s,n,r){const l=this.scale;switch(n=U(t,"name",n),U(t,"type","region")){case"region":{const h=U(t,"path",n),i=this.readSequence(U(t,"sequence",null)),a=this.attachmentLoader.newRegionAttachment(e,n,h,i);if(!a)return null;a.path=h,a.x=U(t,"x",0)*l,a.y=U(t,"y",0)*l,a.scaleX=U(t,"scaleX",1),a.scaleY=U(t,"scaleY",1),a.rotation=U(t,"rotation",0),a.width=t.width*l,a.height=t.height*l,a.sequence=i;const o=U(t,"color",null);return o&&a.color.setFromString(o),a}case"boundingbox":{const h=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);const i=U(t,"color",null);return i&&h.color.setFromString(i),h}case"mesh":case"linkedmesh":{const h=U(t,"path",n),i=this.readSequence(U(t,"sequence",null)),a=this.attachmentLoader.newMeshAttachment(e,n,h,i);if(!a)return null;a.path=h;const o=U(t,"color",null);o&&a.color.setFromString(o),a.width=U(t,"width",0)*l,a.height=U(t,"height",0)*l,a.sequence=i;const d=U(t,"parent",null);if(d)return this.linkedMeshes.push(new SC(a,U(t,"skin",null),s,d,U(t,"timelines",!0))),a;const u=t.uvs;return this.readVertices(t,a,u.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(u),a.edges=U(t,"edges",null),a.hullLength=U(t,"hull",0)*2,a}case"path":{const h=this.attachmentLoader.newPathAttachment(e,n);if(!h)return null;h.closed=U(t,"closed",!1),h.constantSpeed=U(t,"constantSpeed",!0);const i=t.vertexCount;this.readVertices(t,h,i<<1);const a=mt.newArray(i/3,0);for(let d=0;d<t.lengths.length;d++)a[d]=t.lengths[d]*l;h.lengths=a;const o=U(t,"color",null);return o&&h.color.setFromString(o),h}case"point":{const h=this.attachmentLoader.newPointAttachment(e,n);if(!h)return null;h.x=U(t,"x",0)*l,h.y=U(t,"y",0)*l,h.rotation=U(t,"rotation",0);const i=U(t,"color",null);return i&&h.color.setFromString(i),h}case"clipping":{const h=this.attachmentLoader.newClippingAttachment(e,n);if(!h)return null;const i=U(t,"end",null);if(i!=null){const d=r.findSlot(i);if(d==null)throw new Error(`Clipping end slot not found: ${i}`);h.endSlot=d}const a=t.vertexCount;this.readVertices(t,h,a<<1);const o=U(t,"color",null);return o&&h.color.setFromString(o),h}}return null}readSequence(t){if(t==null)return null;const e=new Tc(U(t,"count",0));return e.start=U(t,"start",1),e.digits=U(t,"digits",0),e.setupIndex=U(t,"setup",0),e}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=mt.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const l=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),l.push(r[i+1]*n),l.push(r[i+2]*n),l.push(r[i+3])}e.bones=h,e.vertices=mt.toFloatArray(l)}readAnimation(t,e,s){const n=this.scale,r=new Array;if(t.slots)for(const h in t.slots){const i=t.slots[h],a=s.findSlot(h);if(!a)throw new Error(`Slot not found: ${h}`);const o=a.index;for(const d in i){const u=i[d];if(!u)continue;const m=u.length;if(d=="attachment"){const c=new Da(m,o);for(let g=0;g<m;g++){const p=u[g];c.setFrame(g,U(p,"time",0),U(p,"name",null))}r.push(c)}else if(d=="rgba"){const c=new Nc(m,m<<2,o);let g=u[0],p=U(g,"time",0),y=Dt.fromString(g.color);for(let w=0,x=0;;w++){c.setFrame(w,p,y.r,y.g,y.b,y.a);const b=u[w+1];if(!b){c.shrink(x);break}const S=U(b,"time",0),C=Dt.fromString(b.color),v=g.curve;v&&(x=Zt(v,c,x,w,0,p,S,y.r,C.r,1),x=Zt(v,c,x,w,1,p,S,y.g,C.g,1),x=Zt(v,c,x,w,2,p,S,y.b,C.b,1),x=Zt(v,c,x,w,3,p,S,y.a,C.a,1)),p=S,y=C,g=b}r.push(c)}else if(d=="rgb"){const c=new Vc(m,m*3,o);let g=u[0],p=U(g,"time",0),y=Dt.fromString(g.color);for(let w=0,x=0;;w++){c.setFrame(w,p,y.r,y.g,y.b);const b=u[w+1];if(!b){c.shrink(x);break}const S=U(b,"time",0),C=Dt.fromString(b.color),v=g.curve;v&&(x=Zt(v,c,x,w,0,p,S,y.r,C.r,1),x=Zt(v,c,x,w,1,p,S,y.g,C.g,1),x=Zt(v,c,x,w,2,p,S,y.b,C.b,1)),p=S,y=C,g=b}r.push(c)}else if(d=="alpha")r.push(Or(u,new _c(m,m,o),0,1));else if(d=="rgba2"){const c=new Dc(m,m*7,o);let g=u[0],p=U(g,"time",0),y=Dt.fromString(g.light),w=Dt.fromString(g.dark);for(let x=0,b=0;;x++){c.setFrame(x,p,y.r,y.g,y.b,y.a,w.r,w.g,w.b);const S=u[x+1];if(!S){c.shrink(b);break}const C=U(S,"time",0),v=Dt.fromString(S.light),A=Dt.fromString(S.dark),M=g.curve;M&&(b=Zt(M,c,b,x,0,p,C,y.r,v.r,1),b=Zt(M,c,b,x,1,p,C,y.g,v.g,1),b=Zt(M,c,b,x,2,p,C,y.b,v.b,1),b=Zt(M,c,b,x,3,p,C,y.a,v.a,1),b=Zt(M,c,b,x,4,p,C,w.r,A.r,1),b=Zt(M,c,b,x,5,p,C,w.g,A.g,1),b=Zt(M,c,b,x,6,p,C,w.b,A.b,1)),p=C,y=v,w=A,g=S}r.push(c)}else if(d=="rgb2"){const c=new Lc(m,m*6,o);let g=u[0],p=U(g,"time",0),y=Dt.fromString(g.light),w=Dt.fromString(g.dark);for(let x=0,b=0;;x++){c.setFrame(x,p,y.r,y.g,y.b,w.r,w.g,w.b);const S=u[x+1];if(!S){c.shrink(b);break}const C=U(S,"time",0),v=Dt.fromString(S.light),A=Dt.fromString(S.dark),M=g.curve;M&&(b=Zt(M,c,b,x,0,p,C,y.r,v.r,1),b=Zt(M,c,b,x,1,p,C,y.g,v.g,1),b=Zt(M,c,b,x,2,p,C,y.b,v.b,1),b=Zt(M,c,b,x,3,p,C,w.r,A.r,1),b=Zt(M,c,b,x,4,p,C,w.g,A.g,1),b=Zt(M,c,b,x,5,p,C,w.b,A.b,1)),p=C,y=v,w=A,g=S}r.push(c)}}}if(t.bones)for(const h in t.bones){const i=t.bones[h],a=s.findBone(h);if(!a)throw new Error(`Bone not found: ${h}`);const o=a.index;for(const d in i){const u=i[d],m=u.length;if(m!=0){if(d==="rotate")r.push(Or(u,new gl(m,m,o),0,1));else if(d==="translate"){const c=new Ic(m,m<<1,o);r.push(ud(u,c,"x","y",0,n))}else if(d==="translatex"){const c=new kc(m,m,o);r.push(Or(u,c,0,n))}else if(d==="translatey"){const c=new Pc(m,m,o);r.push(Or(u,c,0,n))}else if(d==="scale"){const c=new Rc(m,m<<1,o);r.push(ud(u,c,"x","y",1,1))}else if(d==="scalex"){const c=new Yc(m,m,o);r.push(Or(u,c,1,1))}else if(d==="scaley"){const c=new Fc(m,m,o);r.push(Or(u,c,1,1))}else if(d==="shear"){const c=new Bc(m,m<<1,o);r.push(ud(u,c,"x","y",0,1))}else if(d==="shearx"){const c=new Xc(m,m,o);r.push(Or(u,c,0,1))}else if(d==="sheary"){const c=new $c(m,m,o);r.push(Or(u,c,0,1))}}}}if(t.ik)for(const h in t.ik){const i=t.ik[h];let a=i[0];if(!a)continue;const o=s.findIkConstraint(h);if(!o)throw new Error(`IK Constraint not found: ${h}`);const d=s.ikConstraints.indexOf(o),u=new Wc(i.length,i.length<<1,d);let m=U(a,"time",0),c=U(a,"mix",1),g=U(a,"softness",0)*n;for(let p=0,y=0;;p++){u.setFrame(p,m,c,g,U(a,"bendPositive",!0)?1:-1,U(a,"compress",!1),U(a,"stretch",!1));const w=i[p+1];if(!w){u.shrink(y);break}const x=U(w,"time",0),b=U(w,"mix",1),S=U(w,"softness",0)*n,C=a.curve;C&&(y=Zt(C,u,y,p,0,m,x,c,b,1),y=Zt(C,u,y,p,1,m,x,g,S,n)),m=x,c=b,g=S,a=w}r.push(u)}if(t.transform)for(const h in t.transform){const i=t.transform[h];let a=i[0];if(!a)continue;const o=s.findTransformConstraint(h);if(!o)throw new Error(`Transform constraint not found: ${h}`);const d=s.transformConstraints.indexOf(o),u=new Uc(i.length,i.length*6,d);let m=U(a,"time",0),c=U(a,"mixRotate",1),g=U(a,"mixX",1),p=U(a,"mixY",g),y=U(a,"mixScaleX",1),w=U(a,"mixScaleY",y);const x=U(a,"mixShearY",1);for(let b=0,S=0;;b++){u.setFrame(b,m,c,g,p,y,w,x);const C=i[b+1];if(!C){u.shrink(S);break}const v=U(C,"time",0),A=U(C,"mixRotate",1),M=U(C,"mixX",1),I=U(C,"mixY",M),E=U(C,"mixScaleX",1),P=U(C,"mixScaleY",E),R=U(C,"mixShearY",1),k=a.curve;k&&(S=Zt(k,u,S,b,0,m,v,c,A,1),S=Zt(k,u,S,b,1,m,v,g,M,1),S=Zt(k,u,S,b,2,m,v,p,I,1),S=Zt(k,u,S,b,3,m,v,y,E,1),S=Zt(k,u,S,b,4,m,v,w,P,1),S=Zt(k,u,S,b,5,m,v,x,R,1)),m=v,c=A,g=M,p=I,y=E,w=P,y=E,a=C}r.push(u)}if(t.path)for(const h in t.path){const i=t.path[h],a=s.findPathConstraint(h);if(!a)throw new Error(`Path constraint not found: ${h}`);const o=s.pathConstraints.indexOf(a);for(const d in i){const u=i[d];let m=u[0];if(!m)continue;const c=u.length;if(d==="position"){const g=new qc(c,c,o);r.push(Or(u,g,0,a.positionMode==ii.Fixed?n:1))}else if(d==="spacing"){const g=new zc(c,c,o);r.push(Or(u,g,0,a.spacingMode==fs.Length||a.spacingMode==fs.Fixed?n:1))}else if(d==="mix"){const g=new Gc(c,c*3,o);let p=U(m,"time",0),y=U(m,"mixRotate",1),w=U(m,"mixX",1),x=U(m,"mixY",w);for(let b=0,S=0;;b++){g.setFrame(b,p,y,w,x);const C=u[b+1];if(!C){g.shrink(S);break}const v=U(C,"time",0),A=U(C,"mixRotate",1),M=U(C,"mixX",1),I=U(C,"mixY",M),E=m.curve;E&&(S=Zt(E,g,S,b,0,p,v,y,A,1),S=Zt(E,g,S,b,1,p,v,w,M,1),S=Zt(E,g,S,b,2,p,v,x,I,1)),p=v,y=A,w=M,x=I,m=C}r.push(g)}}}if(t.deform){t.attachments={};for(const h in t.deform){const i=t.deform[h],a=t.attachments[h]={};for(const o in i){const d=i[o],u=a[o]={};for(const m in d)u[m]={deform:d[m]}}}}if(t.attachments)for(const h in t.attachments){const i=t.attachments[h],a=s.findSkin(h);if(a!=null)for(const o in i){const d=i[o],u=s.findSlot(o);if(!u)throw new Error(`Slot not found: ${o}`);const m=u.index;for(const c in d){const g=d[c],p=a.getAttachment(m,c);for(const y in g){const w=g[y];let x=w[0];if(x){if(y=="deform"){const b=p.bones,S=p.vertices,C=b?S.length/3*2:S.length,v=new Oc(w.length,w.length,m,p);let A=U(x,"time",0);for(let M=0,I=0;;M++){let E;const P=U(x,"vertices",null);if(!P)E=b?mt.newFloatArray(C):S;else{E=mt.newFloatArray(C);const F=U(x,"offset",0);if(mt.arrayCopy(P,0,E,F,P.length),n!=1)for(let X=F,W=X+P.length;X<W;X++)E[X]*=n;if(!b)for(let X=0;X<C;X++)E[X]+=S[X]}v.setFrame(M,A,E);const R=w[M+1];if(!R){v.shrink(I);break}const k=U(R,"time",0),Y=x.curve;Y&&(I=Zt(Y,v,I,M,0,A,k,0,1,1)),A=k,x=R}r.push(v)}else if(y=="sequence"){const b=new Hc(w.length,m,p);let S=0;for(let C=0;C<w.length;C++){const v=U(x,"delay",S),A=U(x,"time",0),M=Dr[U(x,"mode","hold")],I=U(x,"index",0);b.setFrame(C,A,M,I,v),S=v,x=w[C+1]}r.push(b)}}}}}}if(t.drawOrder){const h=new wo(t.drawOrder.length),i=s.slots.length;let a=0;for(let o=0;o<t.drawOrder.length;o++,a++){const d=t.drawOrder[o];let u=null;const m=U(d,"offsets",null);if(m){u=mt.newArray(i,-1);const c=mt.newArray(i-m.length,0);let g=0,p=0;for(let y=0;y<m.length;y++){const w=m[y],x=s.findSlot(w.slot);if(!x)throw new Error(`Slot not found: ${x}`);const b=x.index;for(;g!=b;)c[p++]=g++;u[g+w.offset]=g++}for(;g<i;)c[p++]=g++;for(let y=i-1;y>=0;y--)u[y]==-1&&(u[y]=c[--p])}h.setFrame(a,U(d,"time",0),u)}r.push(h)}if(t.events){const h=new mh(t.events.length);let i=0;for(let a=0;a<t.events.length;a++,i++){const o=t.events[a],d=s.findEvent(o.name);if(!d)throw new Error(`Event not found: ${o.name}`);const u=new sd(mt.toSinglePrecision(U(o,"time",0)),d);u.intValue=U(o,"int",d.intValue),u.floatValue=U(o,"float",d.floatValue),u.stringValue=U(o,"string",d.stringValue),u.data.audioPath&&(u.volume=U(o,"volume",1),u.balance=U(o,"balance",0)),h.setFrame(i,u)}r.push(h)}let l=0;for(let h=0,i=r.length;h<i;h++)l=Math.max(l,r[h].getDuration());if(isNaN(l))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new uh(e,r,l))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return V.BLEND_MODES.NORMAL;if(t=="additive")return V.BLEND_MODES.ADD;if(t=="multiply")return V.BLEND_MODES.MULTIPLY;if(t=="screen")return V.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}},SC=class{constructor(t,e,s,n,r){Ki(this,"parent"),Ki(this,"skin"),Ki(this,"slotIndex"),Ki(this,"mesh"),Ki(this,"inheritTimeline"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}};function Or(f,t,e,s){let n=f[0],r=U(n,"time",0),l=U(n,"value",e)*s,h=0;for(let i=0;;i++){t.setFrame(i,r,l);const a=f[i+1];if(!a)return t.shrink(h),t;const o=U(a,"time",0),d=U(a,"value",e)*s;n.curve&&(h=Zt(n.curve,t,h,i,0,r,o,l,d,s)),r=o,l=d,n=a}}function ud(f,t,e,s,n,r){let l=f[0],h=U(l,"time",0),i=U(l,e,n)*r,a=U(l,s,n)*r,o=0;for(let d=0;;d++){t.setFrame(d,h,i,a);const u=f[d+1];if(!u)return t.shrink(o),t;const m=U(u,"time",0),c=U(u,e,n)*r,g=U(u,s,n)*r,p=l.curve;p&&(o=Zt(p,t,o,d,0,h,m,i,c,r),o=Zt(p,t,o,d,1,h,m,a,g,r)),h=m,i=c,a=g,l=u}}function Zt(f,t,e,s,n,r,l,h,i,a){if(f=="stepped")return t.setStepped(s),e;const o=n<<2,d=f[o],u=f[o+1]*a,m=f[o+2],c=f[o+3]*a;return t.setBezier(e,s,n,r,h,d,u,m,c,l,i),e+1}function U(f,t,e){return f[t]!==void 0?f[t]:e}var CC=Object.defineProperty,vC=(f,t,e)=>t in f?CC(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ug=(f,t,e)=>vC(f,typeof t!="symbol"?t+"":t,e);class AC{constructor(){Ug(this,"scale",1)}readSkeletonData(t,e){let s=null,n=this.readVersionOldFormat(e),r=Uo(n);if(r===Js.VER38&&(s=new dg(new uc(t))),n=this.readVersionNewFormat(e),r=Uo(n),(r===Js.VER40||r===Js.VER41)&&(s=new cd(new jc(t))),!s){const l=`Unsupported version of spine model ${n}, please update pixi-spine`;console.error(l)}return s.scale=this.scale,s.readSkeletonData(e)}readVersionOldFormat(t){const e=new Wf(t);let s;try{e.readString(),s=e.readString()}catch(n){s=""}return s||""}readVersionNewFormat(t){const e=new Wf(t);e.readInt32(),e.readInt32();let s;try{s=e.readString()}catch(n){s=""}return s||""}}class MC{constructor(){Ug(this,"scale",1)}readSkeletonData(t,e){const s=e.skeleton.spine,n=Uo(s);let r=null;if(n===Js.VER37&&(r=new Nm(new Sm(t))),n===Js.VER38&&(r=new ug(new uc(t))),(n===Js.VER40||n===Js.VER41)&&(r=new Wg(new jc(t))),!r){const l=`Unsupported version of spine model ${s}, please update pixi-spine`;console.error(l)}return r.scale=this.scale,r.readSkeletonData(e)}}class TC extends Ob{createBinaryParser(){return new AC}createJsonParser(){return new MC}parseData(t,e,s){return{spineData:t.readSkeletonData(e,s),spineAtlas:e}}}if(typeof window!="undefined"&&window.PIXI){let f=window.require;window.require=t=>{if(f)return f(t);if(t.startsWith("@pixi/"))return window.PIXI}}let EC=class{constructor(){T(this,"array",new Array)}add(t){let e=this.contains(t);return this.array[t|0]=t|0,!e}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}},fd=class{constructor(){T(this,"entries",{});T(this,"size",0)}add(t){let e=this.entries[t];return this.entries[t]=!0,e?!1:(this.size++,!0)}addAll(t){let e=this.size;for(var s=0,n=t.length;s<n;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}},Yt=(Ks=class{constructor(t=0,e=0,s=0,n=0){T(this,"r");T(this,"g");T(this,"b");T(this,"a");this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}toRgb888(){const t=e=>("0"+(e*255).toString(16)).slice(-2);return+("0x"+t(this.r)+t(this.g)+t(this.b))}static fromString(t,e=new Ks){return e.setFromString(t)}},T(Ks,"WHITE",new Ks(1,1,1,1)),T(Ks,"RED",new Ks(1,0,0,1)),T(Ks,"GREEN",new Ks(0,1,0,1)),T(Ks,"BLUE",new Ks(0,0,1,1)),T(Ks,"MAGENTA",new Ks(1,0,1,1)),Ks),ot=(Re=class{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Re.degRad)}static sinDeg(t){return Math.sin(t*Re.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Re.degRad}static signum(t){return t>0?1:t<0?-1:0}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){let e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Re.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){let n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}},T(Re,"PI",3.1415927),T(Re,"PI2",Re.PI*2),T(Re,"invPI2",1/Re.PI2),T(Re,"radiansToDegrees",180/Re.PI),T(Re,"radDeg",Re.radiansToDegrees),T(Re,"degreesToRadians",Re.PI/180),T(Re,"degRad",Re.degreesToRadians),Re),qg=class{apply(t,e,s){return t+(e-t)*this.applyInternal(s)}},zg=class extends qg{constructor(e){super();T(this,"power",2);this.power=e}applyInternal(e){return e<=.5?Math.pow(e*2,this.power)/2:Math.pow((e-1)*2,this.power)/(this.power%2==0?-2:2)+1}},IC=class extends zg{constructor(t){super(t)}applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}},ht=(Mr=class{static arrayCopy(t,e,s,n,r){for(let l=e,h=n;l<e+r;l++,h++)s[h]=t[l]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){let n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Mr.setArraySize(t,e,s)}static newArray(t,e){let s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Mr.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);{let e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}}static newShortArray(t){if(Mr.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);{let e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}}static toFloatArray(t){return Mr.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Mr.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(var n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}},T(Mr,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined"),Mr),kC=class{static logBones(t){for(let e=0;e<t.bones.length;e++){let s=t.bones[e];console.log(s.data.name+", "+s.a+", "+s.b+", "+s.c+", "+s.d+", "+s.worldX+", "+s.worldY)}}},So=class{constructor(t){T(this,"items",new Array);T(this,"instantiator");this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},Sl=class{constructor(t=0,e=0){T(this,"x");T(this,"y");this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){let t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){let t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}},PC=class{constructor(){T(this,"maxDelta",.064);T(this,"framesPerSecond",0);T(this,"delta",0);T(this,"totalTime",0);T(this,"lastTime",Date.now()/1e3);T(this,"frameCount",0);T(this,"frameTime",0)}update(){let t=Date.now()/1e3;this.delta=t-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=t,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}},RC=class{constructor(t=32){T(this,"values");T(this,"addedValues",0);T(this,"lastValue",0);T(this,"mean",0);T(this,"dirty",!0);this.values=new Array(t)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(t){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=t,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let t=0;for(let e=0;e<this.values.length;e++)t+=this.values[e];this.mean=t/this.values.length,this.dirty=!1}return this.mean}return 0}},md=class{constructor(t){T(this,"name");if(!t)throw new Error("name cannot be null.");this.name=t}},Wr=(ho=class extends md{constructor(e){super(e);T(this,"id",ho.nextID++);T(this,"bones",null);T(this,"vertices",[]);T(this,"worldVerticesLength",0);T(this,"timelineAttachment",this)}computeWorldVertices(e,s,n,r,l,h){n=l+(n>>1)*h;let i=e.bone.skeleton,a=e.deform,o=this.vertices,d=this.bones;if(!d){a.length>0&&(o=a);let g=e.bone,p=g.worldX,y=g.worldY,w=g.a,x=g.b,b=g.c,S=g.d;for(let C=s,v=l;v<n;C+=2,v+=h){let A=o[C],M=o[C+1];r[v]=A*w+M*x+p,r[v+1]=A*b+M*S+y}return}let u=0,m=0;for(let g=0;g<s;g+=2){let p=d[u];u+=p+1,m+=p}let c=i.bones;if(a.length==0)for(let g=l,p=m*3;g<n;g+=h){let y=0,w=0,x=d[u++];for(x+=u;u<x;u++,p+=3){let b=c[d[u]],S=o[p],C=o[p+1],v=o[p+2];y+=(S*b.a+C*b.b+b.worldX)*v,w+=(S*b.c+C*b.d+b.worldY)*v}r[g]=y,r[g+1]=w}else{let g=a;for(let p=l,y=m*3,w=m<<1;p<n;p+=h){let x=0,b=0,S=d[u++];for(S+=u;u<S;u++,y+=3,w+=2){let C=c[d[u]],v=o[y]+g[w],A=o[y+1]+g[w+1],M=o[y+2];x+=(v*C.a+A*C.b+C.worldX)*M,b+=(v*C.c+A*C.d+C.worldY)*M}r[p]=x,r[p+1]=b}}}copyTo(e){this.bones?(e.bones=new Array(this.bones.length),ht.arrayCopy(this.bones,0,e.bones,0,this.bones.length)):e.bones=null,this.vertices&&(e.vertices=ht.newFloatArray(this.vertices.length),ht.arrayCopy(this.vertices,0,e.vertices,0,this.vertices.length)),e.worldVerticesLength=this.worldVerticesLength,e.timelineAttachment=this.timelineAttachment}},T(ho,"nextID",0),ho),Gg=(Si=class{constructor(t){T(this,"id",Si.nextID());T(this,"regions");T(this,"start",0);T(this,"digits",0);T(this,"setupIndex",0);this.regions=new Array(t)}copy(){let t=new Si(this.regions.length);return ht.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,e){let s=t.sequenceIndex;s==-1&&(s=this.setupIndex),s>=this.regions.length&&(s=this.regions.length-1);let n=this.regions[s];e.region!=n&&(e.region=n,e.updateRegion())}getPath(t,e){let s=t,n=(this.start+e).toString();for(let r=this.digits-n.length;r>0;r--)s+="0";return s+=n,s}static nextID(){return Si._nextID++}},T(Si,"_nextID",0),Si);var Fs;(function(f){f[f.hold=0]="hold",f[f.once=1]="once",f[f.loop=2]="loop",f[f.pingpong=3]="pingpong",f[f.onceReverse=4]="onceReverse",f[f.loopReverse=5]="loopReverse",f[f.pingpongReverse=6]="pingpongReverse"})(Fs||(Fs={}));const Hg=[Fs.hold,Fs.once,Fs.loop,Fs.pingpong,Fs.onceReverse,Fs.loopReverse,Fs.pingpongReverse];let yh=class{constructor(t,e,s){T(this,"name");T(this,"timelines",[]);T(this,"timelineIds",new fd);T(this,"duration");if(!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(e),this.duration=s}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(var e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,s,n,r,l,h,i){if(!t)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));let a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,l,h,i)}};var J;(function(f){f[f.setup=0]="setup",f[f.first=1]="first",f[f.replace=2]="replace",f[f.add=3]="add"})(J||(J={}));var Bs;(function(f){f[f.mixIn=0]="mixIn",f[f.mixOut=1]="mixOut"})(Bs||(Bs={}));const $t={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,inherit:7,rgb:8,alpha:9,rgb2:10,attachment:11,deform:12,event:13,drawOrder:14,ikConstraint:15,transformConstraint:16,pathConstraintPosition:17,pathConstraintSpacing:18,pathConstraintMix:19,physicsConstraintInertia:20,physicsConstraintStrength:21,physicsConstraintDamping:22,physicsConstraintMass:23,physicsConstraintWind:24,physicsConstraintGravity:25,physicsConstraintMix:26,physicsConstraintReset:27,sequence:28};let pe=class{constructor(t,e){T(this,"propertyIds");T(this,"frames");this.propertyIds=e,this.frames=ht.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){let s=t.length;for(let n=1;n<s;n++)if(t[n]>e)return n-1;return s-1}static search(t,e,s){let n=t.length;for(let r=s;r<n;r+=s)if(t[r]>e)return r-s;return n-s}},hr=class extends pe{constructor(e,s,n){super(e,n);T(this,"curves");this.curves=ht.newFloatArray(e+s*18),this.curves[e-1]=1}setLinear(e){this.curves[e]=0}setStepped(e){this.curves[e]=1}shrink(e){let s=this.getFrameCount()+e*18;if(this.curves.length>s){let n=ht.newFloatArray(s);ht.arrayCopy(this.curves,0,n,0,s),this.curves=n}}setBezier(e,s,n,r,l,h,i,a,o,d,u){let m=this.curves,c=this.getFrameCount()+e*18;n==0&&(m[s]=2+c);let g=(r-h*2+a)*.03,p=(l-i*2+o)*.03,y=((h-a)*3-r+d)*.006,w=((i-o)*3-l+u)*.006,x=g*2+y,b=p*2+w,S=(h-r)*.3+g+y*.16666667,C=(i-l)*.3+p+w*.16666667,v=r+S,A=l+C;for(let M=c+18;c<M;c+=2)m[c]=v,m[c+1]=A,S+=x,C+=b,x+=y,b+=w,v+=S,A+=C}getBezierValue(e,s,n,r){let l=this.curves;if(l[r]>e){let o=this.frames[s],d=this.frames[s+n];return d+(e-o)/(l[r]-o)*(l[r+1]-d)}let h=r+18;for(r+=2;r<h;r+=2)if(l[r]>=e){let o=l[r-2],d=l[r-1];return d+(e-o)/(l[r]-o)*(l[r+1]-d)}s+=this.getFrameEntries();let i=l[h-2],a=l[h-1];return a+(e-i)/(this.frames[s]-i)*(this.frames[s+n]-a)}},Wn=class extends hr{constructor(t,e,s){super(t,e,[s])}getFrameEntries(){return 2}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+1]=s}getCurveValue(t){let e=this.frames,s=e.length-2;for(let r=2;r<=s;r+=2)if(e[r]>t){s=r-2;break}let n=this.curves[s>>1];switch(n){case 0:let r=e[s],l=e[s+1];return l+(t-r)/(e[s+2]-r)*(e[s+2+1]-l);case 1:return e[s+1]}return this.getBezierValue(t,s,1,n-2)}getRelativeValue(t,e,s,n,r){if(t<this.frames[0]){switch(s){case J.setup:return r;case J.first:return n+(r-n)*e}return n}let l=this.getCurveValue(t);switch(s){case J.setup:return r+l*e;case J.first:case J.replace:l+=r-n}return n+l*e}getAbsoluteValue(t,e,s,n,r){if(t<this.frames[0]){switch(s){case J.setup:return r;case J.first:return n+(r-n)*e}return n}let l=this.getCurveValue(t);return s==J.setup?r+(l-r)*e:n+(l-n)*e}getAbsoluteValue2(t,e,s,n,r,l){if(t<this.frames[0]){switch(s){case J.setup:return r;case J.first:return n+(r-n)*e}return n}return s==J.setup?r+(l-r)*e:n+(l-n)*e}getScaleValue(t,e,s,n,r,l){const h=this.frames;if(t<h[0]){switch(s){case J.setup:return l;case J.first:return r+(l-r)*e}return r}let i=this.getCurveValue(t)*l;if(e==1)return s==J.add?r+i-l:i;if(n==Bs.mixOut)switch(s){case J.setup:return l+(Math.abs(i)*ot.signum(l)-l)*e;case J.first:case J.replace:return r+(Math.abs(i)*ot.signum(r)-r)*e}else{let a=0;switch(s){case J.setup:return a=Math.abs(l)*ot.signum(i),a+(i-a)*e;case J.first:case J.replace:return a=Math.abs(r)*ot.signum(i),a+(i-a)*e}}return r+(i-l)*e}},Sh=class extends hr{constructor(t,e,s,n){super(t,e,[s,n])}getFrameEntries(){return 3}setFrame(t,e,s,n){t*=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n}},Cl=class extends Wn{constructor(e,s,n){super(e,s,$t.rotate+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];a.active&&(a.rotation=this.getRelativeValue(n,l,h,a.rotation,a.data.rotation))}},gd=class extends Sh{constructor(e,s,n){super(e,s,$t.x+"|"+n,$t.y+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];if(!a.active)return;let o=this.frames;if(n<o[0]){switch(h){case J.setup:a.x=a.data.x,a.y=a.data.y;return;case J.first:a.x+=(a.data.x-a.x)*l,a.y+=(a.data.y-a.y)*l}return}let d=0,u=0,m=pe.search(o,n,3),c=this.curves[m/3];switch(c){case 0:let g=o[m];d=o[m+1],u=o[m+2];let p=(n-g)/(o[m+3]-g);d+=(o[m+3+1]-d)*p,u+=(o[m+3+2]-u)*p;break;case 1:d=o[m+1],u=o[m+2];break;default:d=this.getBezierValue(n,m,1,c-2),u=this.getBezierValue(n,m,2,c+18-2)}switch(h){case J.setup:a.x=a.data.x+d*l,a.y=a.data.y+u*l;break;case J.first:case J.replace:a.x+=(a.data.x+d-a.x)*l,a.y+=(a.data.y+u-a.y)*l;break;case J.add:a.x+=d*l,a.y+=u*l}}},pd=class extends Wn{constructor(e,s,n){super(e,s,$t.x+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];a.active&&(a.x=this.getRelativeValue(n,l,h,a.x,a.data.x))}},xd=class extends Wn{constructor(e,s,n){super(e,s,$t.y+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];a.active&&(a.y=this.getRelativeValue(n,l,h,a.y,a.data.y))}},bd=class extends Sh{constructor(e,s,n){super(e,s,$t.scaleX+"|"+n,$t.scaleY+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];if(!a.active)return;let o=this.frames;if(n<o[0]){switch(h){case J.setup:a.scaleX=a.data.scaleX,a.scaleY=a.data.scaleY;return;case J.first:a.scaleX+=(a.data.scaleX-a.scaleX)*l,a.scaleY+=(a.data.scaleY-a.scaleY)*l}return}let d,u,m=pe.search(o,n,3),c=this.curves[m/3];switch(c){case 0:let g=o[m];d=o[m+1],u=o[m+2];let p=(n-g)/(o[m+3]-g);d+=(o[m+3+1]-d)*p,u+=(o[m+3+2]-u)*p;break;case 1:d=o[m+1],u=o[m+2];break;default:d=this.getBezierValue(n,m,1,c-2),u=this.getBezierValue(n,m,2,c+18-2)}if(d*=a.data.scaleX,u*=a.data.scaleY,l==1)h==J.add?(a.scaleX+=d-a.data.scaleX,a.scaleY+=u-a.data.scaleY):(a.scaleX=d,a.scaleY=u);else{let g=0,p=0;if(i==Bs.mixOut)switch(h){case J.setup:g=a.data.scaleX,p=a.data.scaleY,a.scaleX=g+(Math.abs(d)*ot.signum(g)-g)*l,a.scaleY=p+(Math.abs(u)*ot.signum(p)-p)*l;break;case J.first:case J.replace:g=a.scaleX,p=a.scaleY,a.scaleX=g+(Math.abs(d)*ot.signum(g)-g)*l,a.scaleY=p+(Math.abs(u)*ot.signum(p)-p)*l;break;case J.add:a.scaleX+=(d-a.data.scaleX)*l,a.scaleY+=(u-a.data.scaleY)*l}else switch(h){case J.setup:g=Math.abs(a.data.scaleX)*ot.signum(d),p=Math.abs(a.data.scaleY)*ot.signum(u),a.scaleX=g+(d-g)*l,a.scaleY=p+(u-p)*l;break;case J.first:case J.replace:g=Math.abs(a.scaleX)*ot.signum(d),p=Math.abs(a.scaleY)*ot.signum(u),a.scaleX=g+(d-g)*l,a.scaleY=p+(u-p)*l;break;case J.add:a.scaleX+=(d-a.data.scaleX)*l,a.scaleY+=(u-a.data.scaleY)*l}}}},wd=class extends Wn{constructor(e,s,n){super(e,s,$t.scaleX+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];a.active&&(a.scaleX=this.getScaleValue(n,l,h,i,a.scaleX,a.data.scaleX))}},yd=class extends Wn{constructor(e,s,n){super(e,s,$t.scaleY+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];a.active&&(a.scaleY=this.getScaleValue(n,l,h,i,a.scaleY,a.data.scaleY))}},Sd=class extends Sh{constructor(e,s,n){super(e,s,$t.shearX+"|"+n,$t.shearY+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];if(!a.active)return;let o=this.frames;if(n<o[0]){switch(h){case J.setup:a.shearX=a.data.shearX,a.shearY=a.data.shearY;return;case J.first:a.shearX+=(a.data.shearX-a.shearX)*l,a.shearY+=(a.data.shearY-a.shearY)*l}return}let d=0,u=0,m=pe.search(o,n,3),c=this.curves[m/3];switch(c){case 0:let g=o[m];d=o[m+1],u=o[m+2];let p=(n-g)/(o[m+3]-g);d+=(o[m+3+1]-d)*p,u+=(o[m+3+2]-u)*p;break;case 1:d=o[m+1],u=o[m+2];break;default:d=this.getBezierValue(n,m,1,c-2),u=this.getBezierValue(n,m,2,c+18-2)}switch(h){case J.setup:a.shearX=a.data.shearX+d*l,a.shearY=a.data.shearY+u*l;break;case J.first:case J.replace:a.shearX+=(a.data.shearX+d-a.shearX)*l,a.shearY+=(a.data.shearY+u-a.shearY)*l;break;case J.add:a.shearX+=d*l,a.shearY+=u*l}}},Cd=class extends Wn{constructor(e,s,n){super(e,s,$t.shearX+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];a.active&&(a.shearX=this.getRelativeValue(n,l,h,a.shearX,a.data.shearX))}},vd=class extends Wn{constructor(e,s,n){super(e,s,$t.shearY+"|"+n);T(this,"boneIndex",0);this.boneIndex=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];a.active&&(a.shearY=this.getRelativeValue(n,l,h,a.shearY,a.data.shearY))}};class Ad extends pe{constructor(e,s){super(e,[$t.inherit+"|"+s]);T(this,"boneIndex",0);this.boneIndex=s}getFrameEntries(){return 2}setFrame(e,s,n){e*=2,this.frames[e]=s,this.frames[e+1]=n}apply(e,s,n,r,l,h,i){let a=e.bones[this.boneIndex];if(!a.active)return;if(i==Bs.mixOut){h==J.setup&&(a.inherit=a.data.inherit);return}let o=this.frames;if(n<o[0]){(h==J.setup||h==J.first)&&(a.inherit=a.data.inherit);return}a.inherit=this.frames[pe.search(o,n,2)+1]}}let Md=class extends hr{constructor(e,s,n){super(e,s,[$t.rgb+"|"+n,$t.alpha+"|"+n]);T(this,"slotIndex",0);this.slotIndex=n}getFrameEntries(){return 5}setFrame(e,s,n,r,l,h){e*=5,this.frames[e]=s,this.frames[e+1]=n,this.frames[e+2]=r,this.frames[e+3]=l,this.frames[e+4]=h}apply(e,s,n,r,l,h,i){let a=e.slots[this.slotIndex];if(!a.bone.active)return;let o=this.frames,d=a.color;if(n<o[0]){let w=a.data.color;switch(h){case J.setup:d.setFromColor(w);return;case J.first:d.add((w.r-d.r)*l,(w.g-d.g)*l,(w.b-d.b)*l,(w.a-d.a)*l)}return}let u=0,m=0,c=0,g=0,p=pe.search(o,n,5),y=this.curves[p/5];switch(y){case 0:let w=o[p];u=o[p+1],m=o[p+2],c=o[p+3],g=o[p+4];let x=(n-w)/(o[p+5]-w);u+=(o[p+5+1]-u)*x,m+=(o[p+5+2]-m)*x,c+=(o[p+5+3]-c)*x,g+=(o[p+5+4]-g)*x;break;case 1:u=o[p+1],m=o[p+2],c=o[p+3],g=o[p+4];break;default:u=this.getBezierValue(n,p,1,y-2),m=this.getBezierValue(n,p,2,y+18-2),c=this.getBezierValue(n,p,3,y+18*2-2),g=this.getBezierValue(n,p,4,y+18*3-2)}l==1?d.set(u,m,c,g):(h==J.setup&&d.setFromColor(a.data.color),d.add((u-d.r)*l,(m-d.g)*l,(c-d.b)*l,(g-d.a)*l))}},Td=class extends hr{constructor(e,s,n){super(e,s,[$t.rgb+"|"+n]);T(this,"slotIndex",0);this.slotIndex=n}getFrameEntries(){return 4}setFrame(e,s,n,r,l){e<<=2,this.frames[e]=s,this.frames[e+1]=n,this.frames[e+2]=r,this.frames[e+3]=l}apply(e,s,n,r,l,h,i){let a=e.slots[this.slotIndex];if(!a.bone.active)return;let o=this.frames,d=a.color;if(n<o[0]){let y=a.data.color;switch(h){case J.setup:d.r=y.r,d.g=y.g,d.b=y.b;return;case J.first:d.r+=(y.r-d.r)*l,d.g+=(y.g-d.g)*l,d.b+=(y.b-d.b)*l}return}let u=0,m=0,c=0,g=pe.search(o,n,4),p=this.curves[g>>2];switch(p){case 0:let y=o[g];u=o[g+1],m=o[g+2],c=o[g+3];let w=(n-y)/(o[g+4]-y);u+=(o[g+4+1]-u)*w,m+=(o[g+4+2]-m)*w,c+=(o[g+4+3]-c)*w;break;case 1:u=o[g+1],m=o[g+2],c=o[g+3];break;default:u=this.getBezierValue(n,g,1,p-2),m=this.getBezierValue(n,g,2,p+18-2),c=this.getBezierValue(n,g,3,p+18*2-2)}if(l==1)d.r=u,d.g=m,d.b=c;else{if(h==J.setup){let y=a.data.color;d.r=y.r,d.g=y.g,d.b=y.b}d.r+=(u-d.r)*l,d.g+=(m-d.g)*l,d.b+=(c-d.b)*l}}},Ed=class extends Wn{constructor(e,s,n){super(e,s,$t.alpha+"|"+n);T(this,"slotIndex",0);this.slotIndex=n}apply(e,s,n,r,l,h,i){let a=e.slots[this.slotIndex];if(!a.bone.active)return;let o=a.color;if(n<this.frames[0]){let u=a.data.color;switch(h){case J.setup:o.a=u.a;return;case J.first:o.a+=(u.a-o.a)*l}return}let d=this.getCurveValue(n);l==1?o.a=d:(h==J.setup&&(o.a=a.data.color.a),o.a+=(d-o.a)*l)}},Id=class extends hr{constructor(e,s,n){super(e,s,[$t.rgb+"|"+n,$t.alpha+"|"+n,$t.rgb2+"|"+n]);T(this,"slotIndex",0);this.slotIndex=n}getFrameEntries(){return 8}setFrame(e,s,n,r,l,h,i,a,o){e<<=3,this.frames[e]=s,this.frames[e+1]=n,this.frames[e+2]=r,this.frames[e+3]=l,this.frames[e+4]=h,this.frames[e+5]=i,this.frames[e+6]=a,this.frames[e+7]=o}apply(e,s,n,r,l,h,i){let a=e.slots[this.slotIndex];if(!a.bone.active)return;let o=this.frames,d=a.color,u=a.darkColor;if(n<o[0]){let C=a.data.color,v=a.data.darkColor;switch(h){case J.setup:d.setFromColor(C),u.r=v.r,u.g=v.g,u.b=v.b;return;case J.first:d.add((C.r-d.r)*l,(C.g-d.g)*l,(C.b-d.b)*l,(C.a-d.a)*l),u.r+=(v.r-u.r)*l,u.g+=(v.g-u.g)*l,u.b+=(v.b-u.b)*l}return}let m=0,c=0,g=0,p=0,y=0,w=0,x=0,b=pe.search(o,n,8),S=this.curves[b>>3];switch(S){case 0:let C=o[b];m=o[b+1],c=o[b+2],g=o[b+3],p=o[b+4],y=o[b+5],w=o[b+6],x=o[b+7];let v=(n-C)/(o[b+8]-C);m+=(o[b+8+1]-m)*v,c+=(o[b+8+2]-c)*v,g+=(o[b+8+3]-g)*v,p+=(o[b+8+4]-p)*v,y+=(o[b+8+5]-y)*v,w+=(o[b+8+6]-w)*v,x+=(o[b+8+7]-x)*v;break;case 1:m=o[b+1],c=o[b+2],g=o[b+3],p=o[b+4],y=o[b+5],w=o[b+6],x=o[b+7];break;default:m=this.getBezierValue(n,b,1,S-2),c=this.getBezierValue(n,b,2,S+18-2),g=this.getBezierValue(n,b,3,S+18*2-2),p=this.getBezierValue(n,b,4,S+18*3-2),y=this.getBezierValue(n,b,5,S+18*4-2),w=this.getBezierValue(n,b,6,S+18*5-2),x=this.getBezierValue(n,b,7,S+18*6-2)}if(l==1)d.set(m,c,g,p),u.r=y,u.g=w,u.b=x;else{if(h==J.setup){d.setFromColor(a.data.color);let C=a.data.darkColor;u.r=C.r,u.g=C.g,u.b=C.b}d.add((m-d.r)*l,(c-d.g)*l,(g-d.b)*l,(p-d.a)*l),u.r+=(y-u.r)*l,u.g+=(w-u.g)*l,u.b+=(x-u.b)*l}}},kd=class extends hr{constructor(e,s,n){super(e,s,[$t.rgb+"|"+n,$t.rgb2+"|"+n]);T(this,"slotIndex",0);this.slotIndex=n}getFrameEntries(){return 7}setFrame(e,s,n,r,l,h,i,a){e*=7,this.frames[e]=s,this.frames[e+1]=n,this.frames[e+2]=r,this.frames[e+3]=l,this.frames[e+4]=h,this.frames[e+5]=i,this.frames[e+6]=a}apply(e,s,n,r,l,h,i){let a=e.slots[this.slotIndex];if(!a.bone.active)return;let o=this.frames,d=a.color,u=a.darkColor;if(n<o[0]){let S=a.data.color,C=a.data.darkColor;switch(h){case J.setup:d.r=S.r,d.g=S.g,d.b=S.b,u.r=C.r,u.g=C.g,u.b=C.b;return;case J.first:d.r+=(S.r-d.r)*l,d.g+=(S.g-d.g)*l,d.b+=(S.b-d.b)*l,u.r+=(C.r-u.r)*l,u.g+=(C.g-u.g)*l,u.b+=(C.b-u.b)*l}return}let m=0,c=0,g=0,p=0,y=0,w=0,x=pe.search(o,n,7),b=this.curves[x/7];switch(b){case 0:let S=o[x];m=o[x+1],c=o[x+2],g=o[x+3],p=o[x+4],y=o[x+5],w=o[x+6];let C=(n-S)/(o[x+7]-S);m+=(o[x+7+1]-m)*C,c+=(o[x+7+2]-c)*C,g+=(o[x+7+3]-g)*C,p+=(o[x+7+4]-p)*C,y+=(o[x+7+5]-y)*C,w+=(o[x+7+6]-w)*C;break;case 1:m=o[x+1],c=o[x+2],g=o[x+3],p=o[x+4],y=o[x+5],w=o[x+6];break;default:m=this.getBezierValue(n,x,1,b-2),c=this.getBezierValue(n,x,2,b+18-2),g=this.getBezierValue(n,x,3,b+18*2-2),p=this.getBezierValue(n,x,4,b+18*3-2),y=this.getBezierValue(n,x,5,b+18*4-2),w=this.getBezierValue(n,x,6,b+18*5-2)}if(l==1)d.r=m,d.g=c,d.b=g,u.r=p,u.g=y,u.b=w;else{if(h==J.setup){let S=a.data.color,C=a.data.darkColor;d.r=S.r,d.g=S.g,d.b=S.b,u.r=C.r,u.g=C.g,u.b=C.b}d.r+=(m-d.r)*l,d.g+=(c-d.g)*l,d.b+=(g-d.b)*l,u.r+=(p-u.r)*l,u.g+=(y-u.g)*l,u.b+=(w-u.b)*l}}},Ua=class extends pe{constructor(e,s){super(e,[$t.attachment+"|"+s]);T(this,"slotIndex",0);T(this,"attachmentNames");this.slotIndex=s,this.attachmentNames=new Array(e)}getFrameCount(){return this.frames.length}setFrame(e,s,n){this.frames[e]=s,this.attachmentNames[e]=n}apply(e,s,n,r,l,h,i){let a=e.slots[this.slotIndex];if(a.bone.active){if(i==Bs.mixOut){h==J.setup&&this.setAttachment(e,a,a.data.attachmentName);return}if(n<this.frames[0]){(h==J.setup||h==J.first)&&this.setAttachment(e,a,a.data.attachmentName);return}this.setAttachment(e,a,this.attachmentNames[pe.search1(this.frames,n)])}}setAttachment(e,s,n){s.setAttachment(n?e.getAttachment(this.slotIndex,n):null)}},Pd=class extends hr{constructor(e,s,n,r){super(e,s,[$t.deform+"|"+n+"|"+r.id]);T(this,"slotIndex",0);T(this,"attachment");T(this,"vertices");this.slotIndex=n,this.attachment=r,this.vertices=new Array(e)}getFrameCount(){return this.frames.length}setFrame(e,s,n){this.frames[e]=s,this.vertices[e]=n}setBezier(e,s,n,r,l,h,i,a,o,d,u){let m=this.curves,c=this.getFrameCount()+e*18;n==0&&(m[s]=2+c);let g=(r-h*2+a)*.03,p=o*.03-i*.06,y=((h-a)*3-r+d)*.006,w=(i-o+.33333333)*.018,x=g*2+y,b=p*2+w,S=(h-r)*.3+g+y*.16666667,C=i*.3+p+w*.16666667,v=r+S,A=C;for(let M=c+18;c<M;c+=2)m[c]=v,m[c+1]=A,S+=x,C+=b,x+=y,b+=w,v+=S,A+=C}getCurvePercent(e,s){let n=this.curves,r=n[s];switch(r){case 0:let a=this.frames[s];return(e-a)/(this.frames[s+this.getFrameEntries()]-a);case 1:return 0}if(r-=2,n[r]>e){let a=this.frames[s];return n[r+1]*(e-a)/(n[r]-a)}let l=r+18;for(r+=2;r<l;r+=2)if(n[r]>=e){let a=n[r-2],o=n[r-1];return o+(e-a)/(n[r]-a)*(n[r+1]-o)}let h=n[l-2],i=n[l-1];return i+(1-i)*(e-h)/(this.frames[s+this.getFrameEntries()]-h)}apply(e,s,n,r,l,h,i){let a=e.slots[this.slotIndex];if(!a.bone.active)return;let o=a.getAttachment();if(!o||!(o instanceof Wr)||o.timelineAttachment!=this.attachment)return;let d=a.deform;d.length==0&&(h=J.setup);let u=this.vertices,m=u[0].length,c=this.frames;if(n<c[0]){switch(h){case J.setup:d.length=0;return;case J.first:if(l==1){d.length=0;return}d.length=m;let b=o;if(b.bones){l=1-l;for(var g=0;g<m;g++)d[g]*=l}else{let S=b.vertices;for(var g=0;g<m;g++)d[g]+=(S[g]-d[g])*l}}return}if(d.length=m,n>=c[c.length-1]){let b=u[c.length-1];if(l==1)if(h==J.add){let S=o;if(S.bones)for(let C=0;C<m;C++)d[C]+=b[C];else{let C=S.vertices;for(let v=0;v<m;v++)d[v]+=b[v]-C[v]}}else ht.arrayCopy(b,0,d,0,m);else switch(h){case J.setup:{let C=o;if(C.bones)for(let v=0;v<m;v++)d[v]=b[v]*l;else{let v=C.vertices;for(let A=0;A<m;A++){let M=v[A];d[A]=M+(b[A]-M)*l}}break}case J.first:case J.replace:for(let C=0;C<m;C++)d[C]+=(b[C]-d[C])*l;break;case J.add:let S=o;if(S.bones)for(let C=0;C<m;C++)d[C]+=b[C]*l;else{let C=S.vertices;for(let v=0;v<m;v++)d[v]+=(b[v]-C[v])*l}}return}let p=pe.search1(c,n),y=this.getCurvePercent(n,p),w=u[p],x=u[p+1];if(l==1)if(h==J.add){let b=o;if(b.bones)for(let S=0;S<m;S++){let C=w[S];d[S]+=C+(x[S]-C)*y}else{let S=b.vertices;for(let C=0;C<m;C++){let v=w[C];d[C]+=v+(x[C]-v)*y-S[C]}}}else for(let b=0;b<m;b++){let S=w[b];d[b]=S+(x[b]-S)*y}else switch(h){case J.setup:{let S=o;if(S.bones)for(let C=0;C<m;C++){let v=w[C];d[C]=(v+(x[C]-v)*y)*l}else{let C=S.vertices;for(let v=0;v<m;v++){let A=w[v],M=C[v];d[v]=M+(A+(x[v]-A)*y-M)*l}}break}case J.first:case J.replace:for(let S=0;S<m;S++){let C=w[S];d[S]+=(C+(x[S]-C)*y-d[S])*l}break;case J.add:let b=o;if(b.bones)for(let S=0;S<m;S++){let C=w[S];d[S]+=(C+(x[S]-C)*y)*l}else{let S=b.vertices;for(let C=0;C<m;C++){let v=w[C];d[C]+=(v+(x[C]-v)*y-S[C])*l}}}}},Ch=(co=class extends pe{constructor(e){super(e,co.propertyIds);T(this,"events");this.events=new Array(e)}getFrameCount(){return this.frames.length}setFrame(e,s){this.frames[e]=s.time,this.events[e]=s}apply(e,s,n,r,l,h,i){if(!r)return;let a=this.frames,o=this.frames.length;if(s>n)this.apply(e,s,Number.MAX_VALUE,r,l,h,i),s=-1;else if(s>=a[o-1])return;if(n<a[0])return;let d=0;if(s<a[0])d=0;else{d=pe.search1(a,s)+1;let u=a[d];for(;d>0&&a[d-1]==u;)d--}for(;d<o&&n>=a[d];d++)r.push(this.events[d])}},T(co,"propertyIds",[""+$t.event]),co),Co=(uo=class extends pe{constructor(e){super(e,uo.propertyIds);T(this,"drawOrders");this.drawOrders=new Array(e)}getFrameCount(){return this.frames.length}setFrame(e,s,n){this.frames[e]=s,this.drawOrders[e]=n}apply(e,s,n,r,l,h,i){if(i==Bs.mixOut){h==J.setup&&ht.arrayCopy(e.slots,0,e.drawOrder,0,e.slots.length);return}if(n<this.frames[0]){(h==J.setup||h==J.first)&&ht.arrayCopy(e.slots,0,e.drawOrder,0,e.slots.length);return}let a=pe.search1(this.frames,n),o=this.drawOrders[a];if(!o)ht.arrayCopy(e.slots,0,e.drawOrder,0,e.slots.length);else{let d=e.drawOrder,u=e.slots;for(let m=0,c=o.length;m<c;m++)d[m]=u[o[m]]}}},T(uo,"propertyIds",[""+$t.drawOrder]),uo),Rd=class extends hr{constructor(e,s,n){super(e,s,[$t.ikConstraint+"|"+n]);T(this,"constraintIndex",0);this.constraintIndex=n}getFrameEntries(){return 6}setFrame(e,s,n,r,l,h,i){e*=6,this.frames[e]=s,this.frames[e+1]=n,this.frames[e+2]=r,this.frames[e+3]=l,this.frames[e+4]=h?1:0,this.frames[e+5]=i?1:0}apply(e,s,n,r,l,h,i){let a=e.ikConstraints[this.constraintIndex];if(!a.active)return;let o=this.frames;if(n<o[0]){switch(h){case J.setup:a.mix=a.data.mix,a.softness=a.data.softness,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch;return;case J.first:a.mix+=(a.data.mix-a.mix)*l,a.softness+=(a.data.softness-a.softness)*l,a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch}return}let d=0,u=0,m=pe.search(o,n,6),c=this.curves[m/6];switch(c){case 0:let g=o[m];d=o[m+1],u=o[m+2];let p=(n-g)/(o[m+6]-g);d+=(o[m+6+1]-d)*p,u+=(o[m+6+2]-u)*p;break;case 1:d=o[m+1],u=o[m+2];break;default:d=this.getBezierValue(n,m,1,c-2),u=this.getBezierValue(n,m,2,c+18-2)}h==J.setup?(a.mix=a.data.mix+(d-a.data.mix)*l,a.softness=a.data.softness+(u-a.data.softness)*l,i==Bs.mixOut?(a.bendDirection=a.data.bendDirection,a.compress=a.data.compress,a.stretch=a.data.stretch):(a.bendDirection=o[m+3],a.compress=o[m+4]!=0,a.stretch=o[m+5]!=0)):(a.mix+=(d-a.mix)*l,a.softness+=(u-a.softness)*l,i==Bs.mixIn&&(a.bendDirection=o[m+3],a.compress=o[m+4]!=0,a.stretch=o[m+5]!=0))}},Yd=class extends hr{constructor(e,s,n){super(e,s,[$t.transformConstraint+"|"+n]);T(this,"constraintIndex",0);this.constraintIndex=n}getFrameEntries(){return 7}setFrame(e,s,n,r,l,h,i,a){let o=this.frames;e*=7,o[e]=s,o[e+1]=n,o[e+2]=r,o[e+3]=l,o[e+4]=h,o[e+5]=i,o[e+6]=a}apply(e,s,n,r,l,h,i){let a=e.transformConstraints[this.constraintIndex];if(!a.active)return;let o=this.frames;if(n<o[0]){let x=a.data;switch(h){case J.setup:a.mixRotate=x.mixRotate,a.mixX=x.mixX,a.mixY=x.mixY,a.mixScaleX=x.mixScaleX,a.mixScaleY=x.mixScaleY,a.mixShearY=x.mixShearY;return;case J.first:a.mixRotate+=(x.mixRotate-a.mixRotate)*l,a.mixX+=(x.mixX-a.mixX)*l,a.mixY+=(x.mixY-a.mixY)*l,a.mixScaleX+=(x.mixScaleX-a.mixScaleX)*l,a.mixScaleY+=(x.mixScaleY-a.mixScaleY)*l,a.mixShearY+=(x.mixShearY-a.mixShearY)*l}return}let d,u,m,c,g,p,y=pe.search(o,n,7),w=this.curves[y/7];switch(w){case 0:let x=o[y];d=o[y+1],u=o[y+2],m=o[y+3],c=o[y+4],g=o[y+5],p=o[y+6];let b=(n-x)/(o[y+7]-x);d+=(o[y+7+1]-d)*b,u+=(o[y+7+2]-u)*b,m+=(o[y+7+3]-m)*b,c+=(o[y+7+4]-c)*b,g+=(o[y+7+5]-g)*b,p+=(o[y+7+6]-p)*b;break;case 1:d=o[y+1],u=o[y+2],m=o[y+3],c=o[y+4],g=o[y+5],p=o[y+6];break;default:d=this.getBezierValue(n,y,1,w-2),u=this.getBezierValue(n,y,2,w+18-2),m=this.getBezierValue(n,y,3,w+18*2-2),c=this.getBezierValue(n,y,4,w+18*3-2),g=this.getBezierValue(n,y,5,w+18*4-2),p=this.getBezierValue(n,y,6,w+18*5-2)}if(h==J.setup){let x=a.data;a.mixRotate=x.mixRotate+(d-x.mixRotate)*l,a.mixX=x.mixX+(u-x.mixX)*l,a.mixY=x.mixY+(m-x.mixY)*l,a.mixScaleX=x.mixScaleX+(c-x.mixScaleX)*l,a.mixScaleY=x.mixScaleY+(g-x.mixScaleY)*l,a.mixShearY=x.mixShearY+(p-x.mixShearY)*l}else a.mixRotate+=(d-a.mixRotate)*l,a.mixX+=(u-a.mixX)*l,a.mixY+=(m-a.mixY)*l,a.mixScaleX+=(c-a.mixScaleX)*l,a.mixScaleY+=(g-a.mixScaleY)*l,a.mixShearY+=(p-a.mixShearY)*l}},Fd=class extends Wn{constructor(e,s,n){super(e,s,$t.pathConstraintPosition+"|"+n);T(this,"constraintIndex",0);this.constraintIndex=n}apply(e,s,n,r,l,h,i){let a=e.pathConstraints[this.constraintIndex];a.active&&(a.position=this.getAbsoluteValue(n,l,h,a.position,a.data.position))}},Bd=class extends Wn{constructor(e,s,n){super(e,s,$t.pathConstraintSpacing+"|"+n);T(this,"constraintIndex",0);this.constraintIndex=n}apply(e,s,n,r,l,h,i){let a=e.pathConstraints[this.constraintIndex];a.active&&(a.spacing=this.getAbsoluteValue(n,l,h,a.spacing,a.data.spacing))}},Xd=class extends hr{constructor(e,s,n){super(e,s,[$t.pathConstraintMix+"|"+n]);T(this,"constraintIndex",0);this.constraintIndex=n}getFrameEntries(){return 4}setFrame(e,s,n,r,l){let h=this.frames;e<<=2,h[e]=s,h[e+1]=n,h[e+2]=r,h[e+3]=l}apply(e,s,n,r,l,h,i){let a=e.pathConstraints[this.constraintIndex];if(!a.active)return;let o=this.frames;if(n<o[0]){switch(h){case J.setup:a.mixRotate=a.data.mixRotate,a.mixX=a.data.mixX,a.mixY=a.data.mixY;return;case J.first:a.mixRotate+=(a.data.mixRotate-a.mixRotate)*l,a.mixX+=(a.data.mixX-a.mixX)*l,a.mixY+=(a.data.mixY-a.mixY)*l}return}let d,u,m,c=pe.search(o,n,4),g=this.curves[c>>2];switch(g){case 0:let p=o[c];d=o[c+1],u=o[c+2],m=o[c+3];let y=(n-p)/(o[c+4]-p);d+=(o[c+4+1]-d)*y,u+=(o[c+4+2]-u)*y,m+=(o[c+4+3]-m)*y;break;case 1:d=o[c+1],u=o[c+2],m=o[c+3];break;default:d=this.getBezierValue(n,c,1,g-2),u=this.getBezierValue(n,c,2,g+18-2),m=this.getBezierValue(n,c,3,g+18*2-2)}if(h==J.setup){let p=a.data;a.mixRotate=p.mixRotate+(d-p.mixRotate)*l,a.mixX=p.mixX+(u-p.mixX)*l,a.mixY=p.mixY+(m-p.mixY)*l}else a.mixRotate+=(d-a.mixRotate)*l,a.mixX+=(u-a.mixX)*l,a.mixY+=(m-a.mixY)*l}};class Zi extends Wn{constructor(e,s,n,r){super(e,s,r+"|"+n);T(this,"constraintIndex",0);this.constraintIndex=n}apply(e,s,n,r,l,h,i){let a;if(this.constraintIndex==-1){const o=n>=this.frames[0]?this.getCurveValue(n):0;for(const d of e.physicsConstraints)d.active&&this.global(d.data)&&this.set(d,this.getAbsoluteValue2(n,l,h,this.get(d),this.setup(d),o))}else a=e.physicsConstraints[this.constraintIndex],a.active&&this.set(a,this.getAbsoluteValue(n,l,h,this.get(a),this.setup(a)))}}class $d extends Zi{constructor(t,e,s){super(t,e,s,$t.physicsConstraintInertia)}setup(t){return t.data.inertia}get(t){return t.inertia}set(t,e){t.inertia=e}global(t){return t.inertiaGlobal}}class Nd extends Zi{constructor(t,e,s){super(t,e,s,$t.physicsConstraintStrength)}setup(t){return t.data.strength}get(t){return t.strength}set(t,e){t.strength=e}global(t){return t.strengthGlobal}}class Vd extends Zi{constructor(t,e,s){super(t,e,s,$t.physicsConstraintDamping)}setup(t){return t.data.damping}get(t){return t.damping}set(t,e){t.damping=e}global(t){return t.dampingGlobal}}class _d extends Zi{constructor(t,e,s){super(t,e,s,$t.physicsConstraintMass)}setup(t){return 1/t.data.massInverse}get(t){return 1/t.massInverse}set(t,e){t.massInverse=1/e}global(t){return t.massGlobal}}class Dd extends Zi{constructor(t,e,s){super(t,e,s,$t.physicsConstraintWind)}setup(t){return t.data.wind}get(t){return t.wind}set(t,e){t.wind=e}global(t){return t.windGlobal}}class Ld extends Zi{constructor(t,e,s){super(t,e,s,$t.physicsConstraintGravity)}setup(t){return t.data.gravity}get(t){return t.gravity}set(t,e){t.gravity=e}global(t){return t.gravityGlobal}}class Od extends Zi{constructor(t,e,s){super(t,e,s,$t.physicsConstraintMix)}setup(t){return t.data.mix}get(t){return t.mix}set(t,e){t.mix=e}global(t){return t.mixGlobal}}const _h=class _h extends pe{constructor(e,s){super(e,_h.propertyIds);T(this,"constraintIndex");this.constraintIndex=s}getFrameCount(){return this.frames.length}setFrame(e,s){this.frames[e]=s}apply(e,s,n,r,l,h,i){let a;if(this.constraintIndex!=-1&&(a=e.physicsConstraints[this.constraintIndex],!a.active))return;const o=this.frames;if(s>n)this.apply(e,s,Number.MAX_VALUE,[],l,h,i),s=-1;else if(s>=o[o.length-1])return;if(!(n<o[0])&&(s<o[0]||n>=o[pe.search1(o,s)+1]))if(a!=null)a.reset();else for(const d of e.physicsConstraints)d.active&&d.reset()}};T(_h,"propertyIds",[$t.physicsConstraintReset.toString()]);let vl=_h,Wd=(nn=class extends pe{constructor(e,s,n){super(e,[$t.sequence+"|"+s+"|"+n.sequence.id]);T(this,"slotIndex");T(this,"attachment");this.slotIndex=s,this.attachment=n}getFrameEntries(){return nn.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(e,s,n,r,l){let h=this.frames;e*=nn.ENTRIES,h[e]=s,h[e+nn.MODE]=n|r<<4,h[e+nn.DELAY]=l}apply(e,s,n,r,l,h,i){let a=e.slots[this.slotIndex];if(!a.bone.active)return;let o=a.attachment,d=this.attachment;if(o!=d&&(!(o instanceof Wr)||o.timelineAttachment!=d))return;if(i==Bs.mixOut){h==J.setup&&(a.sequenceIndex=-1);return}let u=this.frames;if(n<u[0]){(h==J.setup||h==J.first)&&(a.sequenceIndex=-1);return}let m=pe.search(u,n,nn.ENTRIES),c=u[m],g=u[m+nn.MODE],p=u[m+nn.DELAY];if(!this.attachment.sequence)return;let y=g>>4,w=this.attachment.sequence.regions.length,x=Hg[g&15];if(x!=Fs.hold)switch(y+=(n-c)/p+1e-5|0,x){case Fs.once:y=Math.min(w-1,y);break;case Fs.loop:y%=w;break;case Fs.pingpong:{let b=(w<<1)-2;y=b==0?0:y%b,y>=w&&(y=b-y);break}case Fs.onceReverse:y=Math.max(w-1-y,0);break;case Fs.loopReverse:y=w-1-y%w;break;case Fs.pingpongReverse:{let b=(w<<1)-2;y=b==0?0:(y+w-1)%b,y>=w&&(y=b-y)}}a.sequenceIndex=y}},T(nn,"ENTRIES",3),T(nn,"MODE",1),T(nn,"DELAY",2),nn),Ud=(Ci=class{constructor(t){T(this,"data");T(this,"tracks",new Array);T(this,"timeScale",1);T(this,"unkeyedState",0);T(this,"events",new Array);T(this,"listeners",new Array);T(this,"queue",new Zg(this));T(this,"propertyIDs",new fd);T(this,"animationsChanged",!1);T(this,"trackEntryPool",new So(()=>new Kg));this.data=t}static emptyAnimation(){return Ci._emptyAnimation}update(t){t*=this.timeScale;let e=this.tracks;for(let s=0,n=e.length;s<n;s++){let r=e[s];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let l=t*r.timeScale;if(r.delay>0){if(r.delay-=l,r.delay>0)continue;l=-r.delay,r.delay=0}let h=r.next;if(h){let i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=l,this.setCurrent(s,h,!0);h.mixingFrom;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){e[s]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i&&(i.mixingTo=null);i;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=l}this.queue.drain()}updateMixingFrom(t,e){let s=t.mixingFrom;if(!s)return!0;let n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.nextTrackLast!=-1&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom!=null&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();let e=this.events,s=this.tracks,n=!1;for(let u=0,m=s.length;u<m;u++){let c=s[u];if(!c||c.delay>0)continue;n=!0;let g=u==0?J.first:c.mixBlend,p=c.alpha;c.mixingFrom?p*=this.applyMixingFrom(c,t,g):c.trackTime>=c.trackEnd&&!c.next&&(p=0);let y=p>=c.alphaAttachmentThreshold,w=c.animationLast,x=c.getAnimationTime(),b=x,S=e;c.reverse&&(b=c.animation.duration-b,S=null);let C=c.animation.timelines,v=C.length;if(u==0&&p==1||g==J.add){u==0&&(y=!0);for(let A=0;A<v;A++){ht.webkit602BugfixHelper(p,g);var r=C[A];r instanceof Ua?this.applyAttachmentTimeline(r,t,b,g,y):r.apply(t,w,b,S,p,g,Bs.mixIn)}}else{let A=c.timelineMode,M=c.shortestRotation,I=!M&&c.timelinesRotation.length!=v<<1;I&&(c.timelinesRotation.length=v<<1);for(let E=0;E<v;E++){let P=C[E],R=A[E]==vh?g:J.setup;!M&&P instanceof Cl?this.applyRotateTimeline(P,t,b,p,R,c.timelinesRotation,E<<1,I):P instanceof Ua?this.applyAttachmentTimeline(P,t,b,g,y):(ht.webkit602BugfixHelper(p,g),P.apply(t,w,b,S,p,R,Bs.mixIn))}}this.queueEvents(c,x),e.length=0,c.nextAnimationLast=x,c.nextTrackLast=c.trackTime}for(var l=this.unkeyedState+Gd,h=t.slots,i=0,a=t.slots.length;i<a;i++){var o=h[i];if(o.attachmentState==l){var d=o.data.attachmentName;o.setAttachment(d?t.getAttachment(o.data.index,d):null)}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(t,e,s){let n=t.mixingFrom;n.mixingFrom&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==J.first&&(s=J.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=J.first&&(s=n.mixBlend));let l=r<n.mixAttachmentThreshold,h=r<n.mixDrawOrderThreshold,i=n.animation.timelines,a=i.length,o=n.alpha*t.interruptAlpha,d=o*(1-r),u=n.animationLast,m=n.getAnimationTime(),c=m,g=null;if(n.reverse?c=n.animation.duration-c:r<n.eventThreshold&&(g=this.events),s==J.add)for(let p=0;p<a;p++)i[p].apply(e,u,c,g,d,s,Bs.mixOut);else{let p=n.timelineMode,y=n.timelineHoldMix,w=n.shortestRotation,x=!w&&n.timelinesRotation.length!=a<<1;x&&(n.timelinesRotation.length=a<<1),n.totalAlpha=0;for(let b=0;b<a;b++){let S=i[b],C=Bs.mixOut,v,A=0;switch(p[b]){case vh:if(!h&&S instanceof Co)continue;v=s,A=d;break;case qd:v=J.setup,A=d;break;case zd:v=s,A=o;break;case Ah:v=J.setup,A=o;break;default:v=J.setup;let M=y[b];A=o*Math.max(0,1-M.mixTime/M.mixDuration);break}n.totalAlpha+=A,!w&&S instanceof Cl?this.applyRotateTimeline(S,e,c,A,v,n.timelinesRotation,b<<1,x):S instanceof Ua?this.applyAttachmentTimeline(S,e,c,v,l&&A>=n.alphaAttachmentThreshold):(ht.webkit602BugfixHelper(A,s),h&&S instanceof Co&&v==J.setup&&(C=Bs.mixIn),S.apply(e,u,c,g,A,v,C))}}return t.mixDuration>0&&this.queueEvents(n,m),this.events.length=0,n.nextAnimationLast=m,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(t,e,s,n,r){var l=e.slots[t.slotIndex];l.bone.active&&(s<t.frames[0]?(n==J.setup||n==J.first)&&this.setAttachment(e,l,l.data.attachmentName,r):this.setAttachment(e,l,t.attachmentNames[pe.search1(t.frames,s)],r),l.attachmentState<=this.unkeyedState&&(l.attachmentState=this.unkeyedState+Gd))}setAttachment(t,e,s,n){e.setAttachment(s?t.getAttachment(e.data.index,s):null),n&&(e.attachmentState=this.unkeyedState+Qg)}applyRotateTimeline(t,e,s,n,r,l,h,i){if(i&&(l[h]=0),n==1){t.apply(e,0,s,null,1,r,Bs.mixIn);return}let a=e.bones[t.boneIndex];if(!a.active)return;let o=t.frames,d=0,u=0;if(s<o[0])switch(r){case J.setup:a.rotation=a.data.rotation;default:return;case J.first:d=a.rotation,u=a.data.rotation}else d=r==J.setup?a.data.rotation:a.rotation,u=a.data.rotation+t.getCurveValue(s);let m=0,c=u-d;if(c-=Math.ceil(c/360-.5)*360,c==0)m=l[h];else{let g=0,p=0;i?(g=0,p=c):(g=l[h],p=l[h+1]);let y=g-g%360;m=c+y;let w=c>=0,x=g>=0;Math.abs(p)<=90&&ot.signum(p)!=ot.signum(c)&&(Math.abs(g-y)>180?(m+=360*ot.signum(g),x=w):y!=0?m-=360*ot.signum(g):x=w),x!=w&&(m+=360*ot.signum(g)),l[h]=m}l[h+1]=c,a.rotation=d+m*n}queueEvents(t,e){let s=t.animationStart,n=t.animationEnd,r=n-s,l=t.trackLast%r,h=this.events,i=0,a=h.length;for(;i<a;i++){let d=h[i];if(d.time<l)break;d.time>n||this.queue.event(t,d)}let o=!1;if(t.loop)if(r==0)o=!0;else{const d=Math.floor(t.trackTime/r);o=d>0&&d>Math.floor(t.trackLast/r)}else o=e>=n&&t.animationLast<n;for(o&&this.queue.complete(t);i<a;i++){let d=h[i];d.time<s||this.queue.event(t,d)}}clearTracks(){let t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;let e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let s=e;for(;;){let n=s.mixingFrom;if(!n)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){let n=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,n&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s=!1){let n=this.data.skeletonData.findAnimation(e);if(!n)throw new Error("Animation not found: "+e);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s=!1){if(!e)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,n=!1):this.clearNext(r));let l=this.trackEntry(t,e,s,r);return this.setCurrent(t,l,n),this.queue.drain(),l}addAnimation(t,e,s=!1,n=0){let r=this.data.skeletonData.findAnimation(e);if(!r)throw new Error("Animation not found: "+e);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s=!1,n=0){if(!e)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r)for(;r.next;)r=r.next;let l=this.trackEntry(t,e,s,r);return r?(r.next=l,l.previous=r,n<=0&&(n=Math.max(n+r.getTrackComplete()-l.mixDuration,0))):(this.setCurrent(t,l,!0),this.queue.drain(),n<0&&(n=0)),l.delay=n,l}setEmptyAnimation(t,e=0){let s=this.setAnimationWith(t,Ci.emptyAnimation(),!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e=0,s=0){let n=this.addAnimationWith(t,Ci.emptyAnimation(),!1,s);return s<=0&&(n.delay=Math.max(n.delay+n.mixDuration-e,0)),n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t=0){let e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){let r=this.tracks[s];r&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(ht.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){let r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.reverse=!1,r.shortestRotation=!1,r.eventThreshold=0,r.alphaAttachmentThreshold=0,r.mixAttachmentThreshold=0,r.mixDrawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.mixTime=0,r.mixDuration=n?this.data.getMix(n.animation,e):0,r.interruptAlpha=1,r.totalAlpha=0,r.mixBlend=J.replace,r}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();let t=this.tracks;for(let e=0,s=t.length;e<s;e++){let n=t[e];if(n){for(;n.mixingFrom;)n=n.mixingFrom;do(!n.mixingTo||n.mixBlend!=J.add)&&this.computeHold(n),n=n.mixingTo;while(n)}}}computeHold(t){let e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=t.timelineMode;r.length=n;let l=t.timelineHoldMix;l.length=0;let h=this.propertyIDs;if(e&&e.holdPrevious){for(let i=0;i<n;i++)r[i]=h.addAll(s[i].getPropertyIds())?Ah:zd;return}t:for(let i=0;i<n;i++){let a=s[i],o=a.getPropertyIds();if(!h.addAll(o))r[i]=vh;else if(!e||a instanceof Ua||a instanceof Co||a instanceof Ch||!e.animation.hasTimeline(o))r[i]=qd;else{for(let d=e.mixingTo;d;d=d.mixingTo)if(!d.animation.hasTimeline(o)){if(t.mixDuration>0){r[i]=Jg,l[i]=d;continue t}break}r[i]=Ah}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){let e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}},T(Ci,"_emptyAnimation",new yh("<empty>",[],0)),Ci),Kg=class{constructor(){T(this,"animation",null);T(this,"previous",null);T(this,"next",null);T(this,"mixingFrom",null);T(this,"mixingTo",null);T(this,"listener",null);T(this,"trackIndex",0);T(this,"loop",!1);T(this,"holdPrevious",!1);T(this,"reverse",!1);T(this,"shortestRotation",!1);T(this,"eventThreshold",0);T(this,"mixAttachmentThreshold",0);T(this,"alphaAttachmentThreshold",0);T(this,"mixDrawOrderThreshold",0);T(this,"animationStart",0);T(this,"animationEnd",0);T(this,"animationLast",0);T(this,"nextAnimationLast",0);T(this,"delay",0);T(this,"trackTime",0);T(this,"trackLast",0);T(this,"nextTrackLast",0);T(this,"trackEnd",0);T(this,"timeScale",0);T(this,"alpha",0);T(this,"mixTime",0);T(this,"_mixDuration",0);T(this,"interruptAlpha",0);T(this,"totalAlpha",0);T(this,"mixBlend",J.replace);T(this,"timelineMode",new Array);T(this,"timelineHoldMix",new Array);T(this,"timelinesRotation",new Array)}get mixDuration(){return this._mixDuration}set mixDuration(t){this._mixDuration=t}setMixDurationWithDelay(t,e){this._mixDuration=t,e<=0&&(this.previous!=null?e=Math.max(e+this.previous.getTrackComplete()-t,0):e=0),this.delay=e}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){let t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){let t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}wasApplied(){return this.nextTrackLast!=-1}isNextReady(){return this.next!=null&&this.nextTrackLast-this.next.delay>=0}},Zg=class{constructor(t){T(this,"objects",[]);T(this,"drainDisabled",!1);T(this,"animState");this.animState=t}start(t){this.objects.push(tn.start),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(tn.interrupt),this.objects.push(t)}end(t){this.objects.push(tn.end),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(tn.dispose),this.objects.push(t)}complete(t){this.objects.push(tn.complete),this.objects.push(t)}event(t,e){this.objects.push(tn.event),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;let t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){let n=t[s],r=t[s+1];switch(n){case tn.start:r.listener&&r.listener.start&&r.listener.start(r);for(let h=0;h<e.length;h++){let i=e[h];i.start&&i.start(r)}break;case tn.interrupt:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let h=0;h<e.length;h++){let i=e[h];i.interrupt&&i.interrupt(r)}break;case tn.end:r.listener&&r.listener.end&&r.listener.end(r);for(let h=0;h<e.length;h++){let i=e[h];i.end&&i.end(r)}case tn.dispose:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let h=0;h<e.length;h++){let i=e[h];i.dispose&&i.dispose(r)}this.animState.trackEntryPool.free(r);break;case tn.complete:r.listener&&r.listener.complete&&r.listener.complete(r);for(let h=0;h<e.length;h++){let i=e[h];i.complete&&i.complete(r)}break;case tn.event:let l=t[s+++2];r.listener&&r.listener.event&&r.listener.event(r,l);for(let h=0;h<e.length;h++){let i=e[h];i.event&&i.event(r,l)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};var tn;(function(f){f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event"})(tn||(tn={}));let YC=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}};const vh=0,qd=1,zd=2,Ah=3,Jg=4,Gd=1,Qg=2;let jg=class{constructor(t){T(this,"skeletonData");T(this,"animationToMixTime",{});T(this,"defaultMix",0);if(!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){let n=this.skeletonData.findAnimation(t);if(!n)throw new Error("Animation not found: "+t);let r=this.skeletonData.findAnimation(e);if(!r)throw new Error("Animation not found: "+e);this.setMixWith(n,r,s)}setMixWith(t,e,s){if(!t)throw new Error("from cannot be null.");if(!e)throw new Error("to cannot be null.");let n=t.name+"."+e.name;this.animationToMixTime[n]=s}getMix(t,e){let s=t.name+"."+e.name,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}},Hd=class Ux extends Wr{constructor(e){super(e);T(this,"color",new Yt(1,1,1,1))}copy(){let e=new Ux(this.name);return this.copyTo(e),e.color.setFromColor(this.color),e}},qa=class qx extends Wr{constructor(e){super(e);T(this,"endSlot",null);T(this,"color",new Yt(.2275,.2275,.8078,1))}copy(){let e=new qx(this.name);return this.copyTo(e),e.endSlot=this.endSlot,e.color.setFromColor(this.color),e}};class Kd{constructor(t){T(this,"_image");this._image=t}getImage(){return this._image}}var is;(function(f){f[f.Nearest=9728]="Nearest",f[f.Linear=9729]="Linear",f[f.MipMap=9987]="MipMap",f[f.MipMapNearestNearest=9984]="MipMapNearestNearest",f[f.MipMapLinearNearest=9985]="MipMapLinearNearest",f[f.MipMapNearestLinear=9986]="MipMapNearestLinear",f[f.MipMapLinearLinear=9987]="MipMapLinearLinear"})(is||(is={}));var Ur;(function(f){f[f.MirroredRepeat=33648]="MirroredRepeat",f[f.ClampToEdge=33071]="ClampToEdge",f[f.Repeat=10497]="Repeat"})(Ur||(Ur={}));let tp=class{constructor(){T(this,"texture");T(this,"u",0);T(this,"v",0);T(this,"u2",0);T(this,"v2",0);T(this,"width",0);T(this,"height",0);T(this,"degrees",0);T(this,"offsetX",0);T(this,"offsetY",0);T(this,"originalWidth",0);T(this,"originalHeight",0)}};class FC extends Kd{setFilters(t,e){}setWraps(t,e){}dispose(){}}let Mh=class{constructor(t){T(this,"pages",new Array);T(this,"regions",new Array);let e=new BC(t),s=new Array(4),n={};n.size=o=>{o.width=parseInt(s[1]),o.height=parseInt(s[2])},n.format=()=>{},n.filter=o=>{o.minFilter=ht.enumValue(is,s[1]),o.magFilter=ht.enumValue(is,s[2])},n.repeat=o=>{s[1].indexOf("x")!=-1&&(o.uWrap=Ur.Repeat),s[1].indexOf("y")!=-1&&(o.vWrap=Ur.Repeat)},n.pma=o=>{o.pma=s[1]=="true"};var r={};r.xy=o=>{o.x=parseInt(s[1]),o.y=parseInt(s[2])},r.size=o=>{o.width=parseInt(s[1]),o.height=parseInt(s[2])},r.bounds=o=>{o.x=parseInt(s[1]),o.y=parseInt(s[2]),o.width=parseInt(s[3]),o.height=parseInt(s[4])},r.offset=o=>{o.offsetX=parseInt(s[1]),o.offsetY=parseInt(s[2])},r.orig=o=>{o.originalWidth=parseInt(s[1]),o.originalHeight=parseInt(s[2])},r.offsets=o=>{o.offsetX=parseInt(s[1]),o.offsetY=parseInt(s[2]),o.originalWidth=parseInt(s[3]),o.originalHeight=parseInt(s[4])},r.rotate=o=>{let d=s[1];d=="true"?o.degrees=90:d!="false"&&(o.degrees=parseInt(d))},r.index=o=>{o.index=parseInt(s[1])};let l=e.readLine();for(;l&&l.trim().length==0;)l=e.readLine();for(;!(!l||l.trim().length==0||e.readEntry(s,l)==0);)l=e.readLine();let h=null,i=null,a=null;for(;l!==null;)if(l.trim().length==0)h=null,l=e.readLine();else if(h){let o=new Zd(h,l);for(;;){let d=e.readEntry(s,l=e.readLine());if(d==0)break;let u=r[s[0]];if(u)u(o);else{i||(i=[]),a||(a=[]),i.push(s[0]);let m=[];for(let c=0;c<d;c++)m.push(parseInt(s[c+1]));a.push(m)}}o.originalWidth==0&&o.originalHeight==0&&(o.originalWidth=o.width,o.originalHeight=o.height),i&&i.length>0&&a&&a.length>0&&(o.names=i,o.values=a,i=null,a=null),o.u=o.x/h.width,o.v=o.y/h.height,o.degrees==90?(o.u2=(o.x+o.height)/h.width,o.v2=(o.y+o.width)/h.height):(o.u2=(o.x+o.width)/h.width,o.v2=(o.y+o.height)/h.height),this.regions.push(o)}else{for(h=new ep(l.trim());e.readEntry(s,l=e.readLine())!=0;){let o=n[s[0]];o&&o(h)}this.pages.push(h)}}findRegion(t){for(let e=0;e<this.regions.length;e++)if(this.regions[e].name==t)return this.regions[e];return null}setTextures(t,e=""){for(let s of this.pages)s.setTexture(t.get(e+s.name))}dispose(){var t;for(let e=0;e<this.pages.length;e++)(t=this.pages[e].texture)==null||t.dispose()}},BC=class{constructor(t){T(this,"lines");T(this,"index",0);this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,e){if(!e||(e=e.trim(),e.length==0))return 0;let s=e.indexOf(":");if(s==-1)return 0;t[0]=e.substr(0,s).trim();for(let n=1,r=s+1;;n++){let l=e.indexOf(",",r);if(l==-1)return t[n]=e.substr(r).trim(),n;if(t[n]=e.substr(r,l-r).trim(),r=l+1,n==4)return 4}}},ep=class{constructor(t){T(this,"name");T(this,"minFilter",is.Nearest);T(this,"magFilter",is.Nearest);T(this,"uWrap",Ur.ClampToEdge);T(this,"vWrap",Ur.ClampToEdge);T(this,"texture",null);T(this,"width",0);T(this,"height",0);T(this,"pma",!1);T(this,"regions",new Array);this.name=t}setTexture(t){this.texture=t,t.setFilters(this.minFilter,this.magFilter),t.setWraps(this.uWrap,this.vWrap);for(let e of this.regions)e.texture=t}},Zd=class extends tp{constructor(e,s){super();T(this,"page");T(this,"name");T(this,"x",0);T(this,"y",0);T(this,"offsetX",0);T(this,"offsetY",0);T(this,"originalWidth",0);T(this,"originalHeight",0);T(this,"index",0);T(this,"degrees",0);T(this,"names",null);T(this,"values",null);this.page=e,this.name=s,e.regions.push(this)}},vo=class Bf extends Wr{constructor(e,s){super(e);T(this,"region",null);T(this,"path");T(this,"regionUVs",[]);T(this,"uvs",[]);T(this,"triangles",[]);T(this,"color",new Yt(1,1,1,1));T(this,"width",0);T(this,"height",0);T(this,"hullLength",0);T(this,"edges",[]);T(this,"parentMesh",null);T(this,"sequence",null);T(this,"tempColor",new Yt(0,0,0,0));this.path=s}updateRegion(){if(!this.region)throw new Error("Region not set.");let e=this.regionUVs;(!this.uvs||this.uvs.length!=e.length)&&(this.uvs=ht.newFloatArray(e.length));let s=this.uvs,n=this.uvs.length,r=this.region.u,l=this.region.v,h=0,i=0;if(this.region instanceof Zd){let a=this.region,o=a.page,d=o.width,u=o.height;switch(a.degrees){case 90:r-=(a.originalHeight-a.offsetY-a.height)/d,l-=(a.originalWidth-a.offsetX-a.width)/u,h=a.originalHeight/d,i=a.originalWidth/u;for(let m=0;m<n;m+=2)s[m]=r+e[m+1]*h,s[m+1]=l+(1-e[m])*i;return;case 180:r-=(a.originalWidth-a.offsetX-a.width)/d,l-=a.offsetY/u,h=a.originalWidth/d,i=a.originalHeight/u;for(let m=0;m<n;m+=2)s[m]=r+(1-e[m])*h,s[m+1]=l+(1-e[m+1])*i;return;case 270:r-=a.offsetY/d,l-=a.offsetX/u,h=a.originalHeight/d,i=a.originalWidth/u;for(let m=0;m<n;m+=2)s[m]=r+(1-e[m+1])*h,s[m+1]=l+e[m]*i;return}r-=a.offsetX/d,l-=(a.originalHeight-a.offsetY-a.height)/u,h=a.originalWidth/d,i=a.originalHeight/u}else this.region?(h=this.region.u2-r,i=this.region.v2-l):(r=l=0,h=i=1);for(let a=0;a<n;a+=2)s[a]=r+e[a]*h,s[a+1]=l+e[a+1]*i}getParentMesh(){return this.parentMesh}setParentMesh(e){this.parentMesh=e,e&&(this.bones=e.bones,this.vertices=e.vertices,this.worldVerticesLength=e.worldVerticesLength,this.regionUVs=e.regionUVs,this.triangles=e.triangles,this.hullLength=e.hullLength,this.worldVerticesLength=e.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();let e=new Bf(this.name,this.path);return e.region=this.region,e.color.setFromColor(this.color),this.copyTo(e),e.regionUVs=new Array(this.regionUVs.length),ht.arrayCopy(this.regionUVs,0,e.regionUVs,0,this.regionUVs.length),e.uvs=new Array(this.uvs.length),ht.arrayCopy(this.uvs,0,e.uvs,0,this.uvs.length),e.triangles=new Array(this.triangles.length),ht.arrayCopy(this.triangles,0,e.triangles,0,this.triangles.length),e.hullLength=this.hullLength,e.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(e.edges=new Array(this.edges.length),ht.arrayCopy(this.edges,0,e.edges,0,this.edges.length)),e.width=this.width,e.height=this.height,e}computeWorldVertices(e,s,n,r,l,h){this.sequence!=null&&this.sequence.apply(e,this),super.computeWorldVertices(e,s,n,r,l,h)}newLinkedMesh(){let e=new Bf(this.name,this.path);return e.region=this.region,e.color.setFromColor(this.color),e.timelineAttachment=this.timelineAttachment,e.setParentMesh(this.parentMesh?this.parentMesh:this),e.region!=null&&e.updateRegion(),e}},Ao=class zx extends Wr{constructor(e){super(e);T(this,"lengths",[]);T(this,"closed",!1);T(this,"constantSpeed",!1);T(this,"color",new Yt(1,1,1,1))}copy(){let e=new zx(this.name);return this.copyTo(e),e.lengths=new Array(this.lengths.length),ht.arrayCopy(this.lengths,0,e.lengths,0,this.lengths.length),e.closed=closed,e.constantSpeed=this.constantSpeed,e.color.setFromColor(this.color),e}},sp=class Gx extends Wr{constructor(e){super(e);T(this,"x",0);T(this,"y",0);T(this,"rotation",0);T(this,"color",new Yt(.38,.94,0,1))}computeWorldPosition(e,s){return s.x=this.x*e.a+this.y*e.b+e.worldX,s.y=this.x*e.c+this.y*e.d+e.worldY,s}computeWorldRotation(e){const s=this.rotation*ot.degRad,n=Math.cos(s),r=Math.sin(s),l=n*e.a+r*e.b,h=n*e.c+r*e.d;return ot.atan2Deg(h,l)}copy(){let e=new Gx(this.name);return e.x=this.x,e.y=this.y,e.rotation=this.rotation,e.color.setFromColor(this.color),e}},Al=(_t=class extends md{constructor(e,s){super(e);T(this,"x",0);T(this,"y",0);T(this,"scaleX",1);T(this,"scaleY",1);T(this,"rotation",0);T(this,"width",0);T(this,"height",0);T(this,"color",new Yt(1,1,1,1));T(this,"path");T(this,"region",null);T(this,"sequence",null);T(this,"offset",ht.newFloatArray(8));T(this,"uvs",ht.newFloatArray(8));T(this,"tempColor",new Yt(1,1,1,1));this.path=s}updateRegion(){if(!this.region)throw new Error("Region not set.");let e=this.region,s=this.uvs;if(e==null){s[0]=0,s[1]=0,s[2]=0,s[3]=1,s[4]=1,s[5]=1,s[6]=1,s[7]=0;return}let n=this.width/this.region.originalWidth*this.scaleX,r=this.height/this.region.originalHeight*this.scaleY,l=-this.width/2*this.scaleX+this.region.offsetX*n,h=-this.height/2*this.scaleY+this.region.offsetY*r,i=l+this.region.width*n,a=h+this.region.height*r,o=this.rotation*ot.degRad,d=Math.cos(o),u=Math.sin(o),m=this.x,c=this.y,g=l*d+m,p=l*u,y=h*d+c,w=h*u,x=i*d+m,b=i*u,S=a*d+c,C=a*u,v=this.offset;v[0]=g-w,v[1]=y+p,v[2]=g-C,v[3]=S+p,v[4]=x-C,v[5]=S+b,v[6]=x-w,v[7]=y+b,e.degrees==90?(s[0]=e.u2,s[1]=e.v2,s[2]=e.u,s[3]=e.v2,s[4]=e.u,s[5]=e.v,s[6]=e.u2,s[7]=e.v):(s[0]=e.u,s[1]=e.v2,s[2]=e.u,s[3]=e.v,s[4]=e.u2,s[5]=e.v,s[6]=e.u2,s[7]=e.v2)}computeWorldVertices(e,s,n,r){this.sequence!=null&&this.sequence.apply(e,this);let l=e.bone,h=this.offset,i=l.worldX,a=l.worldY,o=l.a,d=l.b,u=l.c,m=l.d,c=0,g=0;c=h[0],g=h[1],s[n]=c*o+g*d+i,s[n+1]=c*u+g*m+a,n+=r,c=h[2],g=h[3],s[n]=c*o+g*d+i,s[n+1]=c*u+g*m+a,n+=r,c=h[4],g=h[5],s[n]=c*o+g*d+i,s[n+1]=c*u+g*m+a,n+=r,c=h[6],g=h[7],s[n]=c*o+g*d+i,s[n+1]=c*u+g*m+a}copy(){let e=new _t(this.name,this.path);return e.region=this.region,e.x=this.x,e.y=this.y,e.scaleX=this.scaleX,e.scaleY=this.scaleY,e.rotation=this.rotation,e.width=this.width,e.height=this.height,ht.arrayCopy(this.uvs,0,e.uvs,0,8),ht.arrayCopy(this.offset,0,e.offset,0,8),e.color.setFromColor(this.color),e.sequence=this.sequence!=null?this.sequence.copy():null,e}},T(_t,"X1",0),T(_t,"Y1",1),T(_t,"C1R",2),T(_t,"C1G",3),T(_t,"C1B",4),T(_t,"C1A",5),T(_t,"U1",6),T(_t,"V1",7),T(_t,"X2",8),T(_t,"Y2",9),T(_t,"C2R",10),T(_t,"C2G",11),T(_t,"C2B",12),T(_t,"C2A",13),T(_t,"U2",14),T(_t,"V2",15),T(_t,"X3",16),T(_t,"Y3",17),T(_t,"C3R",18),T(_t,"C3G",19),T(_t,"C3B",20),T(_t,"C3A",21),T(_t,"U3",22),T(_t,"V3",23),T(_t,"X4",24),T(_t,"Y4",25),T(_t,"C4R",26),T(_t,"C4G",27),T(_t,"C4B",28),T(_t,"C4A",29),T(_t,"U4",30),T(_t,"V4",31),_t),Jd=class{constructor(t){T(this,"atlas");this.atlas=t}loadSequence(t,e,s){let n=s.regions;for(let r=0,l=n.length;r<l;r++){let h=s.getPath(e,r),i=this.atlas.findRegion(h);if(i==null)throw new Error("Region not found in atlas: "+h+" (sequence: "+t+")");n[r]=i}}newRegionAttachment(t,e,s,n){let r=new Al(e,s);if(n!=null)this.loadSequence(e,s,n);else{let l=this.atlas.findRegion(s);if(!l)throw new Error("Region not found in atlas: "+s+" (region attachment: "+e+")");r.region=l}return r}newMeshAttachment(t,e,s,n){let r=new vo(e,s);if(n!=null)this.loadSequence(e,s,n);else{let l=this.atlas.findRegion(s);if(!l)throw new Error("Region not found in atlas: "+s+" (mesh attachment: "+e+")");r.region=l}return r}newBoundingBoxAttachment(t,e){return new Hd(e)}newPathAttachment(t,e){return new Ao(e)}newPointAttachment(t,e){return new sp(e)}newClippingAttachment(t,e){return new qa(e)}},Qd=class{constructor(t,e,s){T(this,"index",0);T(this,"name");T(this,"parent",null);T(this,"length",0);T(this,"x",0);T(this,"y",0);T(this,"rotation",0);T(this,"scaleX",1);T(this,"scaleY",1);T(this,"shearX",0);T(this,"shearY",0);T(this,"inherit",be.Normal);T(this,"skinRequired",!1);T(this,"color",new Yt);T(this,"icon");T(this,"visible",!1);if(t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}};var be;(function(f){f[f.Normal=0]="Normal",f[f.OnlyTranslation=1]="OnlyTranslation",f[f.NoRotationOrReflection=2]="NoRotationOrReflection",f[f.NoScale=3]="NoScale",f[f.NoScaleOrReflection=4]="NoScaleOrReflection"})(be||(be={}));let Ml=class{constructor(t,e,s){T(this,"name");T(this,"order");T(this,"skinRequired");this.name=t,this.order=e,this.skinRequired=s}},jd=class extends Ml{constructor(e){super(e,0,!1);T(this,"bones",new Array);T(this,"_target",null);T(this,"positionMode",cr.Fixed);T(this,"spacingMode",He.Fixed);T(this,"rotateMode",Ji.Chain);T(this,"offsetRotation",0);T(this,"position",0);T(this,"spacing",0);T(this,"mixRotate",0);T(this,"mixX",0);T(this,"mixY",0)}set target(e){this._target=e}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}};var cr;(function(f){f[f.Fixed=0]="Fixed",f[f.Percent=1]="Percent"})(cr||(cr={}));var He;(function(f){f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f[f.Proportional=3]="Proportional"})(He||(He={}));var Ji;(function(f){f[f.Tangent=0]="Tangent",f[f.Chain=1]="Chain",f[f.ChainScale=2]="ChainScale"})(Ji||(Ji={}));let tu=class{constructor(t,e,s){T(this,"data");T(this,"skeleton");T(this,"parent",null);T(this,"children",new Array);T(this,"x",0);T(this,"y",0);T(this,"rotation",0);T(this,"scaleX",0);T(this,"scaleY",0);T(this,"shearX",0);T(this,"shearY",0);T(this,"ax",0);T(this,"ay",0);T(this,"arotation",0);T(this,"ascaleX",0);T(this,"ascaleY",0);T(this,"ashearX",0);T(this,"ashearY",0);T(this,"a",0);T(this,"b",0);T(this,"c",0);T(this,"d",0);T(this,"worldY",0);T(this,"worldX",0);T(this,"inherit",be.Normal);T(this,"sorted",!1);T(this,"active",!1);if(!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}isActive(){return this.active}update(t){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,l,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=l,this.ashearY=h;let i=this.parent;if(!i){let m=this.skeleton;const c=m.scaleX,g=m.scaleY,p=(s+l)*ot.degRad,y=(s+90+h)*ot.degRad;this.a=Math.cos(p)*n*c,this.b=Math.cos(y)*r*c,this.c=Math.sin(p)*n*g,this.d=Math.sin(y)*r*g,this.worldX=t*c+m.x,this.worldY=e*g+m.y;return}let a=i.a,o=i.b,d=i.c,u=i.d;switch(this.worldX=a*t+o*e+i.worldX,this.worldY=d*t+u*e+i.worldY,this.inherit){case be.Normal:{const m=(s+l)*ot.degRad,c=(s+90+h)*ot.degRad,g=Math.cos(m)*n,p=Math.cos(c)*r,y=Math.sin(m)*n,w=Math.sin(c)*r;this.a=a*g+o*y,this.b=a*p+o*w,this.c=d*g+u*y,this.d=d*p+u*w;return}case be.OnlyTranslation:{const m=(s+l)*ot.degRad,c=(s+90+h)*ot.degRad;this.a=Math.cos(m)*n,this.b=Math.cos(c)*r,this.c=Math.sin(m)*n,this.d=Math.sin(c)*r;break}case be.NoRotationOrReflection:{let m=1/this.skeleton.scaleX,c=1/this.skeleton.scaleY;a*=m,d*=c;let g=a*a+d*d,p=0;g>1e-4?(g=Math.abs(a*u*c-o*m*d)/g,o=d*g,u=a*g,p=Math.atan2(d,a)*ot.radDeg):(a=0,d=0,p=90-Math.atan2(u,o)*ot.radDeg);const y=(s+l-p)*ot.degRad,w=(s+h-p+90)*ot.degRad,x=Math.cos(y)*n,b=Math.cos(w)*r,S=Math.sin(y)*n,C=Math.sin(w)*r;this.a=a*x-o*S,this.b=a*b-o*C,this.c=d*x+u*S,this.d=d*b+u*C;break}case be.NoScale:case be.NoScaleOrReflection:{s*=ot.degRad;const m=Math.cos(s),c=Math.sin(s);let g=(a*m+o*c)/this.skeleton.scaleX,p=(d*m+u*c)/this.skeleton.scaleY,y=Math.sqrt(g*g+p*p);y>1e-5&&(y=1/y),g*=y,p*=y,y=Math.sqrt(g*g+p*p),this.inherit==be.NoScale&&a*u-o*d<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(y=-y),s=Math.PI/2+Math.atan2(p,g);const w=Math.cos(s)*y,x=Math.sin(s)*y;l*=ot.degRad,h=(90+h)*ot.degRad;const b=Math.cos(l)*n,S=Math.cos(h)*r,C=Math.sin(l)*n,v=Math.sin(h)*r;this.a=g*b+w*C,this.b=g*S+w*v,this.c=p*b+x*C,this.d=p*S+x*v;break}}this.a*=this.skeleton.scaleX,this.b*=this.skeleton.scaleX,this.c*=this.skeleton.scaleY,this.d*=this.skeleton.scaleY}setToSetupPose(){let t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY,this.inherit=t.inherit}updateAppliedTransform(){let t=this.parent;if(!t){this.ax=this.worldX-this.skeleton.x,this.ay=this.worldY-this.skeleton.y,this.arotation=Math.atan2(this.c,this.a)*ot.radDeg,this.ascaleX=Math.sqrt(this.a*this.a+this.c*this.c),this.ascaleY=Math.sqrt(this.b*this.b+this.d*this.d),this.ashearX=0,this.ashearY=Math.atan2(this.a*this.b+this.c*this.d,this.a*this.d-this.b*this.c)*ot.radDeg;return}let e=t.a,s=t.b,n=t.c,r=t.d,l=1/(e*r-s*n),h=r*l,i=s*l,a=n*l,o=e*l,d=this.worldX-t.worldX,u=this.worldY-t.worldY;this.ax=d*h-u*i,this.ay=u*o-d*a;let m,c,g,p;if(this.inherit==be.OnlyTranslation)m=this.a,c=this.b,g=this.c,p=this.d;else{switch(this.inherit){case be.NoRotationOrReflection:{let S=Math.abs(e*r-s*n)/(e*e+n*n);s=-n*this.skeleton.scaleX*S/this.skeleton.scaleY,r=e*this.skeleton.scaleY*S/this.skeleton.scaleX,l=1/(e*r-s*n),h=r*l,i=s*l;break}case be.NoScale:case be.NoScaleOrReflection:let y=ot.cosDeg(this.rotation),w=ot.sinDeg(this.rotation);e=(e*y+s*w)/this.skeleton.scaleX,n=(n*y+r*w)/this.skeleton.scaleY;let x=Math.sqrt(e*e+n*n);x>1e-5&&(x=1/x),e*=x,n*=x,x=Math.sqrt(e*e+n*n),this.inherit==be.NoScale&&l<0!=(this.skeleton.scaleX<0!=this.skeleton.scaleY<0)&&(x=-x);let b=ot.PI/2+Math.atan2(n,e);s=Math.cos(b)*x,r=Math.sin(b)*x,l=1/(e*r-s*n),h=r*l,i=s*l,a=n*l,o=e*l}m=h*this.a-i*this.c,c=h*this.b-i*this.d,g=o*this.c-a*this.a,p=o*this.d-a*this.b}if(this.ashearX=0,this.ascaleX=Math.sqrt(m*m+g*g),this.ascaleX>1e-4){let y=m*p-c*g;this.ascaleY=y/this.ascaleX,this.ashearY=-Math.atan2(m*c+g*p,y)*ot.radDeg,this.arotation=Math.atan2(g,m)*ot.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(c*c+p*p),this.ashearY=0,this.arotation=90-Math.atan2(p,c)*ot.radDeg}getWorldRotationX(){return Math.atan2(this.c,this.a)*ot.radDeg}getWorldRotationY(){return Math.atan2(this.d,this.b)*ot.radDeg}getWorldScaleX(){return Math.sqrt(this.a*this.a+this.c*this.c)}getWorldScaleY(){return Math.sqrt(this.b*this.b+this.d*this.d)}worldToLocal(t){let e=1/(this.a*this.d-this.b*this.c),s=t.x-this.worldX,n=t.y-this.worldY;return t.x=s*this.d*e-n*this.b*e,t.y=n*this.a*e-s*this.c*e,t}localToWorld(t){let e=t.x,s=t.y;return t.x=e*this.a+s*this.b+this.worldX,t.y=e*this.c+s*this.d+this.worldY,t}worldToParent(t){if(t==null)throw new Error("world cannot be null.");return this.parent==null?t:this.parent.worldToLocal(t)}parentToWorld(t){if(t==null)throw new Error("world cannot be null.");return this.parent==null?t:this.parent.localToWorld(t)}worldToLocalRotation(t){let e=ot.sinDeg(t),s=ot.cosDeg(t);return Math.atan2(this.a*e-this.c*s,this.d*s-this.b*e)*ot.radDeg+this.rotation-this.shearX}localToWorldRotation(t){t-=this.rotation-this.shearX;let e=ot.sinDeg(t),s=ot.cosDeg(t);return Math.atan2(s*this.c+e*this.d,s*this.a+e*this.b)*ot.radDeg}rotateWorld(t){t*=ot.degRad;const e=Math.sin(t),s=Math.cos(t),n=this.a,r=this.b;this.a=s*n-e*this.c,this.b=s*r-e*this.d,this.c=e*n+s*this.c,this.d=e*r+s*this.d}},np=class{constructor(t,e){T(this,"data");T(this,"bones");T(this,"target");T(this,"bendDirection",0);T(this,"compress",!1);T(this,"stretch",!1);T(this,"mix",1);T(this,"softness",0);T(this,"active",!1);if(!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0;n<t.bones.length;n++){let r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}`);this.bones.push(r)}let s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=s,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch}isActive(){return this.active}setToSetupPose(){const t=this.data;this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch}update(t){if(this.mix==0)return;let e=this.target,s=this.bones;switch(s.length){case 1:this.apply1(s[0],e.worldX,e.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(s[0],s[1],e.worldX,e.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,e,s,n,r,l,h){let i=t.parent;if(!i)throw new Error("IK bone must have parent.");let a=i.a,o=i.b,d=i.c,u=i.d,m=-t.ashearX-t.arotation,c=0,g=0;switch(t.inherit){case be.OnlyTranslation:c=(e-t.worldX)*ot.signum(t.skeleton.scaleX),g=(s-t.worldY)*ot.signum(t.skeleton.scaleY);break;case be.NoRotationOrReflection:let w=Math.abs(a*u-o*d)/Math.max(1e-4,a*a+d*d),x=a/t.skeleton.scaleX,b=d/t.skeleton.scaleY;o=-b*w*t.skeleton.scaleX,u=x*w*t.skeleton.scaleY,m+=Math.atan2(b,x)*ot.radDeg;default:let S=e-i.worldX,C=s-i.worldY,v=a*u-o*d;Math.abs(v)<=1e-4?(c=0,g=0):(c=(S*u-C*o)/v-t.ax,g=(C*a-S*d)/v-t.ay)}m+=Math.atan2(g,c)*ot.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let p=t.ascaleX,y=t.ascaleY;if(n||r){switch(t.inherit){case be.NoScale:case be.NoScaleOrReflection:c=e-t.worldX,g=s-t.worldY}const w=t.data.length*p;if(w>1e-4){const x=c*c+g*g;if(n&&x<w*w||r&&x>w*w){const b=(Math.sqrt(x)/w-1)*h+1;p*=b,l&&(y*=b)}}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,p,y,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,l,h,i,a){if(t.inherit!=be.Normal||e.inherit!=be.Normal)return;let o=t.ax,d=t.ay,u=t.ascaleX,m=t.ascaleY,c=u,g=m,p=e.ascaleX,y=0,w=0,x=0;u<0?(u=-u,y=180,x=-1):(y=0,x=1),m<0&&(m=-m,x=-x),p<0?(p=-p,w=180):w=0;let b=e.ax,S=0,C=0,v=0,A=t.a,M=t.b,I=t.c,E=t.d,P=Math.abs(u-m)<=1e-4;!P||l?(S=0,C=A*b+t.worldX,v=I*b+t.worldY):(S=e.ay,C=A*b+M*S+t.worldX,v=I*b+E*S+t.worldY);let R=t.parent;if(!R)throw new Error("IK parent must itself have a parent.");A=R.a,M=R.b,I=R.c,E=R.d;let k=A*E-M*I,Y=C-R.worldX,F=v-R.worldY;k=Math.abs(k)<=1e-4?0:1/k;let X=(Y*E-F*M)*k-o,W=(F*A-Y*I)*k-d,B=Math.sqrt(X*X+W*W),N=e.data.length*p,O,Z;if(B<1e-4){this.apply1(t,s,n,!1,l,!1,a),e.updateWorldTransformWith(b,S,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);return}Y=s-R.worldX,F=n-R.worldY;let $=(Y*E-F*M)*k-o,D=(F*A-Y*I)*k-d,_=$*$+D*D;if(i!=0){i*=u*(p+1)*.5;let Tt=Math.sqrt(_),ct=Tt-B-N*u+i;if(ct>0){let Mt=Math.min(1,ct/(i*2))-1;Mt=(ct-i*(1-Mt*Mt))/Tt,$-=Mt*$,D-=Mt*D,_=$*$+D*D}}t:if(P){N*=u;let Tt=(_-B*B-N*N)/(2*B*N);Tt<-1?(Tt=-1,Z=Math.PI*r):Tt>1?(Tt=1,Z=0,l&&(A=(Math.sqrt(_)/(B+N)-1)*a+1,c*=A,h&&(g*=A))):Z=Math.acos(Tt)*r,A=B+N*Tt,M=N*Math.sin(Z),O=Math.atan2(D*A-$*M,$*A+D*M)}else{A=u*N,M=m*N;let Tt=A*A,ct=M*M,Mt=Math.atan2(D,$);I=ct*B*B+Tt*_-Tt*ct;let Rt=-2*ct*B,de=ct-Tt;if(E=Rt*Rt-4*de*I,E>=0){let Ue=Math.sqrt(E);Rt<0&&(Ue=-Ue),Ue=-(Rt+Ue)*.5;let Kt=Ue/de,ps=I/Ue,Vn=Math.abs(Kt)<Math.abs(ps)?Kt:ps;if(Kt=_-Vn*Vn,Kt>=0){F=Math.sqrt(Kt)*r,O=Mt-Math.atan2(F,Vn),Z=Math.atan2(F/m,(Vn-B)/u);break t}}let Ze=ot.PI,Je=B-A,we=Je*Je,Ye=0,Qe=0,je=B+A,ue=je*je,ye=0;I=-A*B/(Tt-ct),I>=-1&&I<=1&&(I=Math.acos(I),Y=A*Math.cos(I)+B,F=M*Math.sin(I),E=Y*Y+F*F,E<we&&(Ze=I,we=E,Je=Y,Ye=F),E>ue&&(Qe=I,ue=E,je=Y,ye=F)),_<=(we+ue)*.5?(O=Mt-Math.atan2(Ye*r,Je),Z=Ze*r):(O=Mt-Math.atan2(ye*r,je),Z=Qe*r)}let lt=Math.atan2(S,b)*x,wt=t.arotation;O=(O-lt)*ot.radDeg+y-wt,O>180?O-=360:O<-180&&(O+=360),t.updateWorldTransformWith(o,d,wt+O*a,c,g,0,0),wt=e.arotation,Z=((Z+lt)*ot.radDeg-e.ashearX)*x+w-wt,Z>180?Z-=360:Z<-180&&(Z+=360),e.updateWorldTransformWith(b,S,wt+Z*a,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}},rp=(Zs=class{constructor(t,e){T(this,"data");T(this,"bones");T(this,"target");T(this,"position",0);T(this,"spacing",0);T(this,"mixRotate",0);T(this,"mixX",0);T(this,"mixY",0);T(this,"spaces",new Array);T(this,"positions",new Array);T(this,"world",new Array);T(this,"curves",new Array);T(this,"lengths",new Array);T(this,"segments",new Array);T(this,"active",!1);if(!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,r=t.bones.length;n<r;n++){let l=e.findBone(t.bones[n].name);if(!l)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(l)}let s=e.findSlot(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}`);this.target=s,this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}setToSetupPose(){const t=this.data;this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}update(t){let e=this.target.getAttachment();if(!(e instanceof Ao))return;let s=this.mixRotate,n=this.mixX,r=this.mixY;if(s==0&&n==0&&r==0)return;let l=this.data,h=l.rotateMode==Ji.Tangent,i=l.rotateMode==Ji.ChainScale,a=this.bones,o=a.length,d=h?o:o+1,u=ht.setArraySize(this.spaces,d),m=i?this.lengths=ht.setArraySize(this.lengths,o):[],c=this.spacing;switch(l.spacingMode){case He.Percent:if(i)for(let C=0,v=d-1;C<v;C++){let A=a[C],M=A.data.length,I=M*A.a,E=M*A.c;m[C]=Math.sqrt(I*I+E*E)}ht.arrayFill(u,1,d,c);break;case He.Proportional:let b=0;for(let C=0,v=d-1;C<v;){let A=a[C],M=A.data.length;if(M<Zs.epsilon)i&&(m[C]=0),u[++C]=c;else{let I=M*A.a,E=M*A.c,P=Math.sqrt(I*I+E*E);i&&(m[C]=P),u[++C]=P,b+=P}}if(b>0){b=d/b*c;for(let C=1;C<d;C++)u[C]*=b}break;default:let S=l.spacingMode==He.Length;for(let C=0,v=d-1;C<v;){let A=a[C],M=A.data.length;if(M<Zs.epsilon)i&&(m[C]=0),u[++C]=c;else{let I=M*A.a,E=M*A.c,P=Math.sqrt(I*I+E*E);i&&(m[C]=P),u[++C]=(S?M+c:c)*P/M}}}let g=this.computeWorldPositions(e,d,h),p=g[0],y=g[1],w=l.offsetRotation,x=!1;if(w==0)x=l.rotateMode==Ji.Chain;else{x=!1;let b=this.target.bone;w*=b.a*b.d-b.b*b.c>0?ot.degRad:-ot.degRad}for(let b=0,S=3;b<o;b++,S+=3){let C=a[b];C.worldX+=(p-C.worldX)*n,C.worldY+=(y-C.worldY)*r;let v=g[S],A=g[S+1],M=v-p,I=A-y;if(i){let E=m[b];if(E!=0){let P=(Math.sqrt(M*M+I*I)/E-1)*s+1;C.a*=P,C.c*=P}}if(p=v,y=A,s>0){let E=C.a,P=C.b,R=C.c,k=C.d,Y=0,F=0,X=0;if(h?Y=g[S-1]:u[b+1]==0?Y=g[S+2]:Y=Math.atan2(I,M),Y-=Math.atan2(R,E),x){F=Math.cos(Y),X=Math.sin(Y);let W=C.data.length;p+=(W*(F*E-X*R)-M)*s,y+=(W*(X*E+F*R)-I)*s}else Y+=w;Y>ot.PI?Y-=ot.PI2:Y<-ot.PI&&(Y+=ot.PI2),Y*=s,F=Math.cos(Y),X=Math.sin(Y),C.a=F*E-X*R,C.b=F*P-X*k,C.c=X*E+F*R,C.d=X*P+F*k}C.updateAppliedTransform()}}computeWorldPositions(t,e,s){let n=this.target,r=this.position,l=this.spaces,h=ht.setArraySize(this.positions,e*3+2),i=this.world,a=t.closed,o=t.worldVerticesLength,d=o/6,u=Zs.NONE;if(!t.constantSpeed){let W=t.lengths;d-=a?1:2;let B=W[d];this.data.positionMode==cr.Percent&&(r*=B);let N;switch(this.data.spacingMode){case He.Percent:N=B;break;case He.Proportional:N=B/e;break;default:N=1}i=ht.setArraySize(this.world,8);for(let O=0,Z=0,$=0;O<e;O++,Z+=3){let D=l[O]*N;r+=D;let _=r;if(a)_%=B,_<0&&(_+=B),$=0;else if(_<0){u!=Zs.BEFORE&&(u=Zs.BEFORE,t.computeWorldVertices(n,2,4,i,0,2)),this.addBeforePosition(_,i,0,h,Z);continue}else if(_>B){u!=Zs.AFTER&&(u=Zs.AFTER,t.computeWorldVertices(n,o-6,4,i,0,2)),this.addAfterPosition(_-B,i,0,h,Z);continue}for(;;$++){let lt=W[$];if(!(_>lt)){if($==0)_/=lt;else{let wt=W[$-1];_=(_-wt)/(lt-wt)}break}}$!=u&&(u=$,a&&$==d?(t.computeWorldVertices(n,o-4,4,i,0,2),t.computeWorldVertices(n,0,4,i,4,2)):t.computeWorldVertices(n,$*6+2,8,i,0,2)),this.addCurvePosition(_,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],h,Z,s||O>0&&D==0)}return h}a?(o+=2,i=ht.setArraySize(this.world,o),t.computeWorldVertices(n,2,o-4,i,0,2),t.computeWorldVertices(n,0,2,i,o-4,2),i[o-2]=i[0],i[o-1]=i[1]):(d--,o-=4,i=ht.setArraySize(this.world,o),t.computeWorldVertices(n,2,o,i,0,2));let m=ht.setArraySize(this.curves,d),c=0,g=i[0],p=i[1],y=0,w=0,x=0,b=0,S=0,C=0,v=0,A=0,M=0,I=0,E=0,P=0,R=0,k=0;for(let W=0,B=2;W<d;W++,B+=6)y=i[B],w=i[B+1],x=i[B+2],b=i[B+3],S=i[B+4],C=i[B+5],v=(g-y*2+x)*.1875,A=(p-w*2+b)*.1875,M=((y-x)*3-g+S)*.09375,I=((w-b)*3-p+C)*.09375,E=v*2+M,P=A*2+I,R=(y-g)*.75+v+M*.16666667,k=(w-p)*.75+A+I*.16666667,c+=Math.sqrt(R*R+k*k),R+=E,k+=P,E+=M,P+=I,c+=Math.sqrt(R*R+k*k),R+=E,k+=P,c+=Math.sqrt(R*R+k*k),R+=E+M,k+=P+I,c+=Math.sqrt(R*R+k*k),m[W]=c,g=S,p=C;this.data.positionMode==cr.Percent&&(r*=c);let Y;switch(this.data.spacingMode){case He.Percent:Y=c;break;case He.Proportional:Y=c/e;break;default:Y=1}let F=this.segments,X=0;for(let W=0,B=0,N=0,O=0;W<e;W++,B+=3){let Z=l[W]*Y;r+=Z;let $=r;if(a)$%=c,$<0&&($+=c),N=0;else if($<0){this.addBeforePosition($,i,0,h,B);continue}else if($>c){this.addAfterPosition($-c,i,o-4,h,B);continue}for(;;N++){let D=m[N];if(!($>D)){if(N==0)$/=D;else{let _=m[N-1];$=($-_)/(D-_)}break}}if(N!=u){u=N;let D=N*6;for(g=i[D],p=i[D+1],y=i[D+2],w=i[D+3],x=i[D+4],b=i[D+5],S=i[D+6],C=i[D+7],v=(g-y*2+x)*.03,A=(p-w*2+b)*.03,M=((y-x)*3-g+S)*.006,I=((w-b)*3-p+C)*.006,E=v*2+M,P=A*2+I,R=(y-g)*.3+v+M*.16666667,k=(w-p)*.3+A+I*.16666667,X=Math.sqrt(R*R+k*k),F[0]=X,D=1;D<8;D++)R+=E,k+=P,E+=M,P+=I,X+=Math.sqrt(R*R+k*k),F[D]=X;R+=E,k+=P,X+=Math.sqrt(R*R+k*k),F[8]=X,R+=E+M,k+=P+I,X+=Math.sqrt(R*R+k*k),F[9]=X,O=0}for($*=X;;O++){let D=F[O];if(!($>D)){if(O==0)$/=D;else{let _=F[O-1];$=O+($-_)/(D-_)}break}}this.addCurvePosition($*.1,g,p,y,w,x,b,S,C,h,B,s||W>0&&Z==0)}return h}addBeforePosition(t,e,s,n,r){let l=e[s],h=e[s+1],i=e[s+2]-l,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){let l=e[s+2],h=e[s+3],i=l-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,l,h,i,a,o,d,u){if(t==0||isNaN(t)){o[d]=e,o[d+1]=s,o[d+2]=Math.atan2(r-s,n-e);return}let m=t*t,c=m*t,g=1-t,p=g*g,y=p*g,w=g*t,x=w*3,b=g*x,S=x*t,C=e*y+n*b+l*S+i*c,v=s*y+r*b+h*S+a*c;o[d]=C,o[d+1]=v,u&&(t<.001?o[d+2]=Math.atan2(r-s,n-e):o[d+2]=Math.atan2(v-(s*p+r*w*2+h*m),C-(e*p+n*w*2+l*m)))}},T(Zs,"NONE",-1),T(Zs,"BEFORE",-2),T(Zs,"AFTER",-3),T(Zs,"epsilon",1e-5),Zs);class XC{constructor(t,e){T(this,"data");T(this,"_bone",null);T(this,"inertia",0);T(this,"strength",0);T(this,"damping",0);T(this,"massInverse",0);T(this,"wind",0);T(this,"gravity",0);T(this,"mix",0);T(this,"_reset",!0);T(this,"ux",0);T(this,"uy",0);T(this,"cx",0);T(this,"cy",0);T(this,"tx",0);T(this,"ty",0);T(this,"xOffset",0);T(this,"xVelocity",0);T(this,"yOffset",0);T(this,"yVelocity",0);T(this,"rotateOffset",0);T(this,"rotateVelocity",0);T(this,"scaleOffset",0);T(this,"scaleVelocity",0);T(this,"active",!1);T(this,"skeleton");T(this,"remaining",0);T(this,"lastTime",0);this.data=t,this.skeleton=e,this.bone=e.bones[t.bone.index],this.inertia=t.inertia,this.strength=t.strength,this.damping=t.damping,this.massInverse=t.massInverse,this.wind=t.wind,this.gravity=t.gravity,this.mix=t.mix}set bone(t){this._bone=t}get bone(){if(this._bone)return this._bone;throw new Error("Bone not set.")}reset(){this.remaining=0,this.lastTime=this.skeleton.time,this._reset=!0,this.xOffset=0,this.xVelocity=0,this.yOffset=0,this.yVelocity=0,this.rotateOffset=0,this.rotateVelocity=0,this.scaleOffset=0,this.scaleVelocity=0}setToSetupPose(){const t=this.data;this.inertia=t.inertia,this.strength=t.strength,this.damping=t.damping,this.massInverse=t.massInverse,this.wind=t.wind,this.gravity=t.gravity,this.mix=t.mix}isActive(){return this.active}update(t){const e=this.mix;if(e==0)return;const s=this.data.x>0,n=this.data.y>0,r=this.data.rotate>0||this.data.shearX>0,l=this.data.scaleX>0,h=this.bone,i=h.data.length;switch(t){case Un.none:return;case Un.reset:this.reset();case Un.update:const a=this.skeleton,o=Math.max(this.skeleton.time-this.lastTime,0);this.remaining+=o,this.lastTime=a.time;const d=h.worldX,u=h.worldY;if(this._reset)this._reset=!1,this.ux=d,this.uy=u;else{let m=this.remaining,c=this.inertia,g=this.data.step,p=this.skeleton.data.referenceScale,y=-1,w=this.data.limit*o,x=w*Math.abs(a.scaleY);if(w*=Math.abs(a.scaleX),s||n){if(s){const b=(this.ux-d)*c;this.xOffset+=b>w?w:b<-w?-w:b,this.ux=d}if(n){const b=(this.uy-u)*c;this.yOffset+=b>x?x:b<-x?-x:b,this.uy=u}if(m>=g){y=Math.pow(this.damping,60*g);const b=this.massInverse*g,S=this.strength,C=this.wind*p*a.scaleX,v=this.gravity*p*a.scaleY;do s&&(this.xVelocity+=(C-this.xOffset*S)*b,this.xOffset+=this.xVelocity*g,this.xVelocity*=y),n&&(this.yVelocity-=(v+this.yOffset*S)*b,this.yOffset+=this.yVelocity*g,this.yVelocity*=y),m-=g;while(m>=g)}s&&(h.worldX+=this.xOffset*e*this.data.x),n&&(h.worldY+=this.yOffset*e*this.data.y)}if(r||l){let b=Math.atan2(h.c,h.a),S=0,C=0,v=0,A=this.cx-h.worldX,M=this.cy-h.worldY;if(A>w?A=w:A<-w&&(A=-w),M>x?M=x:M<-x&&(M=-x),r){v=(this.data.rotate+this.data.shearX)*e;let I=Math.atan2(M+this.ty,A+this.tx)-b-this.rotateOffset*v;this.rotateOffset+=(I-Math.ceil(I*ot.invPI2-.5)*ot.PI2)*c,I=this.rotateOffset*v+b,S=Math.cos(I),C=Math.sin(I),l&&(I=i*h.getWorldScaleX(),I>0&&(this.scaleOffset+=(A*S+M*C)*c/I))}else{S=Math.cos(b),C=Math.sin(b);const I=i*h.getWorldScaleX();I>0&&(this.scaleOffset+=(A*S+M*C)*c/I)}if(m=this.remaining,m>=g){y==-1&&(y=Math.pow(this.damping,60*g));const I=this.massInverse*g,E=this.strength,P=this.wind,R=Mo.yDown?-this.gravity:this.gravity,k=i/p;for(;;)if(m-=g,l&&(this.scaleVelocity+=(P*S-R*C-this.scaleOffset*E)*I,this.scaleOffset+=this.scaleVelocity*g,this.scaleVelocity*=y),r){if(this.rotateVelocity-=((P*C+R*S)*k+this.rotateOffset*E)*I,this.rotateOffset+=this.rotateVelocity*g,this.rotateVelocity*=y,m<g)break;const Y=this.rotateOffset*v+b;S=Math.cos(Y),C=Math.sin(Y)}else if(m<g)break}}this.remaining=m}this.cx=h.worldX,this.cy=h.worldY;break;case Un.pose:s&&(h.worldX+=this.xOffset*e*this.data.x),n&&(h.worldY+=this.yOffset*e*this.data.y)}if(r){let a=this.rotateOffset*e,o=0,d=0,u=0;if(this.data.shearX>0){let m=0;this.data.rotate>0&&(m=a*this.data.rotate,o=Math.sin(m),d=Math.cos(m),u=h.b,h.b=d*u-o*h.d,h.d=o*u+d*h.d),m+=a*this.data.shearX,o=Math.sin(m),d=Math.cos(m),u=h.a,h.a=d*u-o*h.c,h.c=o*u+d*h.c}else a*=this.data.rotate,o=Math.sin(a),d=Math.cos(a),u=h.a,h.a=d*u-o*h.c,h.c=o*u+d*h.c,u=h.b,h.b=d*u-o*h.d,h.d=o*u+d*h.d}if(l){const a=1+this.scaleOffset*e*this.data.scaleX;h.a*=a,h.c*=a}t!=Un.pose&&(this.tx=i*h.a,this.ty=i*h.c),h.updateAppliedTransform()}translate(t,e){this.ux-=t,this.uy-=e,this.cx-=t,this.cy-=e}rotate(t,e,s){const n=s*ot.degRad,r=Math.cos(n),l=Math.sin(n),h=this.cx-t,i=this.cy-e;this.translate(h*r-i*l-h,h*l+i*r-i)}}let ip=class{constructor(t,e){T(this,"data");T(this,"bone");T(this,"color");T(this,"darkColor",null);T(this,"attachment",null);T(this,"attachmentState",0);T(this,"sequenceIndex",-1);T(this,"deform",new Array);if(!t)throw new Error("data cannot be null.");if(!e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new Yt,this.darkColor=t.darkColor?new Yt:null,this.setToSetupPose()}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof Wr)||!(this.attachment instanceof Wr)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}},ap=class{constructor(t,e){T(this,"data");T(this,"bones");T(this,"target");T(this,"mixRotate",0);T(this,"mixX",0);T(this,"mixY",0);T(this,"mixScaleX",0);T(this,"mixScaleY",0);T(this,"mixShearY",0);T(this,"temp",new Sl);T(this,"active",!1);if(!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0;n<t.bones.length;n++){let r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(r)}let s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=s,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY}isActive(){return this.active}setToSetupPose(){const t=this.data;this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY}update(t){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleY==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){let t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.a,o=i.b,d=i.c,u=i.d,m=a*u-o*d>0?ot.degRad:-ot.degRad,c=this.data.offsetRotation*m,g=this.data.offsetShearY*m,p=this.bones;for(let y=0,w=p.length;y<w;y++){let x=p[y];if(t!=0){let b=x.a,S=x.b,C=x.c,v=x.d,A=Math.atan2(d,a)-Math.atan2(C,b)+c;A>ot.PI?A-=ot.PI2:A<-ot.PI&&(A+=ot.PI2),A*=t;let M=Math.cos(A),I=Math.sin(A);x.a=M*b-I*C,x.b=M*S-I*v,x.c=I*b+M*C,x.d=I*S+M*v}if(h){let b=this.temp;i.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),x.worldX+=(b.x-x.worldX)*e,x.worldY+=(b.y-x.worldY)*s}if(n!=0){let b=Math.sqrt(x.a*x.a+x.c*x.c);b!=0&&(b=(b+(Math.sqrt(a*a+d*d)-b+this.data.offsetScaleX)*n)/b),x.a*=b,x.c*=b}if(r!=0){let b=Math.sqrt(x.b*x.b+x.d*x.d);b!=0&&(b=(b+(Math.sqrt(o*o+u*u)-b+this.data.offsetScaleY)*r)/b),x.b*=b,x.d*=b}if(l>0){let b=x.b,S=x.d,C=Math.atan2(S,b),v=Math.atan2(u,o)-Math.atan2(d,a)-(C-Math.atan2(x.c,x.a));v>ot.PI?v-=ot.PI2:v<-ot.PI&&(v+=ot.PI2),v=C+(v+g)*l;let A=Math.sqrt(b*b+S*S);x.b=Math.cos(v)*A,x.d=Math.sin(v)*A}x.updateAppliedTransform()}}applyRelativeWorld(){let t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.a,o=i.b,d=i.c,u=i.d,m=a*u-o*d>0?ot.degRad:-ot.degRad,c=this.data.offsetRotation*m,g=this.data.offsetShearY*m,p=this.bones;for(let y=0,w=p.length;y<w;y++){let x=p[y];if(t!=0){let b=x.a,S=x.b,C=x.c,v=x.d,A=Math.atan2(d,a)+c;A>ot.PI?A-=ot.PI2:A<-ot.PI&&(A+=ot.PI2),A*=t;let M=Math.cos(A),I=Math.sin(A);x.a=M*b-I*C,x.b=M*S-I*v,x.c=I*b+M*C,x.d=I*S+M*v}if(h){let b=this.temp;i.localToWorld(b.set(this.data.offsetX,this.data.offsetY)),x.worldX+=b.x*e,x.worldY+=b.y*s}if(n!=0){let b=(Math.sqrt(a*a+d*d)-1+this.data.offsetScaleX)*n+1;x.a*=b,x.c*=b}if(r!=0){let b=(Math.sqrt(o*o+u*u)-1+this.data.offsetScaleY)*r+1;x.b*=b,x.d*=b}if(l>0){let b=Math.atan2(u,o)-Math.atan2(d,a);b>ot.PI?b-=ot.PI2:b<-ot.PI&&(b+=ot.PI2);let S=x.b,C=x.d;b=Math.atan2(C,S)+(b-ot.PI/2+g)*l;let v=Math.sqrt(S*S+C*C);x.b=Math.cos(b)*v,x.d=Math.sin(b)*v}x.updateAppliedTransform()}}applyAbsoluteLocal(){let t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){let d=i[a],u=d.arotation;t!=0&&(u+=(h.arotation-u+this.data.offsetRotation)*t);let m=d.ax,c=d.ay;m+=(h.ax-m+this.data.offsetX)*e,c+=(h.ay-c+this.data.offsetY)*s;let g=d.ascaleX,p=d.ascaleY;n!=0&&g!=0&&(g=(g+(h.ascaleX-g+this.data.offsetScaleX)*n)/g),r!=0&&p!=0&&(p=(p+(h.ascaleY-p+this.data.offsetScaleY)*r)/p);let y=d.ashearY;l!=0&&(y+=(h.ashearY-y+this.data.offsetShearY)*l),d.updateWorldTransformWith(m,c,u,g,p,d.ashearX,y)}}applyRelativeLocal(){let t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){let d=i[a],u=d.arotation+(h.arotation+this.data.offsetRotation)*t,m=d.ax+(h.ax+this.data.offsetX)*e,c=d.ay+(h.ay+this.data.offsetY)*s,g=d.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*n+1),p=d.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*r+1),y=d.ashearY+(h.ashearY+this.data.offsetShearY)*l;d.updateWorldTransformWith(m,c,u,g,p,d.ashearX,y)}}},Mo=(vi=class{constructor(t){T(this,"data");T(this,"bones");T(this,"slots");T(this,"drawOrder");T(this,"ikConstraints");T(this,"transformConstraints");T(this,"pathConstraints");T(this,"physicsConstraints");T(this,"_updateCache",new Array);T(this,"skin",null);T(this,"color");T(this,"scaleX",1);T(this,"_scaleY",1);T(this,"x",0);T(this,"y",0);T(this,"time",0);if(!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){let s=t.bones[e],n;if(!s.parent)n=new tu(s,this,null);else{let r=this.bones[s.parent.index];n=new tu(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){let s=t.slots[e],n=this.bones[s.boneData.index],r=new ip(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){let s=t.ikConstraints[e];this.ikConstraints.push(new np(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){let s=t.transformConstraints[e];this.transformConstraints.push(new ap(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){let s=t.pathConstraints[e];this.pathConstraints.push(new rp(s,this))}this.physicsConstraints=new Array;for(let e=0;e<t.physicsConstraints.length;e++){let s=t.physicsConstraints[e];this.physicsConstraints.push(new XC(s,this))}this.color=new Yt(1,1,1,1),this.updateCache()}get scaleY(){return vi.yDown?-this._scaleY:this._scaleY}set scaleY(t){this._scaleY=t}updateCache(){let t=this._updateCache;t.length=0;let e=this.bones;for(let u=0,m=e.length;u<m;u++){let c=e[u];c.sorted=c.data.skinRequired,c.active=!c.sorted}if(this.skin){let u=this.skin.bones;for(let m=0,c=this.skin.bones.length;m<c;m++){let g=this.bones[u[m].index];do g.sorted=!1,g.active=!0,g=g.parent;while(g)}}let s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,l=this.physicsConstraints,h=s.length,i=n.length,a=r.length,o=this.physicsConstraints.length,d=h+i+a+o;t:for(let u=0;u<d;u++){for(let m=0;m<h;m++){let c=s[m];if(c.data.order==u){this.sortIkConstraint(c);continue t}}for(let m=0;m<i;m++){let c=n[m];if(c.data.order==u){this.sortTransformConstraint(c);continue t}}for(let m=0;m<a;m++){let c=r[m];if(c.data.order==u){this.sortPathConstraint(c);continue t}}for(let m=0;m<o;m++){const c=l[m];if(c.data.order==u){this.sortPhysicsConstraint(c);continue t}}}for(let u=0,m=e.length;u<m;u++)this.sortBone(e[u])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&ht.contains(this.skin.constraints,t.data,!0)),!t.active)return;let e=t.target;this.sortBone(e);let s=t.bones,n=s[0];if(this.sortBone(n),s.length==1)this._updateCache.push(t),this.sortReset(n.children);else{let r=s[s.length-1];this.sortBone(r),this._updateCache.push(t),this.sortReset(n.children),r.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&ht.contains(this.skin.constraints,t.data,!0)),!t.active)return;let e=t.target,s=e.data.index,n=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);let r=e.getAttachment();r instanceof Ao&&this.sortPathConstraintAttachmentWith(r,n);let l=t.bones,h=l.length;for(let i=0;i<h;i++)this.sortBone(l[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(l[i].children);for(let i=0;i<h;i++)l[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&ht.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);let e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){let r=e[n];this.sortBone(r.parent),this.sortBone(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){let n=t.attachments[e];if(n)for(let r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof Ao))return;let s=t.bones;if(!s)this.sortBone(e);else{let n=this.bones;for(let r=0,l=s.length;r<l;){let h=s[r++];for(h+=r;r<h;)this.sortBone(n[s[r++]])}}}sortPhysicsConstraint(t){const e=t.bone;t.active=e.active&&(!t.data.skinRequired||this.skin!=null&&ht.contains(this.skin.constraints,t.data,!0)),t.active&&(this.sortBone(e),this._updateCache.push(t),this.sortReset(e.children),e.sorted=!0)}sortBone(t){if(!t||t.sorted)return;let e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){let n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(t){if(t==null)throw new Error("physics is undefined");let e=this.bones;for(let n=0,r=e.length;n<r;n++){let l=e[n];l.ax=l.x,l.ay=l.y,l.arotation=l.rotation,l.ascaleX=l.scaleX,l.ascaleY=l.scaleY,l.ashearX=l.shearX,l.ashearY=l.shearY}let s=this._updateCache;for(let n=0,r=s.length;n<r;n++)s[n].update(t)}updateWorldTransformWith(t,e){if(!e)throw new Error("parent cannot be null.");let s=this.bones;for(let p=1,y=s.length;p<y;p++){let w=s[p];w.ax=w.x,w.ay=w.y,w.arotation=w.rotation,w.ascaleX=w.scaleX,w.ascaleY=w.scaleY,w.ashearX=w.shearX,w.ashearY=w.shearY}let n=this.getRootBone();if(!n)throw new Error("Root bone must not be null.");let r=e.a,l=e.b,h=e.c,i=e.d;n.worldX=r*this.x+l*this.y+e.worldX,n.worldY=h*this.x+i*this.y+e.worldY;const a=(n.rotation+n.shearX)*ot.degRad,o=(n.rotation+90+n.shearY)*ot.degRad,d=Math.cos(a)*n.scaleX,u=Math.cos(o)*n.scaleY,m=Math.sin(a)*n.scaleX,c=Math.sin(o)*n.scaleY;n.a=(r*d+l*m)*this.scaleX,n.b=(r*u+l*c)*this.scaleX,n.c=(h*d+i*m)*this.scaleY,n.d=(h*u+i*c)*this.scaleY;let g=this._updateCache;for(let p=0,y=g.length;p<y;p++){let w=g[p];w!=n&&w.update(t)}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){for(const t of this.bones)t.setToSetupPose();for(const t of this.ikConstraints)t.setToSetupPose();for(const t of this.transformConstraints)t.setToSetupPose();for(const t of this.pathConstraints)t.setToSetupPose();for(const t of this.physicsConstraints)t.setToSetupPose()}setSlotsToSetupPose(){let t=this.slots;ht.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");let e=this.bones;for(let s=0,n=e.length;s<n;s++){let r=e[s];if(r.data.name==t)return r}return null}findSlot(t){if(!t)throw new Error("slotName cannot be null.");let e=this.slots;for(let s=0,n=e.length;s<n;s++){let r=e[s];if(r.data.name==t)return r}return null}setSkinByName(t){let e=this.data.findSkin(t);if(!e)throw new Error("Skin not found: "+t);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{let e=this.slots;for(let s=0,n=e.length;s<n;s++){let r=e[s],l=r.data.attachmentName;if(l){let h=t.getAttachment(s,l);h&&r.setAttachment(h)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){let s=this.data.findSlot(t);if(!s)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(s.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){let s=this.skin.getAttachment(t,e);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");let s=this.slots;for(let n=0,r=s.length;n<r;n++){let l=s[n];if(l.data.name==t){let h=null;if(e&&(h=this.getAttachment(n,e),!h))throw new Error("Attachment not found: "+e+", for slot: "+t);l.setAttachment(h);return}}throw new Error("Slot not found: "+t)}findIkConstraint(t){var e;if(!t)throw new Error("constraintName cannot be null.");return(e=this.ikConstraints.find(s=>s.data.name==t))!=null?e:null}findTransformConstraint(t){var e;if(!t)throw new Error("constraintName cannot be null.");return(e=this.transformConstraints.find(s=>s.data.name==t))!=null?e:null}findPathConstraint(t){var e;if(!t)throw new Error("constraintName cannot be null.");return(e=this.pathConstraints.find(s=>s.data.name==t))!=null?e:null}findPhysicsConstraint(t){var e;if(t==null)throw new Error("constraintName cannot be null.");return(e=this.physicsConstraints.find(s=>s.data.name==t))!=null?e:null}getBoundsRect(t){let e=new Sl,s=new Sl;return this.getBounds(e,s,void 0,t),{x:e.x,y:e.y,width:s.x,height:s.y}}getBounds(t,e,s=new Array(2),n=null){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");let r=this.drawOrder,l=Number.POSITIVE_INFINITY,h=Number.POSITIVE_INFINITY,i=Number.NEGATIVE_INFINITY,a=Number.NEGATIVE_INFINITY;for(let o=0,d=r.length;o<d;o++){let u=r[o];if(!u.bone.active)continue;let m=0,c=null,g=null,p=u.getAttachment();if(p instanceof Al)m=8,c=ht.setArraySize(s,m,0),p.computeWorldVertices(u,c,0,2),g=vi.quadTriangles;else if(p instanceof vo){let y=p;m=y.worldVerticesLength,c=ht.setArraySize(s,m,0),y.computeWorldVertices(u,0,m,c,0,2),g=y.triangles}else if(p instanceof qa&&n!=null){n.clipStart(u,p);continue}if(c&&g){n!=null&&n.isClipping()&&(n.clipTriangles(c,g,g.length),c=n.clippedVertices,m=n.clippedVertices.length);for(let y=0,w=c.length;y<w;y+=2){let x=c[y],b=c[y+1];l=Math.min(l,x),h=Math.min(h,b),i=Math.max(i,x),a=Math.max(a,b)}}n!=null&&n.clipEndWithSlot(u)}n!=null&&n.clipEnd(),t.set(l,h),e.set(i-l,a-h)}update(t){this.time+=t}physicsTranslate(t,e){const s=this.physicsConstraints;for(let n=0,r=s.length;n<r;n++)s[n].translate(t,e)}physicsRotate(t,e,s){const n=this.physicsConstraints;for(let r=0,l=n.length;r<l;r++)n[r].rotate(t,e,s)}},T(vi,"quadTriangles",[0,1,2,2,3,0]),T(vi,"yDown",!1),vi);var Un;(function(f){f[f.none=0]="none",f[f.reset=1]="reset",f[f.update=2]="update",f[f.pose=3]="pose"})(Un||(Un={}));let eu=class{constructor(t,e){T(this,"data");T(this,"intValue",0);T(this,"floatValue",0);T(this,"stringValue",null);T(this,"time",0);T(this,"volume",0);T(this,"balance",0);if(!e)throw new Error("data cannot be null.");this.time=t,this.data=e}},su=class{constructor(t){T(this,"name");T(this,"intValue",0);T(this,"floatValue",0);T(this,"stringValue",null);T(this,"audioPath",null);T(this,"volume",0);T(this,"balance",0);this.name=t}},nu=class extends Ml{constructor(e){super(e,0,!1);T(this,"bones",new Array);T(this,"_target",null);T(this,"bendDirection",0);T(this,"compress",!1);T(this,"stretch",!1);T(this,"uniform",!1);T(this,"mix",0);T(this,"softness",0)}set target(e){this._target=e}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}};class op extends Ml{constructor(e){super(e,0,!1);T(this,"_bone",null);T(this,"x",0);T(this,"y",0);T(this,"rotate",0);T(this,"scaleX",0);T(this,"shearX",0);T(this,"limit",0);T(this,"step",0);T(this,"inertia",0);T(this,"strength",0);T(this,"damping",0);T(this,"massInverse",0);T(this,"wind",0);T(this,"gravity",0);T(this,"mix",0);T(this,"inertiaGlobal",!1);T(this,"strengthGlobal",!1);T(this,"dampingGlobal",!1);T(this,"massGlobal",!1);T(this,"windGlobal",!1);T(this,"gravityGlobal",!1);T(this,"mixGlobal",!1)}set bone(e){this._bone=e}get bone(){if(this._bone)return this._bone;throw new Error("BoneData not set.")}}let Tl=class{constructor(){T(this,"name",null);T(this,"bones",new Array);T(this,"slots",new Array);T(this,"skins",new Array);T(this,"defaultSkin",null);T(this,"events",new Array);T(this,"animations",new Array);T(this,"ikConstraints",new Array);T(this,"transformConstraints",new Array);T(this,"pathConstraints",new Array);T(this,"physicsConstraints",new Array);T(this,"x",0);T(this,"y",0);T(this,"width",0);T(this,"height",0);T(this,"referenceScale",100);T(this,"version",null);T(this,"hash",null);T(this,"fps",0);T(this,"imagesPath",null);T(this,"audioPath",null)}findBone(t){if(!t)throw new Error("boneName cannot be null.");let e=this.bones;for(let s=0,n=e.length;s<n;s++){let r=e[s];if(r.name==t)return r}return null}findSlot(t){if(!t)throw new Error("slotName cannot be null.");let e=this.slots;for(let s=0,n=e.length;s<n;s++){let r=e[s];if(r.name==t)return r}return null}findSkin(t){if(!t)throw new Error("skinName cannot be null.");let e=this.skins;for(let s=0,n=e.length;s<n;s++){let r=e[s];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");let e=this.events;for(let s=0,n=e.length;s<n;s++){let r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");let e=this.animations;for(let s=0,n=e.length;s<n;s++){let r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPhysicsConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.physicsConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}},ru=class{constructor(t=0,e,s){T(this,"slotIndex");T(this,"name");T(this,"attachment");this.slotIndex=t,this.name=e,this.attachment=s}},El=class{constructor(t){T(this,"name");T(this,"attachments",new Array);T(this,"bones",Array());T(this,"constraints",new Array);T(this,"color",new Yt(.99607843,.61960787,.30980393,1));if(!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(!s)throw new Error("attachment cannot be null.");let n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let n=0;n<t.bones.length;n++){let r=t.bones[n],l=!1;for(let h=0;h<this.bones.length;h++)if(this.bones[h]==r){l=!0;break}l||this.bones.push(r)}for(let n=0;n<t.constraints.length;n++){let r=t.constraints[n],l=!1;for(let h=0;h<this.constraints.length;h++)if(this.constraints[h]==r){l=!0;break}l||this.constraints.push(r)}let e=t.getAttachments();for(let n=0;n<e.length;n++){var s=e[n];this.setAttachment(s.slotIndex,s.name,s.attachment)}}copySkin(t){for(let n=0;n<t.bones.length;n++){let r=t.bones[n],l=!1;for(let h=0;h<this.bones.length;h++)if(this.bones[h]==r){l=!0;break}l||this.bones.push(r)}for(let n=0;n<t.constraints.length;n++){let r=t.constraints[n],l=!1;for(let h=0;h<this.constraints.length;h++)if(this.constraints[h]==r){l=!0;break}l||this.constraints.push(r)}let e=t.getAttachments();for(let n=0;n<e.length;n++){var s=e[n];s.attachment&&(s.attachment instanceof vo?(s.attachment=s.attachment.newLinkedMesh(),this.setAttachment(s.slotIndex,s.name,s.attachment)):(s.attachment=s.attachment.copy(),this.setAttachment(s.slotIndex,s.name,s.attachment)))}}getAttachment(t,e){let s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){let s=this.attachments[t];s&&delete s[e]}getAttachments(){let t=new Array;for(var e=0;e<this.attachments.length;e++){let s=this.attachments[e];if(s)for(let n in s){let r=s[n];r&&t.push(new ru(e,n,r))}}return t}getAttachmentsForSlot(t,e){let s=this.attachments[t];if(s)for(let n in s){let r=s[n];r&&e.push(new ru(t,n,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){let r=t.slots[n],l=r.getAttachment();if(l&&s<e.attachments.length){let h=e.attachments[s];for(let i in h){let a=h[i];if(l==a){let o=this.getAttachment(s,i);o&&r.setAttachment(o);break}}}s++}}},iu=class{constructor(t,e,s){T(this,"index",0);T(this,"name");T(this,"boneData");T(this,"color",new Yt(1,1,1,1));T(this,"darkColor",null);T(this,"attachmentName",null);T(this,"blendMode",hi.Normal);T(this,"visible",!0);if(t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");if(!s)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}};var hi;(function(f){f[f.Normal=0]="Normal",f[f.Additive=1]="Additive",f[f.Multiply=2]="Multiply",f[f.Screen=3]="Screen"})(hi||(hi={}));let au=class extends Ml{constructor(e){super(e,0,!1);T(this,"bones",new Array);T(this,"_target",null);T(this,"mixRotate",0);T(this,"mixX",0);T(this,"mixY",0);T(this,"mixScaleX",0);T(this,"mixScaleY",0);T(this,"mixShearY",0);T(this,"offsetRotation",0);T(this,"offsetX",0);T(this,"offsetY",0);T(this,"offsetScaleX",0);T(this,"offsetScaleY",0);T(this,"offsetShearY",0);T(this,"relative",!1);T(this,"local",!1)}set target(e){this._target=e}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}},ou=class{constructor(t){T(this,"scale",1);T(this,"attachmentLoader");T(this,"linkedMeshes",new Array);this.attachmentLoader=t}readSkeletonData(t){var o;let e=this.scale,s=new Tl;s.name="";let n=new lp(t),r=n.readInt32(),l=n.readInt32();s.hash=l==0&&r==0?null:l.toString(16)+r.toString(16),s.version=n.readString(),s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat(),s.referenceScale=n.readFloat()*e;let h=n.readBoolean();h&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let i=0;i=n.readInt(!0);for(let d=0;d<i;d++){let u=n.readString();if(!u)throw new Error("String in string table must not be null.");n.strings.push(u)}i=n.readInt(!0);for(let d=0;d<i;d++){let u=n.readString();if(!u)throw new Error("Bone name must not be null.");let m=d==0?null:s.bones[n.readInt(!0)],c=new Qd(d,u,m);c.rotation=n.readFloat(),c.x=n.readFloat()*e,c.y=n.readFloat()*e,c.scaleX=n.readFloat(),c.scaleY=n.readFloat(),c.shearX=n.readFloat(),c.shearY=n.readFloat(),c.length=n.readFloat()*e,c.inherit=n.readByte(),c.skinRequired=n.readBoolean(),h&&(Yt.rgba8888ToColor(c.color,n.readInt32()),c.icon=(o=n.readString())!=null?o:void 0,c.visible=n.readBoolean()),s.bones.push(c)}i=n.readInt(!0);for(let d=0;d<i;d++){let u=n.readString();if(!u)throw new Error("Slot name must not be null.");let m=s.bones[n.readInt(!0)],c=new iu(d,u,m);Yt.rgba8888ToColor(c.color,n.readInt32());let g=n.readInt32();g!=-1&&Yt.rgb888ToColor(c.darkColor=new Yt,g),c.attachmentName=n.readStringRef(),c.blendMode=n.readInt(!0),h&&(c.visible=n.readBoolean()),s.slots.push(c)}i=n.readInt(!0);for(let d=0,u;d<i;d++){let m=n.readString();if(!m)throw new Error("IK constraint data name must not be null.");let c=new nu(m);c.order=n.readInt(!0),u=n.readInt(!0);for(let p=0;p<u;p++)c.bones.push(s.bones[n.readInt(!0)]);c.target=s.bones[n.readInt(!0)];let g=n.readByte();c.skinRequired=(g&1)!=0,c.bendDirection=(g&2)!=0?1:-1,c.compress=(g&4)!=0,c.stretch=(g&8)!=0,c.uniform=(g&16)!=0,(g&32)!=0&&(c.mix=(g&64)!=0?n.readFloat():1),(g&128)!=0&&(c.softness=n.readFloat()*e),s.ikConstraints.push(c)}i=n.readInt(!0);for(let d=0,u;d<i;d++){let m=n.readString();if(!m)throw new Error("Transform constraint data name must not be null.");let c=new au(m);c.order=n.readInt(!0),u=n.readInt(!0);for(let p=0;p<u;p++)c.bones.push(s.bones[n.readInt(!0)]);c.target=s.bones[n.readInt(!0)];let g=n.readByte();c.skinRequired=(g&1)!=0,c.local=(g&2)!=0,c.relative=(g&4)!=0,(g&8)!=0&&(c.offsetRotation=n.readFloat()),(g&16)!=0&&(c.offsetX=n.readFloat()*e),(g&32)!=0&&(c.offsetY=n.readFloat()*e),(g&64)!=0&&(c.offsetScaleX=n.readFloat()),(g&128)!=0&&(c.offsetScaleY=n.readFloat()),g=n.readByte(),(g&1)!=0&&(c.offsetShearY=n.readFloat()),(g&2)!=0&&(c.mixRotate=n.readFloat()),(g&4)!=0&&(c.mixX=n.readFloat()),(g&8)!=0&&(c.mixY=n.readFloat()),(g&16)!=0&&(c.mixScaleX=n.readFloat()),(g&32)!=0&&(c.mixScaleY=n.readFloat()),(g&64)!=0&&(c.mixShearY=n.readFloat()),s.transformConstraints.push(c)}i=n.readInt(!0);for(let d=0,u;d<i;d++){let m=n.readString();if(!m)throw new Error("Path constraint data name must not be null.");let c=new jd(m);c.order=n.readInt(!0),c.skinRequired=n.readBoolean(),u=n.readInt(!0);for(let p=0;p<u;p++)c.bones.push(s.bones[n.readInt(!0)]);c.target=s.slots[n.readInt(!0)];const g=n.readByte();c.positionMode=g&1,c.spacingMode=g>>1&3,c.rotateMode=g>>3&3,(g&128)!=0&&(c.offsetRotation=n.readFloat()),c.position=n.readFloat(),c.positionMode==cr.Fixed&&(c.position*=e),c.spacing=n.readFloat(),(c.spacingMode==He.Length||c.spacingMode==He.Fixed)&&(c.spacing*=e),c.mixRotate=n.readFloat(),c.mixX=n.readFloat(),c.mixY=n.readFloat(),s.pathConstraints.push(c)}i=n.readInt(!0);for(let d=0,u;d<i;d++){const m=n.readString();if(!m)throw new Error("Physics constraint data name must not be null.");const c=new op(m);c.order=n.readInt(!0),c.bone=s.bones[n.readInt(!0)];let g=n.readByte();c.skinRequired=(g&1)!=0,(g&2)!=0&&(c.x=n.readFloat()),(g&4)!=0&&(c.y=n.readFloat()),(g&8)!=0&&(c.rotate=n.readFloat()),(g&16)!=0&&(c.scaleX=n.readFloat()),(g&32)!=0&&(c.shearX=n.readFloat()),c.limit=((g&64)!=0?n.readFloat():5e3)*e,c.step=1/n.readUnsignedByte(),c.inertia=n.readFloat(),c.strength=n.readFloat(),c.damping=n.readFloat(),c.massInverse=(g&128)!=0?n.readFloat():1,c.wind=n.readFloat(),c.gravity=n.readFloat(),g=n.readByte(),(g&1)!=0&&(c.inertiaGlobal=!0),(g&2)!=0&&(c.strengthGlobal=!0),(g&4)!=0&&(c.dampingGlobal=!0),(g&8)!=0&&(c.massGlobal=!0),(g&16)!=0&&(c.windGlobal=!0),(g&32)!=0&&(c.gravityGlobal=!0),(g&64)!=0&&(c.mixGlobal=!0),c.mix=(g&128)!=0?n.readFloat():1,s.physicsConstraints.push(c)}let a=this.readSkin(n,s,!0,h);a&&(s.defaultSkin=a,s.skins.push(a));{let d=s.skins.length;for(ht.setArraySize(s.skins,i=d+n.readInt(!0));d<i;d++){let u=this.readSkin(n,s,!1,h);if(!u)throw new Error("readSkin() should not have returned null.");s.skins[d]=u}}i=this.linkedMeshes.length;for(let d=0;d<i;d++){let u=this.linkedMeshes[d];const m=s.skins[u.skinIndex];if(!u.parent)throw new Error("Linked mesh parent must not be null");let c=m.getAttachment(u.slotIndex,u.parent);if(!c)throw new Error(`Parent mesh not found: ${u.parent}`);u.mesh.timelineAttachment=u.inheritTimeline?c:u.mesh,u.mesh.setParentMesh(c),u.mesh.region!=null&&u.mesh.updateRegion()}this.linkedMeshes.length=0,i=n.readInt(!0);for(let d=0;d<i;d++){let u=n.readString();if(!u)throw new Error("Event data name must not be null");let m=new su(u);m.intValue=n.readInt(!1),m.floatValue=n.readFloat(),m.stringValue=n.readString(),m.audioPath=n.readString(),m.audioPath&&(m.volume=n.readFloat(),m.balance=n.readFloat()),s.events.push(m)}i=n.readInt(!0);for(let d=0;d<i;d++){let u=n.readString();if(!u)throw new Error("Animatio name must not be null.");s.animations.push(this.readAnimation(n,u,s))}return s}readSkin(t,e,s,n){let r=null,l=0;if(s){if(l=t.readInt(!0),l==0)return null;r=new El("default")}else{let h=t.readString();if(!h)throw new Error("Skin name must not be null.");r=new El(h),n&&Yt.rgba8888ToColor(r.color,t.readInt32()),r.bones.length=t.readInt(!0);for(let i=0,a=r.bones.length;i<a;i++)r.bones[i]=e.bones[t.readInt(!0)];for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.pathConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.physicsConstraints[t.readInt(!0)]);l=t.readInt(!0)}for(let h=0;h<l;h++){let i=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){let d=t.readStringRef();if(!d)throw new Error("Attachment name must not be null");let u=this.readAttachment(t,e,r,i,d,n);u&&r.setAttachment(i,d,u)}}return r}readAttachment(t,e,s,n,r,l){let h=this.scale,i=t.readByte();const a=(i&8)!=0?t.readStringRef():r;if(!a)throw new Error("Attachment name must not be null");switch(i&7){case ci.Region:{let o=(i&16)!=0?t.readStringRef():null;const d=(i&32)!=0?t.readInt32():4294967295,u=(i&64)!=0?this.readSequence(t):null;let m=(i&128)!=0?t.readFloat():0,c=t.readFloat(),g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),x=t.readFloat();o||(o=a);let b=this.attachmentLoader.newRegionAttachment(s,a,o,u);return b?(b.path=o,b.x=c*h,b.y=g*h,b.scaleX=p,b.scaleY=y,b.rotation=m,b.width=w*h,b.height=x*h,Yt.rgba8888ToColor(b.color,d),b.sequence=u,u==null&&b.updateRegion(),b):null}case ci.BoundingBox:{let o=this.readVertices(t,(i&16)!=0),d=l?t.readInt32():0,u=this.attachmentLoader.newBoundingBoxAttachment(s,a);return u?(u.worldVerticesLength=o.length,u.vertices=o.vertices,u.bones=o.bones,l&&Yt.rgba8888ToColor(u.color,d),u):null}case ci.Mesh:{let o=(i&16)!=0?t.readStringRef():a;const d=(i&32)!=0?t.readInt32():4294967295,u=(i&64)!=0?this.readSequence(t):null,m=t.readInt(!0),c=this.readVertices(t,(i&128)!=0),g=this.readFloatArray(t,c.length,1),p=this.readShortArray(t,(c.length-m-2)*3);let y=[],w=0,x=0;l&&(y=this.readShortArray(t,t.readInt(!0)),w=t.readFloat(),x=t.readFloat()),o||(o=a);let b=this.attachmentLoader.newMeshAttachment(s,a,o,u);return b?(b.path=o,Yt.rgba8888ToColor(b.color,d),b.bones=c.bones,b.vertices=c.vertices,b.worldVerticesLength=c.length,b.triangles=p,b.regionUVs=g,u==null&&b.updateRegion(),b.hullLength=m<<1,b.sequence=u,l&&(b.edges=y,b.width=w*h,b.height=x*h),b):null}case ci.LinkedMesh:{const o=(i&16)!=0?t.readStringRef():a;if(o==null)throw new Error("Path of linked mesh must not be null");const d=(i&32)!=0?t.readInt32():4294967295,u=(i&64)!=0?this.readSequence(t):null,m=(i&128)!=0,c=t.readInt(!0),g=t.readStringRef();let p=0,y=0;l&&(p=t.readFloat(),y=t.readFloat());let w=this.attachmentLoader.newMeshAttachment(s,a,o,u);return w?(w.path=o,Yt.rgba8888ToColor(w.color,d),w.sequence=u,l&&(w.width=p*h,w.height=y*h),this.linkedMeshes.push(new $C(w,c,n,g,m)),w):null}case ci.Path:{const o=(i&16)!=0,d=(i&32)!=0,u=this.readVertices(t,(i&64)!=0),m=ht.newArray(u.length/6,0);for(let p=0,y=m.length;p<y;p++)m[p]=t.readFloat()*h;const c=l?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(s,a);return g?(g.closed=o,g.constantSpeed=d,g.worldVerticesLength=u.length,g.vertices=u.vertices,g.bones=u.bones,g.lengths=m,l&&Yt.rgba8888ToColor(g.color,c),g):null}case ci.Point:{const o=t.readFloat(),d=t.readFloat(),u=t.readFloat(),m=l?t.readInt32():0,c=this.attachmentLoader.newPointAttachment(s,a);return c?(c.x=d*h,c.y=u*h,c.rotation=o,l&&Yt.rgba8888ToColor(c.color,m),c):null}case ci.Clipping:{const o=t.readInt(!0),d=this.readVertices(t,(i&16)!=0);let u=l?t.readInt32():0,m=this.attachmentLoader.newClippingAttachment(s,a);return m?(m.endSlot=e.slots[o],m.worldVerticesLength=d.length,m.vertices=d.vertices,m.bones=d.bones,l&&Yt.rgba8888ToColor(m.color,u),m):null}}return null}readSequence(t){let e=new Gg(t.readInt(!0));return e.start=t.readInt(!0),e.digits=t.readInt(!0),e.setupIndex=t.readInt(!0),e}readVertices(t,e){const s=this.scale,n=t.readInt(!0),r=new NC;if(r.length=n<<1,!e)return r.vertices=this.readFloatArray(t,r.length,s),r;let l=new Array,h=new Array;for(let i=0;i<n;i++){let a=t.readInt(!0);h.push(a);for(let o=0;o<a;o++)h.push(t.readInt(!0)),l.push(t.readFloat()*s),l.push(t.readFloat()*s),l.push(t.readFloat())}return r.vertices=ht.toFloatArray(l),r.bones=h,r}readFloatArray(t,e,s){let n=new Array(e);if(s==1)for(let r=0;r<e;r++)n[r]=t.readFloat();else for(let r=0;r<e;r++)n[r]=t.readFloat()*s;return n}readShortArray(t,e){let s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readInt(!0);return s}readAnimation(t,e,s){t.readInt(!0);let n=new Array,r=this.scale;for(let a=0,o=t.readInt(!0);a<o;a++){let d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){let c=t.readByte(),g=t.readInt(!0),p=g-1;switch(c){case KC:{let y=new Ua(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat(),t.readStringRef());n.push(y);break}case ZC:{let y=t.readInt(!0),w=new Md(g,y,d),x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255;for(let A=0,M=0;w.setFrame(A,x,b,S,C,v),A!=p;A++){let I=t.readFloat(),E=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255;switch(t.readByte()){case qr:w.setStepped(A);break;case zr:Ut(t,w,M++,A,0,x,I,b,E,1),Ut(t,w,M++,A,1,x,I,S,P,1),Ut(t,w,M++,A,2,x,I,C,R,1),Ut(t,w,M++,A,3,x,I,v,k,1)}x=I,b=E,S=P,C=R,v=k}n.push(w);break}case JC:{let y=t.readInt(!0),w=new Td(g,y,d),x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let v=0,A=0;w.setFrame(v,x,b,S,C),v!=p;v++){let M=t.readFloat(),I=t.readUnsignedByte()/255,E=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255;switch(t.readByte()){case qr:w.setStepped(v);break;case zr:Ut(t,w,A++,v,0,x,M,b,I,1),Ut(t,w,A++,v,1,x,M,S,E,1),Ut(t,w,A++,v,2,x,M,C,P,1)}x=M,b=I,S=E,C=P}n.push(w);break}case QC:{let y=t.readInt(!0),w=new Id(g,y,d),x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255;for(let E=0,P=0;w.setFrame(E,x,b,S,C,v,A,M,I),E!=p;E++){let R=t.readFloat(),k=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255;switch(t.readByte()){case qr:w.setStepped(E);break;case zr:Ut(t,w,P++,E,0,x,R,b,k,1),Ut(t,w,P++,E,1,x,R,S,Y,1),Ut(t,w,P++,E,2,x,R,C,F,1),Ut(t,w,P++,E,3,x,R,v,X,1),Ut(t,w,P++,E,4,x,R,A,W,1),Ut(t,w,P++,E,5,x,R,M,B,1),Ut(t,w,P++,E,6,x,R,I,N,1)}x=R,b=k,S=Y,C=F,v=X,A=W,M=B,I=N}n.push(w);break}case jC:{let y=t.readInt(!0),w=new kd(g,y,d),x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let I=0,E=0;w.setFrame(I,x,b,S,C,v,A,M),I!=p;I++){let P=t.readFloat(),R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255;switch(t.readByte()){case qr:w.setStepped(I);break;case zr:Ut(t,w,E++,I,0,x,P,b,R,1),Ut(t,w,E++,I,1,x,P,S,k,1),Ut(t,w,E++,I,2,x,P,C,Y,1),Ut(t,w,E++,I,3,x,P,v,F,1),Ut(t,w,E++,I,4,x,P,A,X,1),Ut(t,w,E++,I,5,x,P,M,W,1)}x=P,b=R,S=k,C=Y,v=F,A=X,M=W}n.push(w);break}case tv:{let y=new Ed(g,t.readInt(!0),d),w=t.readFloat(),x=t.readUnsignedByte()/255;for(let b=0,S=0;y.setFrame(b,w,x),b!=p;b++){let C=t.readFloat(),v=t.readUnsignedByte()/255;switch(t.readByte()){case qr:y.setStepped(b);break;case zr:Ut(t,y,S++,b,0,w,C,x,v,1)}w=C,x=v}n.push(y)}}}}for(let a=0,o=t.readInt(!0);a<o;a++){let d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){let c=t.readByte(),g=t.readInt(!0);if(c==HC){let y=new Ad(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat(),t.readByte());n.push(y);continue}let p=t.readInt(!0);switch(c){case VC:n.push(qs(t,new Cl(g,p,d),1));break;case _C:n.push(lu(t,new gd(g,p,d),r));break;case DC:n.push(qs(t,new pd(g,p,d),r));break;case LC:n.push(qs(t,new xd(g,p,d),r));break;case OC:n.push(lu(t,new bd(g,p,d),1));break;case WC:n.push(qs(t,new wd(g,p,d),1));break;case UC:n.push(qs(t,new yd(g,p,d),1));break;case qC:n.push(lu(t,new Sd(g,p,d),1));break;case zC:n.push(qs(t,new Cd(g,p,d),1));break;case GC:n.push(qs(t,new vd(g,p,d),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){let d=t.readInt(!0),u=t.readInt(!0),m=u-1,c=new Rd(u,t.readInt(!0),d),g=t.readByte(),p=t.readFloat(),y=(g&1)!=0?(g&2)!=0?t.readFloat():1:0,w=(g&4)!=0?t.readFloat()*r:0;for(let x=0,b=0;c.setFrame(x,p,y,w,(g&8)!=0?1:-1,(g&16)!=0,(g&32)!=0),x!=m;x++){g=t.readByte();const S=t.readFloat(),C=(g&1)!=0?(g&2)!=0?t.readFloat():1:0,v=(g&4)!=0?t.readFloat()*r:0;(g&64)!=0?c.setStepped(x):(g&128)!=0&&(Ut(t,c,b++,x,0,p,S,y,C,1),Ut(t,c,b++,x,1,p,S,w,v,r)),p=S,y=C,w=v}n.push(c)}for(let a=0,o=t.readInt(!0);a<o;a++){let d=t.readInt(!0),u=t.readInt(!0),m=u-1,c=new Yd(u,t.readInt(!0),d),g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),x=t.readFloat(),b=t.readFloat(),S=t.readFloat();for(let C=0,v=0;c.setFrame(C,g,p,y,w,x,b,S),C!=m;C++){let A=t.readFloat(),M=t.readFloat(),I=t.readFloat(),E=t.readFloat(),P=t.readFloat(),R=t.readFloat(),k=t.readFloat();switch(t.readByte()){case qr:c.setStepped(C);break;case zr:Ut(t,c,v++,C,0,g,A,p,M,1),Ut(t,c,v++,C,1,g,A,y,I,1),Ut(t,c,v++,C,2,g,A,w,E,1),Ut(t,c,v++,C,3,g,A,x,P,1),Ut(t,c,v++,C,4,g,A,b,R,1),Ut(t,c,v++,C,5,g,A,S,k,1)}g=A,p=M,y=I,w=E,x=P,b=R,S=k}n.push(c)}for(let a=0,o=t.readInt(!0);a<o;a++){let d=t.readInt(!0),u=s.pathConstraints[d];for(let m=0,c=t.readInt(!0);m<c;m++){const g=t.readByte(),p=t.readInt(!0),y=t.readInt(!0);switch(g){case nv:n.push(qs(t,new Fd(p,y,d),u.positionMode==cr.Fixed?r:1));break;case rv:n.push(qs(t,new Bd(p,y,d),u.spacingMode==He.Length||u.spacingMode==He.Fixed?r:1));break;case iv:let w=new Xd(p,y,d),x=t.readFloat(),b=t.readFloat(),S=t.readFloat(),C=t.readFloat();for(let v=0,A=0,M=w.getFrameCount()-1;w.setFrame(v,x,b,S,C),v!=M;v++){let I=t.readFloat(),E=t.readFloat(),P=t.readFloat(),R=t.readFloat();switch(t.readByte()){case qr:w.setStepped(v);break;case zr:Ut(t,w,A++,v,0,x,I,b,E,1),Ut(t,w,A++,v,1,x,I,S,P,1),Ut(t,w,A++,v,2,x,I,C,R,1)}x=I,b=E,S=P,C=R}n.push(w)}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0)-1;for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readByte(),g=t.readInt(!0);if(c==fv){const y=new vl(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat());n.push(y);continue}const p=t.readInt(!0);switch(c){case av:n.push(qs(t,new $d(g,p,d),1));break;case ov:n.push(qs(t,new Nd(g,p,d),1));break;case lv:n.push(qs(t,new Vd(g,p,d),1));break;case hv:n.push(qs(t,new _d(g,p,d),1));break;case cv:n.push(qs(t,new Dd(g,p,d),1));break;case dv:n.push(qs(t,new Ld(g,p,d),1));break;case uv:n.push(qs(t,new Od(g,p,d),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){let d=s.skins[t.readInt(!0)];for(let u=0,m=t.readInt(!0);u<m;u++){let c=t.readInt(!0);for(let g=0,p=t.readInt(!0);g<p;g++){let y=t.readStringRef();if(!y)throw new Error("attachmentName must not be null.");let w=d.getAttachment(c,y),x=t.readByte(),b=t.readInt(!0),S=b-1;switch(x){case ev:{let C=w,v=C.bones,A=C.vertices,M=v?A.length/3*2:A.length,I=t.readInt(!0),E=new Pd(b,I,c,C),P=t.readFloat();for(let R=0,k=0;;R++){let Y,F=t.readInt(!0);if(F==0)Y=v?ht.newFloatArray(M):A;else{Y=ht.newFloatArray(M);let W=t.readInt(!0);if(F+=W,r==1)for(let B=W;B<F;B++)Y[B]=t.readFloat();else for(let B=W;B<F;B++)Y[B]=t.readFloat()*r;if(!v)for(let B=0,N=Y.length;B<N;B++)Y[B]+=A[B]}if(E.setFrame(R,P,Y),R==S)break;let X=t.readFloat();switch(t.readByte()){case qr:E.setStepped(R);break;case zr:Ut(t,E,k++,R,0,P,X,0,1,1)}P=X}n.push(E);break}case sv:{let C=new Wd(b,c,w);for(let v=0;v<b;v++){let A=t.readFloat(),M=t.readInt32();C.setFrame(v,A,Hg[M&15],M>>4,t.readFloat())}n.push(C);break}}}}}let l=t.readInt(!0);if(l>0){let a=new Co(l),o=s.slots.length;for(let d=0;d<l;d++){let u=t.readFloat(),m=t.readInt(!0),c=ht.newArray(o,0);for(let w=o-1;w>=0;w--)c[w]=-1;let g=ht.newArray(o-m,0),p=0,y=0;for(let w=0;w<m;w++){let x=t.readInt(!0);for(;p!=x;)g[y++]=p++;c[p+t.readInt(!0)]=p++}for(;p<o;)g[y++]=p++;for(let w=o-1;w>=0;w--)c[w]==-1&&(c[w]=g[--y]);a.setFrame(d,u,c)}n.push(a)}let h=t.readInt(!0);if(h>0){let a=new Ch(h);for(let o=0;o<h;o++){let d=t.readFloat(),u=s.events[t.readInt(!0)],m=new eu(d,u);m.intValue=t.readInt(!1),m.floatValue=t.readFloat(),m.stringValue=t.readString(),m.stringValue==null&&(m.stringValue=u.stringValue),m.data.audioPath&&(m.volume=t.readFloat(),m.balance=t.readFloat()),a.setFrame(o,m)}n.push(a)}let i=0;for(let a=0,o=n.length;a<o;a++)i=Math.max(i,n[a].getDuration());return new yh(e,n,i)}},lp=class{constructor(t,e=new Array,s=0,n=new DataView(t instanceof ArrayBuffer?t:t.buffer)){T(this,"strings");T(this,"index");T(this,"buffer");this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){let t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){let t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<7,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<14,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<21,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){let t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){let n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){let t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}},$C=class{constructor(t,e,s,n,r){T(this,"parent");T(this,"skinIndex");T(this,"slotIndex");T(this,"mesh");T(this,"inheritTimeline");this.mesh=t,this.skinIndex=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}},NC=class{constructor(t=null,e=null,s=0){T(this,"bones");T(this,"vertices");T(this,"length");this.bones=t,this.vertices=e,this.length=s}};var ci;(function(f){f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping"})(ci||(ci={}));function qs(f,t,e){let s=f.readFloat(),n=f.readFloat()*e;for(let r=0,l=0,h=t.getFrameCount()-1;t.setFrame(r,s,n),r!=h;r++){let i=f.readFloat(),a=f.readFloat()*e;switch(f.readByte()){case qr:t.setStepped(r);break;case zr:Ut(f,t,l++,r,0,s,i,n,a,e)}s=i,n=a}return t}function lu(f,t,e){let s=f.readFloat(),n=f.readFloat()*e,r=f.readFloat()*e;for(let l=0,h=0,i=t.getFrameCount()-1;t.setFrame(l,s,n,r),l!=i;l++){let a=f.readFloat(),o=f.readFloat()*e,d=f.readFloat()*e;switch(f.readByte()){case qr:t.setStepped(l);break;case zr:Ut(f,t,h++,l,0,s,a,n,o,e),Ut(f,t,h++,l,1,s,a,r,d,e)}s=a,n=o,r=d}return t}function Ut(f,t,e,s,n,r,l,h,i,a){t.setBezier(e,s,n,r,h,f.readFloat(),f.readFloat()*a,f.readFloat(),f.readFloat()*a,l,i)}const VC=0,_C=1,DC=2,LC=3,OC=4,WC=5,UC=6,qC=7,zC=8,GC=9,HC=10,KC=0,ZC=1,JC=2,QC=3,jC=4,tv=5,ev=0,sv=1,nv=0,rv=1,iv=2,av=0,ov=1,lv=2,hv=4,cv=5,dv=6,uv=7,fv=8,qr=1,zr=2;class en{constructor(){T(this,"convexPolygons",new Array);T(this,"convexPolygonsIndices",new Array);T(this,"indicesArray",new Array);T(this,"isConcaveArray",new Array);T(this,"triangles",new Array);T(this,"polygonPool",new So(()=>new Array));T(this,"polygonIndicesPool",new So(()=>new Array))}triangulate(t){let e=t,s=t.length>>1,n=this.indicesArray;n.length=0;for(let h=0;h<s;h++)n[h]=h;let r=this.isConcaveArray;r.length=0;for(let h=0,i=s;h<i;++h)r[h]=en.isConcave(h,s,e,n);let l=this.triangles;for(l.length=0;s>3;){let h=s-1,i=0,a=1;for(;;){t:if(!r[i]){let u=n[h]<<1,m=n[i]<<1,c=n[a]<<1,g=e[u],p=e[u+1],y=e[m],w=e[m+1],x=e[c],b=e[c+1];for(let S=(a+1)%s;S!=h;S=(S+1)%s){if(!r[S])continue;let C=n[S]<<1,v=e[C],A=e[C+1];if(en.positiveArea(x,b,g,p,v,A)&&en.positiveArea(g,p,y,w,v,A)&&en.positiveArea(y,w,x,b,v,A))break t}break}if(a==0){do{if(!r[i])break;i--}while(i>0);break}h=i,i=a,a=(a+1)%s}l.push(n[(s+i-1)%s]),l.push(n[i]),l.push(n[(i+1)%s]),n.splice(i,1),r.splice(i,1),s--;let o=(s+i-1)%s,d=i==s?0:i;r[o]=en.isConcave(o,s,e,n),r[d]=en.isConcave(d,s,e,n)}return s==3&&(l.push(n[2]),l.push(n[0]),l.push(n[1])),l}decompose(t,e){let s=t,n=this.convexPolygons;this.polygonPool.freeAll(n),n.length=0;let r=this.convexPolygonsIndices;this.polygonIndicesPool.freeAll(r),r.length=0;let l=this.polygonIndicesPool.obtain();l.length=0;let h=this.polygonPool.obtain();h.length=0;let i=-1,a=0;for(let o=0,d=e.length;o<d;o+=3){let u=e[o]<<1,m=e[o+1]<<1,c=e[o+2]<<1,g=s[u],p=s[u+1],y=s[m],w=s[m+1],x=s[c],b=s[c+1],S=!1;if(i==u){let C=h.length-4,v=en.winding(h[C],h[C+1],h[C+2],h[C+3],x,b),A=en.winding(x,b,h[0],h[1],h[2],h[3]);v==a&&A==a&&(h.push(x),h.push(b),l.push(c),S=!0)}S||(h.length>0?(n.push(h),r.push(l)):(this.polygonPool.free(h),this.polygonIndicesPool.free(l)),h=this.polygonPool.obtain(),h.length=0,h.push(g),h.push(p),h.push(y),h.push(w),h.push(x),h.push(b),l=this.polygonIndicesPool.obtain(),l.length=0,l.push(u),l.push(m),l.push(c),a=en.winding(g,p,y,w,x,b),i=u)}h.length>0&&(n.push(h),r.push(l));for(let o=0,d=n.length;o<d;o++){if(l=r[o],l.length==0)continue;let u=l[0],m=l[l.length-1];h=n[o];let c=h.length-4,g=h[c],p=h[c+1],y=h[c+2],w=h[c+3],x=h[0],b=h[1],S=h[2],C=h[3],v=en.winding(g,p,y,w,x,b);for(let A=0;A<d;A++){if(A==o)continue;let M=r[A];if(M.length!=3)continue;let I=M[0],E=M[1],P=M[2],R=n[A],k=R[R.length-2],Y=R[R.length-1];if(I!=u||E!=m)continue;let F=en.winding(g,p,y,w,k,Y),X=en.winding(k,Y,x,b,S,C);F==v&&X==v&&(R.length=0,M.length=0,h.push(k),h.push(Y),l.push(P),g=y,p=w,y=k,w=Y,A=0)}}for(let o=n.length-1;o>=0;o--)h=n[o],h.length==0&&(n.splice(o,1),this.polygonPool.free(h),l=r[o],r.splice(o,1),this.polygonIndicesPool.free(l));return n}static isConcave(t,e,s,n){let r=n[(e+t-1)%e]<<1,l=n[t]<<1,h=n[(t+1)%e]<<1;return!this.positiveArea(s[r],s[r+1],s[l],s[l+1],s[h],s[h+1])}static positiveArea(t,e,s,n,r,l){return t*(l-n)+s*(e-l)+r*(n-e)>=0}static winding(t,e,s,n,r,l){let h=s-t,i=n-e;return r*i-l*h+h*e-t*i>=0?1:-1}}class za{constructor(){T(this,"triangulator",new en);T(this,"clippingPolygon",new Array);T(this,"clipOutput",new Array);T(this,"clippedVertices",new Array);T(this,"clippedUVs",new Array);T(this,"clippedTriangles",new Array);T(this,"scratch",new Array);T(this,"clipAttachment",null);T(this,"clippingPolygons",null)}clipStart(t,e){if(this.clipAttachment)return 0;this.clipAttachment=e;let s=e.worldVerticesLength,n=ht.setArraySize(this.clippingPolygon,s);e.computeWorldVertices(t,0,s,n,0,2);let r=this.clippingPolygon;za.makeClockwise(r);let l=this.clippingPolygons=this.triangulator.decompose(r,this.triangulator.triangulate(r));for(let h=0,i=l.length;h<i;h++){let a=l[h];za.makeClockwise(a),a.push(a[0]),a.push(a[1])}return l.length}clipEndWithSlot(t){this.clipAttachment&&this.clipAttachment.endSlot==t.data&&this.clipEnd()}clipEnd(){this.clipAttachment&&(this.clipAttachment=null,this.clippingPolygons=null,this.clippedVertices.length=0,this.clippedTriangles.length=0,this.clippingPolygon.length=0)}isClipping(){return this.clipAttachment!=null}clipTriangles(t,e,s,n,r,l,h,i){let a,o,d,u,m,c;typeof e=="number"?(a=s,o=n,d=r,u=l,m=h,c=i):(a=e,o=s,d=n,u=r,m=l,c=h),d&&u&&m&&typeof c=="boolean"?this.clipTrianglesRender(t,a,o,d,u,m,c):this.clipTrianglesNoRender(t,a,o)}clipTrianglesNoRender(t,e,s){let n=this.clipOutput,r=this.clippedVertices,l=this.clippedTriangles,h=this.clippingPolygons,i=h.length,a=0;r.length=0,l.length=0;for(let o=0;o<s;o+=3){let d=e[o]<<1,u=t[d],m=t[d+1];d=e[o+1]<<1;let c=t[d],g=t[d+1];d=e[o+2]<<1;let p=t[d],y=t[d+1];for(let w=0;w<i;w++){let x=r.length;if(this.clip(u,m,c,g,p,y,h[w],n)){let b=n.length;if(b==0)continue;let S=b>>1,C=this.clipOutput,v=ht.setArraySize(r,x+S*2);for(let M=0;M<b;M+=2,x+=2){let I=C[M],E=C[M+1];v[x]=I,v[x+1]=E}x=l.length;let A=ht.setArraySize(l,x+3*(S-2));S--;for(let M=1;M<S;M++,x+=3)A[x]=a,A[x+1]=a+M,A[x+2]=a+M+1;a+=S+1}else{let b=ht.setArraySize(r,x+6);b[x]=u,b[x+1]=m,b[x+2]=c,b[x+3]=g,b[x+4]=p,b[x+5]=y,x=l.length;let S=ht.setArraySize(l,x+3);S[x]=a,S[x+1]=a+1,S[x+2]=a+2,a+=3;break}}}}clipTrianglesRender(t,e,s,n,r,l,h){let i=this.clipOutput,a=this.clippedVertices,o=this.clippedTriangles,d=this.clippingPolygons,u=d.length,m=h?12:8,c=0;a.length=0,o.length=0;for(let g=0;g<s;g+=3){let p=e[g]<<1,y=t[p],w=t[p+1],x=n[p],b=n[p+1];p=e[g+1]<<1;let S=t[p],C=t[p+1],v=n[p],A=n[p+1];p=e[g+2]<<1;let M=t[p],I=t[p+1],E=n[p],P=n[p+1];for(let R=0;R<u;R++){let k=a.length;if(this.clip(y,w,S,C,M,I,d[R],i)){let Y=i.length;if(Y==0)continue;let F=C-I,X=M-S,W=y-M,B=I-w,N=1/(F*W+X*(w-I)),O=Y>>1,Z=this.clipOutput,$=ht.setArraySize(a,k+O*m);for(let _=0;_<Y;_+=2,k+=m){let lt=Z[_],wt=Z[_+1];$[k]=lt,$[k+1]=wt,$[k+2]=r.r,$[k+3]=r.g,$[k+4]=r.b,$[k+5]=r.a;let Tt=lt-M,ct=wt-I,Mt=(F*Tt+X*ct)*N,Rt=(B*Tt+W*ct)*N,de=1-Mt-Rt;$[k+6]=x*Mt+v*Rt+E*de,$[k+7]=b*Mt+A*Rt+P*de,h&&($[k+8]=l.r,$[k+9]=l.g,$[k+10]=l.b,$[k+11]=l.a)}k=o.length;let D=ht.setArraySize(o,k+3*(O-2));O--;for(let _=1;_<O;_++,k+=3)D[k]=c,D[k+1]=c+_,D[k+2]=c+_+1;c+=O+1}else{let Y=ht.setArraySize(a,k+3*m);Y[k]=y,Y[k+1]=w,Y[k+2]=r.r,Y[k+3]=r.g,Y[k+4]=r.b,Y[k+5]=r.a,h?(Y[k+6]=x,Y[k+7]=b,Y[k+8]=l.r,Y[k+9]=l.g,Y[k+10]=l.b,Y[k+11]=l.a,Y[k+12]=S,Y[k+13]=C,Y[k+14]=r.r,Y[k+15]=r.g,Y[k+16]=r.b,Y[k+17]=r.a,Y[k+18]=v,Y[k+19]=A,Y[k+20]=l.r,Y[k+21]=l.g,Y[k+22]=l.b,Y[k+23]=l.a,Y[k+24]=M,Y[k+25]=I,Y[k+26]=r.r,Y[k+27]=r.g,Y[k+28]=r.b,Y[k+29]=r.a,Y[k+30]=E,Y[k+31]=P,Y[k+32]=l.r,Y[k+33]=l.g,Y[k+34]=l.b,Y[k+35]=l.a):(Y[k+6]=x,Y[k+7]=b,Y[k+8]=S,Y[k+9]=C,Y[k+10]=r.r,Y[k+11]=r.g,Y[k+12]=r.b,Y[k+13]=r.a,Y[k+14]=v,Y[k+15]=A,Y[k+16]=M,Y[k+17]=I,Y[k+18]=r.r,Y[k+19]=r.g,Y[k+20]=r.b,Y[k+21]=r.a,Y[k+22]=E,Y[k+23]=P),k=o.length;let F=ht.setArraySize(o,k+3);F[k]=c,F[k+1]=c+1,F[k+2]=c+2,c+=3;break}}}}clipTrianglesUnpacked(t,e,s,n){let r=this.clipOutput,l=this.clippedVertices,h=this.clippedUVs,i=this.clippedTriangles,a=this.clippingPolygons,o=a.length,d=0;l.length=0,h.length=0,i.length=0;for(let u=0;u<s;u+=3){let m=e[u]<<1,c=t[m],g=t[m+1],p=n[m],y=n[m+1];m=e[u+1]<<1;let w=t[m],x=t[m+1],b=n[m],S=n[m+1];m=e[u+2]<<1;let C=t[m],v=t[m+1],A=n[m],M=n[m+1];for(let I=0;I<o;I++){let E=l.length;if(this.clip(c,g,w,x,C,v,a[I],r)){let P=r.length;if(P==0)continue;let R=x-v,k=C-w,Y=c-C,F=v-g,X=1/(R*Y+k*(g-v)),W=P>>1,B=this.clipOutput,N=ht.setArraySize(l,E+W*2),O=ht.setArraySize(h,E+W*2);for(let $=0;$<P;$+=2,E+=2){let D=B[$],_=B[$+1];N[E]=D,N[E+1]=_;let lt=D-C,wt=_-v,Tt=(R*lt+k*wt)*X,ct=(F*lt+Y*wt)*X,Mt=1-Tt-ct;O[E]=p*Tt+b*ct+A*Mt,O[E+1]=y*Tt+S*ct+M*Mt}E=i.length;let Z=ht.setArraySize(i,E+3*(W-2));W--;for(let $=1;$<W;$++,E+=3)Z[E]=d,Z[E+1]=d+$,Z[E+2]=d+$+1;d+=W+1}else{let P=ht.setArraySize(l,E+6);P[E]=c,P[E+1]=g,P[E+2]=w,P[E+3]=x,P[E+4]=C,P[E+5]=v;let R=ht.setArraySize(h,E+3*2);R[E]=p,R[E+1]=y,R[E+2]=b,R[E+3]=S,R[E+4]=A,R[E+5]=M,E=i.length;let k=ht.setArraySize(i,E+3);k[E]=d,k[E+1]=d+1,k[E+2]=d+2,d+=3;break}}}}clip(t,e,s,n,r,l,h,i){let a=i,o=!1,d;h.length%4>=2?(d=i,i=this.scratch):d=this.scratch,d.length=0,d.push(t),d.push(e),d.push(s),d.push(n),d.push(r),d.push(l),d.push(t),d.push(e),i.length=0;let u=h.length-4,m=h;for(let c=0;;c+=2){let g=m[c],p=m[c+1],y=g-m[c+2],w=p-m[c+3],x=i.length,b=d;for(let C=0,v=d.length-2;C<v;){let A=b[C],M=b[C+1];C+=2;let I=b[C],E=b[C+1],P=w*(g-I)>y*(p-E),R=w*(g-A)-y*(p-M);if(R>0){if(P){i.push(I),i.push(E);continue}let k=I-A,Y=E-M,F=R/(k*w-Y*y);if(F>=0&&F<=1)i.push(A+k*F),i.push(M+Y*F);else{i.push(I),i.push(E);continue}}else if(P){let k=I-A,Y=E-M,F=R/(k*w-Y*y);if(F>=0&&F<=1)i.push(A+k*F),i.push(M+Y*F),i.push(I),i.push(E);else{i.push(I),i.push(E);continue}}o=!0}if(x==i.length)return a.length=0,!0;if(i.push(i[0]),i.push(i[1]),c==u)break;let S=i;i=d,i.length=0,d=S}if(a!=i){a.length=0;for(let c=0,g=i.length-2;c<g;c++)a[c]=i[c]}else a.length=a.length-2;return o}static makeClockwise(t){let e=t,s=t.length,n=e[s-2]*e[1]-e[0]*e[s-1],r=0,l=0,h=0,i=0;for(let a=0,o=s-3;a<o;a+=2)r=e[a],l=e[a+1],h=e[a+2],i=e[a+3],n+=r*i-h*l;if(!(n<0))for(let a=0,o=s-2,d=s>>1;a<d;a+=2){let u=e[a],m=e[a+1],c=o-a;e[a]=e[c],e[a+1]=e[c+1],e[c]=u,e[c+1]=m}}}let hu=class{constructor(t){T(this,"attachmentLoader");T(this,"scale",1);T(this,"linkedMeshes",new Array);this.attachmentLoader=t}readSkeletonData(t){var l,h;let e=this.scale,s=new Tl,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r&&(s.hash=r.hash,s.version=r.spine,s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.referenceScale=L(r,"referenceScale",100)*e,s.fps=r.fps,s.imagesPath=(l=r.images)!=null?l:null,s.audioPath=(h=r.audio)!=null?h:null),n.bones)for(let i=0;i<n.bones.length;i++){let a=n.bones[i],o=null,d=L(a,"parent",null);d&&(o=s.findBone(d));let u=new Qd(s.bones.length,a.name,o);u.length=L(a,"length",0)*e,u.x=L(a,"x",0)*e,u.y=L(a,"y",0)*e,u.rotation=L(a,"rotation",0),u.scaleX=L(a,"scaleX",1),u.scaleY=L(a,"scaleY",1),u.shearX=L(a,"shearX",0),u.shearY=L(a,"shearY",0),u.inherit=ht.enumValue(be,L(a,"inherit","Normal")),u.skinRequired=L(a,"skin",!1);let m=L(a,"color",null);m&&u.color.setFromString(m),s.bones.push(u)}if(n.slots)for(let i=0;i<n.slots.length;i++){let a=n.slots[i],o=a.name,d=s.findBone(a.bone);if(!d)throw new Error(`Couldn't find bone ${a.bone} for slot ${o}`);let u=new iu(s.slots.length,o,d),m=L(a,"color",null);m&&u.color.setFromString(m);let c=L(a,"dark",null);c&&(u.darkColor=Yt.fromString(c)),u.attachmentName=L(a,"attachment",null),u.blendMode=ht.enumValue(hi,L(a,"blend","normal")),u.visible=L(a,"visible",!0),s.slots.push(u)}if(n.ik)for(let i=0;i<n.ik.length;i++){let a=n.ik[i],o=new nu(a.name);o.order=L(a,"order",0),o.skinRequired=L(a,"skin",!1);for(let u=0;u<a.bones.length;u++){let m=s.findBone(a.bones[u]);if(!m)throw new Error(`Couldn't find bone ${a.bones[u]} for IK constraint ${a.name}.`);o.bones.push(m)}let d=s.findBone(a.target);if(!d)throw new Error(`Couldn't find target bone ${a.target} for IK constraint ${a.name}.`);o.target=d,o.mix=L(a,"mix",1),o.softness=L(a,"softness",0)*e,o.bendDirection=L(a,"bendPositive",!0)?1:-1,o.compress=L(a,"compress",!1),o.stretch=L(a,"stretch",!1),o.uniform=L(a,"uniform",!1),s.ikConstraints.push(o)}if(n.transform)for(let i=0;i<n.transform.length;i++){let a=n.transform[i],o=new au(a.name);o.order=L(a,"order",0),o.skinRequired=L(a,"skin",!1);for(let m=0;m<a.bones.length;m++){let c=a.bones[m],g=s.findBone(c);if(!g)throw new Error(`Couldn't find bone ${c} for transform constraint ${a.name}.`);o.bones.push(g)}let d=a.target,u=s.findBone(d);if(!u)throw new Error(`Couldn't find target bone ${d} for transform constraint ${a.name}.`);o.target=u,o.local=L(a,"local",!1),o.relative=L(a,"relative",!1),o.offsetRotation=L(a,"rotation",0),o.offsetX=L(a,"x",0)*e,o.offsetY=L(a,"y",0)*e,o.offsetScaleX=L(a,"scaleX",0),o.offsetScaleY=L(a,"scaleY",0),o.offsetShearY=L(a,"shearY",0),o.mixRotate=L(a,"mixRotate",1),o.mixX=L(a,"mixX",1),o.mixY=L(a,"mixY",o.mixX),o.mixScaleX=L(a,"mixScaleX",1),o.mixScaleY=L(a,"mixScaleY",o.mixScaleX),o.mixShearY=L(a,"mixShearY",1),s.transformConstraints.push(o)}if(n.path)for(let i=0;i<n.path.length;i++){let a=n.path[i],o=new jd(a.name);o.order=L(a,"order",0),o.skinRequired=L(a,"skin",!1);for(let m=0;m<a.bones.length;m++){let c=a.bones[m],g=s.findBone(c);if(!g)throw new Error(`Couldn't find bone ${c} for path constraint ${a.name}.`);o.bones.push(g)}let d=a.target,u=s.findSlot(d);if(!u)throw new Error(`Couldn't find target slot ${d} for path constraint ${a.name}.`);o.target=u,o.positionMode=ht.enumValue(cr,L(a,"positionMode","Percent")),o.spacingMode=ht.enumValue(He,L(a,"spacingMode","Length")),o.rotateMode=ht.enumValue(Ji,L(a,"rotateMode","Tangent")),o.offsetRotation=L(a,"rotation",0),o.position=L(a,"position",0),o.positionMode==cr.Fixed&&(o.position*=e),o.spacing=L(a,"spacing",0),(o.spacingMode==He.Length||o.spacingMode==He.Fixed)&&(o.spacing*=e),o.mixRotate=L(a,"mixRotate",1),o.mixX=L(a,"mixX",1),o.mixY=L(a,"mixY",o.mixX),s.pathConstraints.push(o)}if(n.physics)for(let i=0;i<n.physics.length;i++){const a=n.physics[i],o=new op(a.name);o.order=L(a,"order",0),o.skinRequired=L(a,"skin",!1);const d=a.bone,u=s.findBone(d);if(u==null)throw new Error("Physics bone not found: "+d);o.bone=u,o.x=L(a,"x",0),o.y=L(a,"y",0),o.rotate=L(a,"rotate",0),o.scaleX=L(a,"scaleX",0),o.shearX=L(a,"shearX",0),o.limit=L(a,"limit",5e3)*e,o.step=1/L(a,"fps",60),o.inertia=L(a,"inertia",1),o.strength=L(a,"strength",100),o.damping=L(a,"damping",1),o.massInverse=1/L(a,"mass",1),o.wind=L(a,"wind",0),o.gravity=L(a,"gravity",0),o.mix=L(a,"mix",1),o.inertiaGlobal=L(a,"inertiaGlobal",!1),o.strengthGlobal=L(a,"strengthGlobal",!1),o.dampingGlobal=L(a,"dampingGlobal",!1),o.massGlobal=L(a,"massGlobal",!1),o.windGlobal=L(a,"windGlobal",!1),o.gravityGlobal=L(a,"gravityGlobal",!1),o.mixGlobal=L(a,"mixGlobal",!1),s.physicsConstraints.push(o)}if(n.skins)for(let i=0;i<n.skins.length;i++){let a=n.skins[i],o=new El(a.name);if(a.bones)for(let d=0;d<a.bones.length;d++){let u=a.bones[d],m=s.findBone(u);if(!m)throw new Error(`Couldn't find bone ${u} for skin ${a.name}.`);o.bones.push(m)}if(a.ik)for(let d=0;d<a.ik.length;d++){let u=a.ik[d],m=s.findIkConstraint(u);if(!m)throw new Error(`Couldn't find IK constraint ${u} for skin ${a.name}.`);o.constraints.push(m)}if(a.transform)for(let d=0;d<a.transform.length;d++){let u=a.transform[d],m=s.findTransformConstraint(u);if(!m)throw new Error(`Couldn't find transform constraint ${u} for skin ${a.name}.`);o.constraints.push(m)}if(a.path)for(let d=0;d<a.path.length;d++){let u=a.path[d],m=s.findPathConstraint(u);if(!m)throw new Error(`Couldn't find path constraint ${u} for skin ${a.name}.`);o.constraints.push(m)}if(a.physics)for(let d=0;d<a.physics.length;d++){let u=a.physics[d],m=s.findPhysicsConstraint(u);if(!m)throw new Error(`Couldn't find physics constraint ${u} for skin ${a.name}.`);o.constraints.push(m)}for(let d in a.attachments){let u=s.findSlot(d);if(!u)throw new Error(`Couldn't find slot ${d} for skin ${a.name}.`);let m=a.attachments[d];for(let c in m){let g=this.readAttachment(m[c],o,u.index,c,s);g&&o.setAttachment(u.index,c,g)}}s.skins.push(o),o.name=="default"&&(s.defaultSkin=o)}for(let i=0,a=this.linkedMeshes.length;i<a;i++){let o=this.linkedMeshes[i],d=o.skin?s.findSkin(o.skin):s.defaultSkin;if(!d)throw new Error(`Skin not found: ${o.skin}`);let u=d.getAttachment(o.slotIndex,o.parent);if(!u)throw new Error(`Parent mesh not found: ${o.parent}`);o.mesh.timelineAttachment=o.inheritTimeline?u:o.mesh,o.mesh.setParentMesh(u),o.mesh.region!=null&&o.mesh.updateRegion()}if(this.linkedMeshes.length=0,n.events)for(let i in n.events){let a=n.events[i],o=new su(i);o.intValue=L(a,"int",0),o.floatValue=L(a,"float",0),o.stringValue=L(a,"string",""),o.audioPath=L(a,"audio",null),o.audioPath&&(o.volume=L(a,"volume",1),o.balance=L(a,"balance",0)),s.events.push(o)}if(n.animations)for(let i in n.animations){let a=n.animations[i];this.readAnimation(a,i,s)}return s}readAttachment(t,e,s,n,r){let l=this.scale;switch(n=L(t,"name",n),L(t,"type","region")){case"region":{let h=L(t,"path",n),i=this.readSequence(L(t,"sequence",null)),a=this.attachmentLoader.newRegionAttachment(e,n,h,i);if(!a)return null;a.path=h,a.x=L(t,"x",0)*l,a.y=L(t,"y",0)*l,a.scaleX=L(t,"scaleX",1),a.scaleY=L(t,"scaleY",1),a.rotation=L(t,"rotation",0),a.width=t.width*l,a.height=t.height*l,a.sequence=i;let o=L(t,"color",null);return o&&a.color.setFromString(o),a.region!=null&&a.updateRegion(),a}case"boundingbox":{let h=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);let i=L(t,"color",null);return i&&h.color.setFromString(i),h}case"mesh":case"linkedmesh":{let h=L(t,"path",n),i=this.readSequence(L(t,"sequence",null)),a=this.attachmentLoader.newMeshAttachment(e,n,h,i);if(!a)return null;a.path=h;let o=L(t,"color",null);o&&a.color.setFromString(o),a.width=L(t,"width",0)*l,a.height=L(t,"height",0)*l,a.sequence=i;let d=L(t,"parent",null);if(d)return this.linkedMeshes.push(new mv(a,L(t,"skin",null),s,d,L(t,"timelines",!0))),a;let u=t.uvs;return this.readVertices(t,a,u.length),a.triangles=t.triangles,a.regionUVs=u,a.region!=null&&a.updateRegion(),a.edges=L(t,"edges",null),a.hullLength=L(t,"hull",0)*2,a}case"path":{let h=this.attachmentLoader.newPathAttachment(e,n);if(!h)return null;h.closed=L(t,"closed",!1),h.constantSpeed=L(t,"constantSpeed",!0);let i=t.vertexCount;this.readVertices(t,h,i<<1);let a=ht.newArray(i/3,0);for(let d=0;d<t.lengths.length;d++)a[d]=t.lengths[d]*l;h.lengths=a;let o=L(t,"color",null);return o&&h.color.setFromString(o),h}case"point":{let h=this.attachmentLoader.newPointAttachment(e,n);if(!h)return null;h.x=L(t,"x",0)*l,h.y=L(t,"y",0)*l,h.rotation=L(t,"rotation",0);let i=L(t,"color",null);return i&&h.color.setFromString(i),h}case"clipping":{let h=this.attachmentLoader.newClippingAttachment(e,n);if(!h)return null;let i=L(t,"end",null);i&&(h.endSlot=r.findSlot(i));let a=t.vertexCount;this.readVertices(t,h,a<<1);let o=L(t,"color",null);return o&&h.color.setFromString(o),h}}return null}readSequence(t){if(t==null)return null;let e=new Gg(L(t,"count",0));return e.start=L(t,"start",1),e.digits=L(t,"digits",0),e.setupIndex=L(t,"setup",0),e}readVertices(t,e,s){let n=this.scale;e.worldVerticesLength=s;let r=t.vertices;if(s==r.length){let i=ht.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}let l=new Array,h=new Array;for(let i=0,a=r.length;i<a;){let o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),l.push(r[i+1]*n),l.push(r[i+2]*n),l.push(r[i+3])}e.bones=h,e.vertices=ht.toFloatArray(l)}readAnimation(t,e,s){let n=this.scale,r=new Array;if(t.slots)for(let h in t.slots){let i=t.slots[h],a=s.findSlot(h);if(!a)throw new Error("Slot not found: "+h);let o=a.index;for(let d in i){let u=i[d];if(!u)continue;let m=u.length;if(d=="attachment"){let c=new Ua(m,o);for(let g=0;g<m;g++){let p=u[g];c.setFrame(g,L(p,"time",0),L(p,"name",null))}r.push(c)}else if(d=="rgba"){let c=new Md(m,m<<2,o),g=u[0],p=L(g,"time",0),y=Yt.fromString(g.color);for(let w=0,x=0;;w++){c.setFrame(w,p,y.r,y.g,y.b,y.a);let b=u[w+1];if(!b){c.shrink(x);break}let S=L(b,"time",0),C=Yt.fromString(b.color),v=g.curve;v&&(x=Jt(v,c,x,w,0,p,S,y.r,C.r,1),x=Jt(v,c,x,w,1,p,S,y.g,C.g,1),x=Jt(v,c,x,w,2,p,S,y.b,C.b,1),x=Jt(v,c,x,w,3,p,S,y.a,C.a,1)),p=S,y=C,g=b}r.push(c)}else if(d=="rgb"){let c=new Td(m,m*3,o),g=u[0],p=L(g,"time",0),y=Yt.fromString(g.color);for(let w=0,x=0;;w++){c.setFrame(w,p,y.r,y.g,y.b);let b=u[w+1];if(!b){c.shrink(x);break}let S=L(b,"time",0),C=Yt.fromString(b.color),v=g.curve;v&&(x=Jt(v,c,x,w,0,p,S,y.r,C.r,1),x=Jt(v,c,x,w,1,p,S,y.g,C.g,1),x=Jt(v,c,x,w,2,p,S,y.b,C.b,1)),p=S,y=C,g=b}r.push(c)}else if(d=="alpha")r.push(dr(u,new Ed(m,m,o),0,1));else if(d=="rgba2"){let c=new Id(m,m*7,o),g=u[0],p=L(g,"time",0),y=Yt.fromString(g.light),w=Yt.fromString(g.dark);for(let x=0,b=0;;x++){c.setFrame(x,p,y.r,y.g,y.b,y.a,w.r,w.g,w.b);let S=u[x+1];if(!S){c.shrink(b);break}let C=L(S,"time",0),v=Yt.fromString(S.light),A=Yt.fromString(S.dark),M=g.curve;M&&(b=Jt(M,c,b,x,0,p,C,y.r,v.r,1),b=Jt(M,c,b,x,1,p,C,y.g,v.g,1),b=Jt(M,c,b,x,2,p,C,y.b,v.b,1),b=Jt(M,c,b,x,3,p,C,y.a,v.a,1),b=Jt(M,c,b,x,4,p,C,w.r,A.r,1),b=Jt(M,c,b,x,5,p,C,w.g,A.g,1),b=Jt(M,c,b,x,6,p,C,w.b,A.b,1)),p=C,y=v,w=A,g=S}r.push(c)}else if(d=="rgb2"){let c=new kd(m,m*6,o),g=u[0],p=L(g,"time",0),y=Yt.fromString(g.light),w=Yt.fromString(g.dark);for(let x=0,b=0;;x++){c.setFrame(x,p,y.r,y.g,y.b,w.r,w.g,w.b);let S=u[x+1];if(!S){c.shrink(b);break}let C=L(S,"time",0),v=Yt.fromString(S.light),A=Yt.fromString(S.dark),M=g.curve;M&&(b=Jt(M,c,b,x,0,p,C,y.r,v.r,1),b=Jt(M,c,b,x,1,p,C,y.g,v.g,1),b=Jt(M,c,b,x,2,p,C,y.b,v.b,1),b=Jt(M,c,b,x,3,p,C,w.r,A.r,1),b=Jt(M,c,b,x,4,p,C,w.g,A.g,1),b=Jt(M,c,b,x,5,p,C,w.b,A.b,1)),p=C,y=v,w=A,g=S}r.push(c)}}}if(t.bones)for(let h in t.bones){let i=t.bones[h],a=s.findBone(h);if(!a)throw new Error("Bone not found: "+h);let o=a.index;for(let d in i){let u=i[d],m=u.length;if(m!=0){if(d==="rotate")r.push(dr(u,new Cl(m,m,o),0,1));else if(d==="translate"){let c=new gd(m,m<<1,o);r.push(cu(u,c,"x","y",0,n))}else if(d==="translatex"){let c=new pd(m,m,o);r.push(dr(u,c,0,n))}else if(d==="translatey"){let c=new xd(m,m,o);r.push(dr(u,c,0,n))}else if(d==="scale"){let c=new bd(m,m<<1,o);r.push(cu(u,c,"x","y",1,1))}else if(d==="scalex"){let c=new wd(m,m,o);r.push(dr(u,c,1,1))}else if(d==="scaley"){let c=new yd(m,m,o);r.push(dr(u,c,1,1))}else if(d==="shear"){let c=new Sd(m,m<<1,o);r.push(cu(u,c,"x","y",0,1))}else if(d==="shearx"){let c=new Cd(m,m,o);r.push(dr(u,c,0,1))}else if(d==="sheary"){let c=new vd(m,m,o);r.push(dr(u,c,0,1))}else if(d==="inherit"){let c=new Ad(m,a.index);for(let g=0;g<u.length;g++){let p=u[g];c.setFrame(g,L(p,"time",0),ht.enumValue(be,L(p,"inherit","Normal")))}r.push(c)}}}}if(t.ik)for(let h in t.ik){let i=t.ik[h],a=i[0];if(!a)continue;let o=s.findIkConstraint(h);if(!o)throw new Error("IK Constraint not found: "+h);let d=s.ikConstraints.indexOf(o),u=new Rd(i.length,i.length<<1,d),m=L(a,"time",0),c=L(a,"mix",1),g=L(a,"softness",0)*n;for(let p=0,y=0;;p++){u.setFrame(p,m,c,g,L(a,"bendPositive",!0)?1:-1,L(a,"compress",!1),L(a,"stretch",!1));let w=i[p+1];if(!w){u.shrink(y);break}let x=L(w,"time",0),b=L(w,"mix",1),S=L(w,"softness",0)*n,C=a.curve;C&&(y=Jt(C,u,y,p,0,m,x,c,b,1),y=Jt(C,u,y,p,1,m,x,g,S,n)),m=x,c=b,g=S,a=w}r.push(u)}if(t.transform)for(let h in t.transform){let i=t.transform[h],a=i[0];if(!a)continue;let o=s.findTransformConstraint(h);if(!o)throw new Error("Transform constraint not found: "+h);let d=s.transformConstraints.indexOf(o),u=new Yd(i.length,i.length*6,d),m=L(a,"time",0),c=L(a,"mixRotate",1),g=L(a,"mixX",1),p=L(a,"mixY",g),y=L(a,"mixScaleX",1),w=L(a,"mixScaleY",y),x=L(a,"mixShearY",1);for(let b=0,S=0;;b++){u.setFrame(b,m,c,g,p,y,w,x);let C=i[b+1];if(!C){u.shrink(S);break}let v=L(C,"time",0),A=L(C,"mixRotate",1),M=L(C,"mixX",1),I=L(C,"mixY",M),E=L(C,"mixScaleX",1),P=L(C,"mixScaleY",E),R=L(C,"mixShearY",1),k=a.curve;k&&(S=Jt(k,u,S,b,0,m,v,c,A,1),S=Jt(k,u,S,b,1,m,v,g,M,1),S=Jt(k,u,S,b,2,m,v,p,I,1),S=Jt(k,u,S,b,3,m,v,y,E,1),S=Jt(k,u,S,b,4,m,v,w,P,1),S=Jt(k,u,S,b,5,m,v,x,R,1)),m=v,c=A,g=M,p=I,y=E,w=P,y=E,a=C}r.push(u)}if(t.path)for(let h in t.path){let i=t.path[h],a=s.findPathConstraint(h);if(!a)throw new Error("Path constraint not found: "+h);let o=s.pathConstraints.indexOf(a);for(let d in i){let u=i[d],m=u[0];if(!m)continue;let c=u.length;if(d==="position"){let g=new Fd(c,c,o);r.push(dr(u,g,0,a.positionMode==cr.Fixed?n:1))}else if(d==="spacing"){let g=new Bd(c,c,o);r.push(dr(u,g,0,a.spacingMode==He.Length||a.spacingMode==He.Fixed?n:1))}else if(d==="mix"){let g=new Xd(c,c*3,o),p=L(m,"time",0),y=L(m,"mixRotate",1),w=L(m,"mixX",1),x=L(m,"mixY",w);for(let b=0,S=0;;b++){g.setFrame(b,p,y,w,x);let C=u[b+1];if(!C){g.shrink(S);break}let v=L(C,"time",0),A=L(C,"mixRotate",1),M=L(C,"mixX",1),I=L(C,"mixY",M),E=m.curve;E&&(S=Jt(E,g,S,b,0,p,v,y,A,1),S=Jt(E,g,S,b,1,p,v,w,M,1),S=Jt(E,g,S,b,2,p,v,x,I,1)),p=v,y=A,w=M,x=I,m=C}r.push(g)}}}if(t.physics)for(let h in t.physics){let i=t.physics[h],a=-1;if(h.length>0){let o=s.findPhysicsConstraint(h);if(!o)throw new Error("Physics constraint not found: "+h);a=s.physicsConstraints.indexOf(o)}for(let o in i){let d=i[o],u=d[0];if(!u)continue;let m=d.length;if(o=="reset"){const g=new vl(m,a);for(let p=0;u!=null;u=d[p+1],p++)g.setFrame(p,L(u,"time",0));r.push(g);continue}let c;if(o=="inertia")c=new $d(m,m,a);else if(o=="strength")c=new Nd(m,m,a);else if(o=="damping")c=new Vd(m,m,a);else if(o=="mass")c=new _d(m,m,a);else if(o=="wind")c=new Dd(m,m,a);else if(o=="gravity")c=new Ld(m,m,a);else if(o=="mix")c=new Od(m,m,a);else continue;r.push(dr(d,c,0,1))}}if(t.attachments)for(let h in t.attachments){let i=t.attachments[h],a=s.findSkin(h);if(!a)throw new Error("Skin not found: "+h);for(let o in i){let d=i[o],u=s.findSlot(o);if(!u)throw new Error("Slot not found: "+o);let m=u.index;for(let c in d){let g=d[c],p=a.getAttachment(m,c);for(let y in g){let w=g[y],x=w[0];if(x){if(y=="deform"){let b=p.bones,S=p.vertices,C=b?S.length/3*2:S.length,v=new Pd(w.length,w.length,m,p),A=L(x,"time",0);for(let M=0,I=0;;M++){let E,P=L(x,"vertices",null);if(!P)E=b?ht.newFloatArray(C):S;else{E=ht.newFloatArray(C);let F=L(x,"offset",0);if(ht.arrayCopy(P,0,E,F,P.length),n!=1)for(let X=F,W=X+P.length;X<W;X++)E[X]*=n;if(!b)for(let X=0;X<C;X++)E[X]+=S[X]}v.setFrame(M,A,E);let R=w[M+1];if(!R){v.shrink(I);break}let k=L(R,"time",0),Y=x.curve;Y&&(I=Jt(Y,v,I,M,0,A,k,0,1,1)),A=k,x=R}r.push(v)}else if(y=="sequence"){let b=new Wd(w.length,m,p),S=0;for(let C=0;C<w.length;C++){let v=L(x,"delay",S),A=L(x,"time",0),M=Fs[L(x,"mode","hold")],I=L(x,"index",0);b.setFrame(C,A,M,I,v),S=v,x=w[C+1]}r.push(b)}}}}}}if(t.drawOrder){let h=new Co(t.drawOrder.length),i=s.slots.length,a=0;for(let o=0;o<t.drawOrder.length;o++,a++){let d=t.drawOrder[o],u=null,m=L(d,"offsets",null);if(m){u=ht.newArray(i,-1);let c=ht.newArray(i-m.length,0),g=0,p=0;for(let y=0;y<m.length;y++){let w=m[y],x=s.findSlot(w.slot);if(!x)throw new Error("Slot not found: "+x);let b=x.index;for(;g!=b;)c[p++]=g++;u[g+w.offset]=g++}for(;g<i;)c[p++]=g++;for(let y=i-1;y>=0;y--)u[y]==-1&&(u[y]=c[--p])}h.setFrame(a,L(d,"time",0),u)}r.push(h)}if(t.events){let h=new Ch(t.events.length),i=0;for(let a=0;a<t.events.length;a++,i++){let o=t.events[a],d=s.findEvent(o.name);if(!d)throw new Error("Event not found: "+o.name);let u=new eu(ht.toSinglePrecision(L(o,"time",0)),d);u.intValue=L(o,"int",d.intValue),u.floatValue=L(o,"float",d.floatValue),u.stringValue=L(o,"string",d.stringValue),u.data.audioPath&&(u.volume=L(o,"volume",1),u.balance=L(o,"balance",0)),h.setFrame(i,u)}r.push(h)}let l=0;for(let h=0,i=r.length;h<i;h++)l=Math.max(l,r[h].getDuration());s.animations.push(new yh(e,r,l))}},mv=class{constructor(t,e,s,n,r){T(this,"parent");T(this,"skin");T(this,"slotIndex");T(this,"mesh");T(this,"inheritTimeline");this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}};function dr(f,t,e,s){let n=f[0],r=L(n,"time",0),l=L(n,"value",e)*s,h=0;for(let i=0;;i++){t.setFrame(i,r,l);let a=f[i+1];if(!a)return t.shrink(h),t;let o=L(a,"time",0),d=L(a,"value",e)*s;n.curve&&(h=Jt(n.curve,t,h,i,0,r,o,l,d,s)),r=o,l=d,n=a}}function cu(f,t,e,s,n,r){let l=f[0],h=L(l,"time",0),i=L(l,e,n)*r,a=L(l,s,n)*r,o=0;for(let d=0;;d++){t.setFrame(d,h,i,a);let u=f[d+1];if(!u)return t.shrink(o),t;let m=L(u,"time",0),c=L(u,e,n)*r,g=L(u,s,n)*r,p=l.curve;p&&(o=Jt(p,t,o,d,0,h,m,i,c,r),o=Jt(p,t,o,d,1,h,m,a,g,r)),h=m,i=c,a=g,l=u}}function Jt(f,t,e,s,n,r,l,h,i,a){if(f=="stepped")return t.setStepped(s),e;let o=n<<2,d=f[o],u=f[o+1]*a,m=f[o+2],c=f[o+3]*a;return t.setBezier(e,s,n,r,h,d,u,m,c,l,i),e+1}function L(f,t,e){return f[t]!==void 0?f[t]:e}typeof Math.fround=="undefined"&&(Math.fround=function(f){return function(t){return f[0]=t,f[0]}}(new Float32Array(1)));const Ai=class Ai extends Kd{constructor(e){super(e.resource.source);T(this,"texture");this.texture=V.Texture.from(e)}static from(e){return Ai.textureMap.has(e)?Ai.textureMap.get(e):new Ai(e)}setFilters(e,s){this.texture.baseTexture.scaleMode=Ai.toPixiTextureFilter(e),this.texture.baseTexture.mipmap=Ai.toPixiMipMap(e)}setWraps(e,s){this.texture.baseTexture.wrapMode=Ai.toPixiTextureWrap(e)}dispose(){this.texture.destroy()}static toPixiTextureFilter(e){switch(e){case is.Nearest:case is.MipMapNearestLinear:case is.MipMapNearestNearest:return V.SCALE_MODES.NEAREST;case is.Linear:case is.MipMapLinearLinear:case is.MipMapLinearNearest:return V.SCALE_MODES.LINEAR;default:throw new Error(`Unknown texture filter: ${String(e)}`)}}static toPixiMipMap(e){switch(e){case is.Nearest:case is.Linear:return V.MIPMAP_MODES.OFF;case is.MipMapNearestLinear:case is.MipMapNearestNearest:case is.MipMapLinearLinear:case is.MipMapLinearNearest:return V.MIPMAP_MODES.ON;default:throw new Error(`Unknown texture filter: ${String(e)}`)}}static toPixiTextureWrap(e){switch(e){case Ur.ClampToEdge:return V.WRAP_MODES.CLAMP;case Ur.MirroredRepeat:return V.WRAP_MODES.MIRRORED_REPEAT;case Ur.Repeat:return V.WRAP_MODES.REPEAT;default:throw new Error(`Unknown texture wrap: ${String(e)}`)}}static toPixiBlending(e){switch(e){case hi.Normal:return V.BLEND_MODES.NORMAL;case hi.Additive:return V.BLEND_MODES.ADD;case hi.Multiply:return V.BLEND_MODES.MULTIPLY;case hi.Screen:return V.BLEND_MODES.SCREEN;default:throw new Error(`Unknown blendMode: ${String(e)}`)}}};T(Ai,"textureMap",new Map);let Ga=Ai;const Mi=class Mi extends eh.Mesh{constructor(){const e=new eh.MeshGeometry;e.getBuffer("aVertexPosition").static=!1,e.getBuffer("aTextureCoord").static=!1;const s=new eh.MeshMaterial(V.Texture.EMPTY);super(e,s);T(this,"name","");T(this,"warnedTwoTint",!1)}updateFromSpineData(e,s,n,r,l,h,i,a){var y,w;this.texture=e.texture;const o=l/(a?12:8)*2,d=this.geometry.getBuffer("aTextureCoord");((y=d.data)==null?void 0:y.length)!==o&&(d.data=new Float32Array(o));const u=this.geometry.getBuffer("aVertexPosition");((w=u.data)==null?void 0:w.length)!==o&&(u.data=new Float32Array(o));let m=0,c=d.data,g=u.data;for(let x=0;x<l;x+=a?12:8){let b=x;g[m]=r[b++],g[m+1]=r[b++],b+=4,c[m]=r[b++],c[m+1]=r[b++],m+=2}a&&!this.warnedTwoTint&&(console.warn("DarkTint is not enabled by default. To enable use a DarkSlotMesh factory while creating the Spine object."),this.warnedTwoTint=!0),Mi.auxColor[0]=r[2],Mi.auxColor[1]=r[3],Mi.auxColor[2]=r[4],Mi.auxColor[3]=r[5],this.tint=Mi.auxColor,this.alpha=Mi.auxColor[3],this.blendMode=Ga.toPixiBlending(s);const p=this.geometry.indexBuffer;if(p.data.length!==h.length)p.data=new Uint32Array(h);else{const x=p.data;for(let b=0;b<i;b++)x[b]=h[b]}this.name=n,d.update(),u.update(),p.update()}};T(Mi,"auxColor",[0,0,0,0]);let Th=Mi;class hp extends V.Geometry{constructor(t=!1){super();const e=new V.Buffer(void 0),s=new V.Buffer(void 0,!0),n=new V.Buffer(void 0,!0,!0);this.addAttribute("aVertexPosition",e,2,!1,V.TYPES.FLOAT),this.addAttribute("aTextureCoord",s,2,!1,V.TYPES.FLOAT),this.addIndex(n)}}const gv=`
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`,pv=`
varying vec2 vTextureCoord;
uniform vec4 uColor;
uniform vec4 uDarkColor;

uniform sampler2D uSampler;

void main(void)
{
	vec4 texColor = texture2D(uSampler, vTextureCoord);
    gl_FragColor.a = texColor.a * uColor.a;
    gl_FragColor.rgb = ((texColor.a - 1.0) * uDarkColor.a + 1.0 - texColor.rgb) * uDarkColor.rgb + texColor.rgb * uColor.rgb;
}
`;class cp extends V.Shader{constructor(e){const s={uSampler:e!=null?e:V.Texture.EMPTY,alpha:1,uTextureMatrix:V.Matrix.IDENTITY,uColor:new Float32Array([1,1,1,1]),uDarkColor:new Float32Array([0,0,0,0])},n={tint:16777215,darkTint:0,alpha:1,pluginName:"darkTintBatch"};super(V.Program.from(gv,pv),s);T(this,"uvMatrix");T(this,"batchable");T(this,"pluginName");T(this,"_tintRGB");T(this,"_darkTintRGB");T(this,"_colorDirty");T(this,"_alpha");T(this,"_tintColor");T(this,"_darkTintColor");this._colorDirty=!1,this.uvMatrix=new V.TextureMatrix(s.uSampler),this.batchable=!0,this.pluginName=n.pluginName,this._tintColor=new V.Color(n.tint),this._darkTintColor=new V.Color(n.darkTint),this._tintRGB=this._tintColor.toLittleEndianNumber(),this._darkTintRGB=this._darkTintColor.toLittleEndianNumber(),this._alpha=n.alpha,this._colorDirty=!0}get texture(){return this.uniforms.uSampler}set texture(e){this.uniforms.uSampler!==e&&(!this.uniforms.uSampler.baseTexture.alphaMode!=!e.baseTexture.alphaMode&&(this._colorDirty=!0),this.uniforms.uSampler=e,this.uvMatrix.texture=e)}set alpha(e){e!==this._alpha&&(this._alpha=e,this._colorDirty=!0)}get alpha(){return this._alpha}set tint(e){e!==this.tint&&(this._tintColor.setValue(e),this._tintRGB=this._tintColor.toLittleEndianNumber(),this._colorDirty=!0)}get tint(){return this._tintColor.value}set darkTint(e){e!==this.darkTint&&(this._darkTintColor.setValue(e),this._darkTintRGB=this._darkTintColor.toLittleEndianNumber(),this._colorDirty=!0)}get darkTint(){return this._darkTintColor.value}get tintValue(){return this._tintColor.toNumber()}get darkTintValue(){return this._darkTintColor.toNumber()}update(){this._colorDirty&&(this._colorDirty=!1,V.Color.shared.setValue(this._tintColor).premultiply(this._alpha,!0).toArray(this.uniforms.uColor),V.Color.shared.setValue(this._darkTintColor).premultiply(this._alpha,!0).premultiply(1,!1).toArray(this.uniforms.uDarkColor)),this.uvMatrix.update()&&(this.uniforms.uTextureMatrix=this.uvMatrix.mapCoord)}}class dp extends eh.Mesh{constructor(e){super(new hp,new cp(e),void 0,void 0);T(this,"_darkTintRGB",0)}get darkTint(){return"darkTint"in this.shader?this.shader.darkTint:null}set darkTint(e){this.shader.darkTint=e}get darkTintValue(){return this.shader.darkTintValue}_renderToBatch(e){const s=this.geometry,n=this.shader;n.uvMatrix&&(n.uvMatrix.update(),this.calculateUvs()),this.calculateVertices(),this.indices=s.indexBuffer.data,this._tintRGB=n._tintRGB,this._darkTintRGB=n._darkTintRGB,this._texture=n.texture;const r=this.material.pluginName;e.batch.setObjectRenderer(e.plugins[r]),e.plugins[r].render(this)}}const cs=class cs extends dp{constructor(){super();T(this,"name","")}updateFromSpineData(e,s,n,r,l,h,i,a){var y,w;this.texture=e.texture;const o=l/(a?12:8)*2,d=this.geometry.getBuffer("aTextureCoord");((y=d.data)==null?void 0:y.length)!==o&&(d.data=new Float32Array(o));const u=this.geometry.getBuffer("aVertexPosition");((w=u.data)==null?void 0:w.length)!==o&&(u.data=new Float32Array(o));let m=0,c=d.data,g=u.data;for(let x=0;x<l;x+=a?12:8){let b=x;g[m]=r[b++],g[m+1]=r[b++],b+=4,c[m]=r[b++],c[m+1]=r[b++],m+=2}a?(cs.auxColor[0]=r[8],cs.auxColor[1]=r[9],cs.auxColor[2]=r[10],cs.auxColor[3]=r[11],this.darkTint=cs.auxColor,cs.auxColor[0]=r[2],cs.auxColor[1]=r[3],cs.auxColor[2]=r[4],cs.auxColor[3]=r[5],this.tint=cs.auxColor):(cs.auxColor[0]=r[2],cs.auxColor[1]=r[3],cs.auxColor[2]=r[4],cs.auxColor[3]=r[5],this.tint=cs.auxColor),this.blendMode=Ga.toPixiBlending(s),this.alpha=cs.auxColor[3];const p=this.geometry.indexBuffer;if(p.data.length!==h.length)p.data=new Uint32Array(h);else{const x=p.data;for(let b=0;b<i;b++)x[b]=h[b]}this.name=n,d.update(),u.update(),p.update()}};T(cs,"auxColor",[0,0,0,0]);let To=cs;class xv{constructor(t,e,s,n){T(this,"x");T(this,"y");T(this,"width");T(this,"height");this.x=t,this.y=e,this.width=s,this.height=n}calculateBounds(){return{x:this.x,y:this.y,width:this.width,height:this.height}}}class bv{constructor(t=!1){T(this,"clipping");this.clipping=t}calculateBounds(t){if(!t.skeleton)return{x:0,y:0,width:0,height:0};const e=new Mo(t.skeleton.data);e.setToSetupPose(),e.updateWorldTransform(Un.update);const s=e.getBoundsRect(this.clipping?new za:void 0);return s.width==Number.NEGATIVE_INFINITY?{x:0,y:0,width:0,height:0}:s}}class wv{constructor(t,e=[],s=.05,n=!1){T(this,"animation");T(this,"skins");T(this,"timeStep");T(this,"clipping");this.animation=t,this.skins=e,this.timeStep=s,this.clipping=n}calculateBounds(t){if(!t.skeleton||!t.state)return{x:0,y:0,width:0,height:0};const e=new Ud(t.state.data),s=new Mo(t.skeleton.data),n=this.clipping?new za:void 0,r=s.data;if(this.skins.length>0){let h=new El("custom-skin");for(const i of this.skins){const a=r.findSkin(i);a!=null&&h.addSkin(a)}s.setSkin(h)}s.setToSetupPose();const l=this.animation!=null?r.findAnimation(this.animation):null;if(l==null){s.updateWorldTransform(Un.update);const h=s.getBoundsRect(n);return h.width==Number.NEGATIVE_INFINITY?{x:0,y:0,width:0,height:0}:h}else{let h=Number.POSITIVE_INFINITY,i=Number.POSITIVE_INFINITY,a=Number.NEGATIVE_INFINITY,o=Number.NEGATIVE_INFINITY;e.clearTracks(),e.setAnimationWith(0,l,!1);const d=Math.max(l.duration/this.timeStep,1);for(let m=0;m<d;m++){const c=m>0?this.timeStep:0;e.update(c),e.apply(s),s.update(c),s.updateWorldTransform(Un.update);const g=s.getBoundsRect(n);h=Math.min(h,g.x),i=Math.min(i,g.y),a=Math.max(a,g.x+g.width),o=Math.max(o,g.y+g.height)}const u={x:h,y:i,width:a-h,height:o-i};return u.width==Number.NEGATIVE_INFINITY?{x:0,y:0,width:0,height:0}:u}}}let yv=(Ht=class extends Et.Container{constructor(e,s){var l;if(e instanceof Tl)e=Ef(Tf({},s),{skeletonData:e});else if(s)throw new Error("You cannot use options and oldOptions together.");super();T(this,"skeleton");T(this,"state");T(this,"darkTint",!1);T(this,"hasNeverUpdated",!0);T(this,"_debug");T(this,"slotMeshFactory",()=>new Th);T(this,"beforeUpdateWorldTransforms",()=>{});T(this,"afterUpdateWorldTransforms",()=>{});T(this,"autoUpdateWarned",!1);T(this,"_autoUpdate",!0);T(this,"meshesCache",new Map);T(this,"lightColor",new Yt);T(this,"darkColor",new Yt);T(this,"_boundsProvider");T(this,"_boundsPoint",new V.Point);T(this,"_boundsSpineID",-1);T(this,"_boundsSpineDirty",!0);T(this,"slotsObject",new Map);T(this,"verticesCache",ht.newFloatArray(1024));T(this,"clippingSlotToPixiMasks",{});T(this,"currentClippingSlot");const n=e instanceof Tl?e:e.skeletonData;this.skeleton=new Mo(n);const r=new jg(n);this.state=new Ud(r),(e==null?void 0:e.darkTint)!==void 0||(s==null?void 0:s.slotMeshFactory)===void 0?(this.darkTint=(e==null?void 0:e.darkTint)===void 0?this.skeleton.slots.some(h=>!!h.data.darkColor):e==null?void 0:e.darkTint,this.darkTint&&(this.slotMeshFactory=()=>new To)):this.initializeMeshFactory(s==null?void 0:s.slotMeshFactory),this.autoUpdate=(l=e==null?void 0:e.autoUpdate)!=null?l:!0,this.boundsProvider=e.boundsProvider}get debug(){return this._debug}set debug(e){this._debug&&this._debug.unregisterSpine(this),e&&e.registerSpine(this),this._debug=e}get autoUpdate(){return this._autoUpdate}set autoUpdate(e){e?(V.Ticker.shared.add(this.internalUpdate,this),this.autoUpdateWarned=!1):V.Ticker.shared.remove(this.internalUpdate,this),this._autoUpdate=e}get boundsProvider(){return this._boundsProvider}set boundsProvider(e){this._boundsProvider=e,e?(this._boundsSpineID=-1,this._boundsSpineDirty=!0,this.interactiveChildren=!1):(this.interactiveChildren=!0,this.hitArea=null),this.calculateBounds()}initializeMeshFactory(e){if(e){this.slotMeshFactory=e;const s=this.slotMeshFactory();s instanceof To&&(this.darkTint=!0),s.destroy()}else for(let s=0;s<this.skeleton.slots.length;s++)if(this.skeleton.slots[s].data.darkColor){this.slotMeshFactory=()=>new To,this.darkTint=!0;break}}update(e){this.autoUpdate&&!this.autoUpdateWarned&&(console.warn("You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want."),this.autoUpdateWarned=!0),this.internalUpdate(0,e)}internalUpdate(e,s){this.hasNeverUpdated=!1;const n=s!=null?s:V.Ticker.shared.deltaMS/1e3;this.state.update(n),this.state.apply(this.skeleton),this.beforeUpdateWorldTransforms(this),this.skeleton.update(n),this.skeleton.updateWorldTransform(Un.update),this.afterUpdateWorldTransforms(this)}updateTransform(){var e;this.renderMeshes(),this.sortChildren(),(e=this.debug)==null||e.renderDebug(this),super.updateTransform()}destroy(e){var s;this.autoUpdate&&(this.autoUpdate=!1);for(const[,n]of this.meshesCache)n==null||n.destroy();this.state.clearListeners(),this.debug=void 0,this.meshesCache.clear(),this.slotsObject.clear();for(let n in this.clippingSlotToPixiMasks)(s=this.clippingSlotToPixiMasks[n].mask)==null||s.destroy(),delete this.clippingSlotToPixiMasks[n];super.destroy(e)}resetMeshes(){for(const[,e]of this.meshesCache)e.zIndex=-1,e.visible=!1}_calculateBounds(){this.hasNeverUpdated&&(this.internalUpdate(0,0),this.renderMeshes())}hasMeshForSlot(e){return this.meshesCache.has(e)}getMeshForSlot(e){if(this.hasMeshForSlot(e)){let s=this.meshesCache.get(e);return s.visible=!0,s}else{let s=this.slotMeshFactory();return this.addChild(s),this.meshesCache.set(e,s),s}}getSlotFromRef(e){let s;if(typeof e=="number"?s=this.skeleton.slots[e]:typeof e=="string"?s=this.skeleton.findSlot(e):s=e,!s)throw new Error(`No slot found with the given slot reference: ${e}`);return s}addSlotObject(e,s,n){var h;let r=this.getSlotFromRef(e);const l=(h=this.slotsObject.get(r))==null?void 0:h.container;if(!(l&&l===s)){for(const[i,{container:a}]of this.slotsObject)if(i!==r&&a===s){this.removeSlotObject(i,s);break}l&&this.removeChild(l),this.slotsObject.set(r,{container:s,followAttachmentTimeline:(n==null?void 0:n.followAttachmentTimeline)||!1}),this.addChild(s)}}getSlotObject(e){const s=this.slotsObject.get(this.getSlotFromRef(e));return s?s.container:void 0}removeSlotObject(e,s){var l;let n=this.getSlotFromRef(e),r=(l=this.slotsObject.get(n))==null?void 0:l.container;r&&(s&&s!==r||(this.removeChild(r),this.slotsObject.delete(n)))}removeSlotObjects(){for(const[,e]of this.slotsObject)e.container.removeFromParent();this.slotsObject.clear()}updateSlotObject(e,s,n){const{container:r,followAttachmentTimeline:l}=e,h=l?!!s.attachment:!0;if(r.visible=this.skeleton.drawOrder.includes(s)&&h,r.visible){r.position.set(s.bone.worldX,s.bone.worldY),r.angle=s.bone.getWorldRotationX();let i=s.bone,a=1,o=1;for(;i;)a*=i.scaleX,o*=i.scaleY,i=i.parent;a<0&&(r.angle-=180),r.scale.set(s.bone.getWorldScaleX()*Math.sign(a),s.bone.getWorldScaleY()*Math.sign(o)),r.zIndex=n+1,r.alpha=this.skeleton.color.a*s.color.a}}updateAndSetPixiMask(e,s){var h,i;const n=e.attachment;if(n&&n instanceof qa){const a=(h=this.clippingSlotToPixiMasks)[i=e.data.name]||(h[i]={slot:e,vertices:new Array});a.maskComputed=!1,this.currentClippingSlot=a;return}let r=this.currentClippingSlot;const l=this.slotsObject.get(e);if(r&&l){let a=r.mask;if(a||(a=up.obtain(),r.mask=a,this.addChild(a)),!r.maskComputed){let o=r.slot,d=o.attachment;r.maskComputed=!0;const u=d.worldVerticesLength,m=r.vertices;d.computeWorldVertices(o,0,u,m,0,2),a.clear().lineStyle(0).beginFill(0).drawPolygon(m).endFill()}l.container.mask=a}else l!=null&&l.container.mask&&(l.container.mask=null);if(r&&r.slot.attachment.endSlot==e.data&&(this.currentClippingSlot=void 0),s){for(const a in this.clippingSlotToPixiMasks){const o=this.clippingSlotToPixiMasks[a];(!(o.slot.attachment instanceof qa)||!o.maskComputed)&&o.mask&&(this.removeChild(o.mask),up.free(o.mask),o.mask=void 0)}this.currentClippingSlot=void 0}}renderMeshes(){var r,l;this.resetMeshes();let e=null,s=null;const n=this.skeleton.drawOrder;for(let h=0,i=n.length,a=0;h<i;h++){const o=n[h];let d=this.slotsObject.get(o),u=h+a;d&&(this.updateSlotObject(d,o,u+1),a++),this.updateAndSetPixiMask(o,h===n.length-1);const m=o.darkColor!=null,c=Ht.clipper.isClipping()?2:m?Ht.DARK_VERTEX_SIZE:Ht.VERTEX_SIZE;if(!o.bone.active){Ht.clipper.clipEndWithSlot(o);continue}const g=o.getAttachment();let p,y,w=0;if(g instanceof Al){const x=g;p=x.color,w=c*4,x.computeWorldVertices(o,this.verticesCache,0,c),e=Ht.QUAD_TRIANGLES,s=x.uvs,y=(r=x.region)==null?void 0:r.texture}else if(g instanceof vo){const x=g;p=x.color,w=(x.worldVerticesLength>>1)*c,w>this.verticesCache.length&&(this.verticesCache=ht.newFloatArray(w)),x.computeWorldVertices(o,0,x.worldVerticesLength,this.verticesCache,0,c),e=x.triangles,s=x.uvs,y=(l=x.region)==null?void 0:l.texture}else if(g instanceof qa){Ht.clipper.clipStart(o,g);continue}else{this.hasMeshForSlot(o)&&(this.getMeshForSlot(o).visible=!1),Ht.clipper.clipEndWithSlot(o);continue}if(y!=null){const b=o.bone.skeleton.color,S=o.color,C=b.a*S.a*p.a;this.lightColor.set(b.r*S.r*p.r,b.g*S.g*p.g,b.b*S.b*p.b,C),o.darkColor!=null?this.darkColor.set(o.darkColor.r,o.darkColor.g,o.darkColor.b,1):this.darkColor.set(0,0,0,1);let v,A,M,I;if(Ht.clipper.isClipping())Ht.clipper.clipTriangles(this.verticesCache,e,e.length,s,this.lightColor,this.darkColor,m),v=Ht.clipper.clippedVertices,A=v.length,M=Ht.clipper.clippedTriangles,I=M.length;else{const P=this.verticesCache;for(let R=2,k=0,Y=w;R<Y;R+=c,k+=2){let F=R;P[F++]=this.lightColor.r,P[F++]=this.lightColor.g,P[F++]=this.lightColor.b,P[F++]=this.lightColor.a,P[F++]=s[k],P[F++]=s[k+1],m&&(P[F++]=this.darkColor.r,P[F++]=this.darkColor.g,P[F++]=this.darkColor.b,P[F++]=this.darkColor.a)}v=this.verticesCache,A=w,M=e,I=e.length}if(A==0||I==0){Ht.clipper.clipEndWithSlot(o);continue}const E=this.getMeshForSlot(o);E.renderable=!0,E.zIndex=u,E.updateFromSpineData(y,o.data.blendMode,o.data.name,v,A,M,I,m)}Ht.clipper.clipEndWithSlot(o)}Ht.clipper.clipEnd()}calculateBounds(){if(!this._boundsProvider){super.calculateBounds();return}const e=this.transform;if(this._boundsSpineID===e._worldID)return;this.updateBounds();const s=this._localBounds,n=this._boundsPoint;n.set(s.minX,s.minY),e.worldTransform.apply(n,n),this._bounds.minX=n.x,this._bounds.minY=n.y,n.set(s.maxX,s.maxY),e.worldTransform.apply(n,n),this._bounds.maxX=n.x,this._bounds.maxY=n.y}updateBounds(){if(!this._boundsProvider||!this._boundsSpineDirty)return;this._boundsSpineDirty=!1,this._localBounds||(this._localBounds=new Et.Bounds);const e=this._boundsProvider.calculateBounds(this),s=this._localBounds;s.clear(),s.minX=e.x,s.minY=e.y,s.maxX=e.x+e.width,s.maxY=e.y+e.height,this.hitArea=this._localBounds.getRectangle()}setBonePosition(e,s){const n=e;if(typeof e=="string"&&(e=this.skeleton.findBone(e)),!e)throw Error(`Cannot set bone position, bone ${String(n)} not found`);if(Ht.vectorAux.set(s.x,s.y),e.parent){const r=e.parent.worldToLocal(Ht.vectorAux);e.x=r.x,e.y=r.y}else e.x=Ht.vectorAux.x,e.y=Ht.vectorAux.y}getBonePosition(e,s){const n=e;return typeof e=="string"&&(e=this.skeleton.findBone(e)),e?(s||(s={x:0,y:0}),s.x=e.worldX,s.y=e.worldY,s):(console.error(`Cannot get bone position! Bone ${String(n)} not found`),s)}skeletonToPixiWorldCoordinates(e){this.worldTransform.apply(e,e)}pixiWorldCoordinatesToSkeleton(e){this.worldTransform.applyInverse(e,e)}pixiWorldCoordinatesToBone(e,s){this.pixiWorldCoordinatesToSkeleton(e),s.parent?s.parent.worldToLocal(e):s.worldToLocal(e)}static from(e,s,n){if(typeof e=="string")return Ht.oldFrom(e,s,n);const{skeleton:r,atlas:l,scale:h=1,darkTint:i,autoUpdate:a,boundsProvider:o}=e,d=`${r}-${l}-${h}`;let u=Ht.skeletonCache[d];if(!u){const m=Se.Assets.get(r),c=Se.Assets.get(l),g=new Jd(c);let p=m instanceof Uint8Array?new ou(g):new hu(g);p.scale=h,u=p.readSkeletonData(m),Ht.skeletonCache[d]=u}return new Ht({skeletonData:u,darkTint:i,autoUpdate:a,boundsProvider:o})}static oldFrom(e,s,n){var d,u;const r=`${e}-${s}-${(d=n==null?void 0:n.scale)!=null?d:1}`;let l=Ht.skeletonCache[r];if(l)return new Ht(l,n);const h=Se.Assets.get(e),i=Se.Assets.get(s),a=new Jd(i);let o=h instanceof Uint8Array?new ou(a):new hu(a);return o.scale=(u=n==null?void 0:n.scale)!=null?u:1,l=o.readSkeletonData(h),Ht.skeletonCache[r]=l,new this(l,n)}get tint(){return this.skeleton.color.toRgb888()}set tint(e){Yt.rgb888ToColor(this.skeleton.color,e)}},T(Ht,"vectorAux",new Sl),T(Ht,"clipper",new za),T(Ht,"QUAD_TRIANGLES",[0,1,2,2,3,0]),T(Ht,"VERTEX_SIZE",8),T(Ht,"DARK_VERTEX_SIZE",12),T(Ht,"skeletonCache",Object.create(null)),Ht);const up=new So(()=>new le.Graphics);Mo.yDown=!0;let fp=class{constructor(){T(this,"minX",0);T(this,"minY",0);T(this,"maxX",0);T(this,"maxY",0);T(this,"boundingBoxes",new Array);T(this,"polygons",new Array);T(this,"polygonPool",new So(()=>ht.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");let s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,l=t.slots,h=l.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){let a=l[i];if(!a.bone.active)continue;let o=a.getAttachment();if(o instanceof Hd){let d=o;s.push(d);let u=r.obtain();u.length!=d.worldVerticesLength&&(u=ht.newFloatArray(d.worldVerticesLength)),n.push(u),d.computeWorldVertices(a,0,d.worldVerticesLength,u,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY,r=this.polygons;for(let l=0,h=r.length;l<h;l++){let i=r[l],a=i;for(let o=0,d=i.length;o<d;o+=2){let u=a[o],m=a[o+1];t=Math.min(t,u),e=Math.min(e,m),s=Math.max(s,u),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){let r=this.minX,l=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=l&&n<=l||t>=h&&s>=h||e>=i&&n>=i)return!1;let a=(n-e)/(s-t),o=a*(r-t)+e;if(o>l&&o<i||(o=a*(h-t)+e,o>l&&o<i))return!0;let d=(l-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){let s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){let n=t,r=t.length,l=r-2,h=!1;for(let i=0;i<r;i+=2){let a=n[i+1],o=n[l+1];if(a<s&&o>=s||o<s&&a>=s){let d=n[i];d+(s-a)/(o-a)*(n[l]-d)<e&&(h=!h)}l=i}return h}intersectsSegment(t,e,s,n){let r=this.polygons;for(let l=0,h=r.length;l<h;l++)if(this.intersectsSegmentPolygon(r[l],t,e,s,n))return this.boundingBoxes[l];return null}intersectsSegmentPolygon(t,e,s,n,r){let l=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n,d=l[h-2],u=l[h-1];for(let m=0;m<h;m+=2){let c=l[m],g=l[m+1],p=d*g-u*c,y=d-c,w=u-g,x=i*w-a*y,b=(o*y-i*p)/x;if((b>=d&&b<=c||b>=c&&b<=d)&&(b>=e&&b<=n||b>=n&&b<=e)){let S=(o*w-a*p)/x;if((S>=u&&S<=g||S>=g&&S<=u)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=c,u=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");let e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}},Sv=class{constructor(){T(this,"registeredSpines",new Map);T(this,"drawMeshHull",!0);T(this,"drawMeshTriangles",!0);T(this,"drawBones",!0);T(this,"drawPaths",!0);T(this,"drawBoundingBoxes",!0);T(this,"drawClipping",!0);T(this,"drawRegionAttachments",!0);T(this,"drawEvents",!0);T(this,"lineWidth",1);T(this,"regionAttachmentsColor",30975);T(this,"meshHullColor",30975);T(this,"meshTrianglesColor",16763904);T(this,"clippingPolygonColor",16711935);T(this,"boundingBoxesRectColor",65280);T(this,"boundingBoxesPolygonColor",65280);T(this,"boundingBoxesCircleColor",65280);T(this,"pathsCurveColor",16711680);T(this,"pathsLineColor",16711935);T(this,"skeletonXYColor",16711680);T(this,"bonesColor",61132);T(this,"eventFontSize",24);T(this,"eventFontColor",0)}registerSpine(t){if(this.registeredSpines.has(t)){console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",t);return}const e={parentDebugContainer:new Et.Container,bones:new Et.Container,skeletonXY:new le.Graphics,regionAttachmentsShape:new le.Graphics,meshTrianglesLine:new le.Graphics,meshHullLine:new le.Graphics,clippingPolygon:new le.Graphics,boundingBoxesRect:new le.Graphics,boundingBoxesCircle:new le.Graphics,boundingBoxesPolygon:new le.Graphics,pathsCurve:new le.Graphics,pathsLine:new le.Graphics,eventText:new Et.Container,eventCallback:{event:(s,n)=>{if(this.drawEvents){const r=Math.abs(t.scale.x||t.scale.y||1),l=new mb.Text(n.data.name,{fontSize:this.eventFontSize/r,fill:this.eventFontColor,fontFamily:"monospace"});l.scale.x=Math.sign(t.scale.x),l.anchor.set(.5),e.eventText.addChild(l),setTimeout(()=>{l.destroyed||l.destroy()},250)}}}};e.parentDebugContainer.addChild(e.bones),e.parentDebugContainer.addChild(e.skeletonXY),e.parentDebugContainer.addChild(e.regionAttachmentsShape),e.parentDebugContainer.addChild(e.meshTrianglesLine),e.parentDebugContainer.addChild(e.meshHullLine),e.parentDebugContainer.addChild(e.clippingPolygon),e.parentDebugContainer.addChild(e.boundingBoxesRect),e.parentDebugContainer.addChild(e.boundingBoxesCircle),e.parentDebugContainer.addChild(e.boundingBoxesPolygon),e.parentDebugContainer.addChild(e.pathsCurve),e.parentDebugContainer.addChild(e.pathsLine),e.parentDebugContainer.addChild(e.eventText),e.parentDebugContainer.zIndex=9999999,e.parentDebugContainer.accessibleChildren=!1,e.parentDebugContainer.eventMode="none",e.parentDebugContainer.interactiveChildren=!1,t.addChild(e.parentDebugContainer),t.state.addListener(e.eventCallback),this.registeredSpines.set(t,e)}renderDebug(t){this.registeredSpines.has(t)||this.registerSpine(t);const e=this.registeredSpines.get(t);if(!e)return;t.addChild(e.parentDebugContainer),e.skeletonXY.clear(),e.regionAttachmentsShape.clear(),e.meshTrianglesLine.clear(),e.meshHullLine.clear(),e.clippingPolygon.clear(),e.boundingBoxesRect.clear(),e.boundingBoxesCircle.clear(),e.boundingBoxesPolygon.clear(),e.pathsCurve.clear(),e.pathsLine.clear();for(let r=e.bones.children.length;r>0;r--)e.bones.children[r-1].destroy({children:!0,texture:!0,baseTexture:!0});const s=Math.abs(t.scale.x||t.scale.y||1),n=this.lineWidth/s;if(this.drawBones&&this.drawBonesFunc(t,e,n,s),this.drawPaths&&this.drawPathsFunc(t,e,n),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(t,e,n),this.drawClipping&&this.drawClippingFunc(t,e,n),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(t,e,n),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(t,e,n),this.drawEvents)for(const r of e.eventText.children)r.alpha-=.05,r.y-=2}drawBonesFunc(t,e,s,n){const r=t.skeleton,l=r.x,h=r.y,i=r.bones;e.skeletonXY.lineStyle(s,this.skeletonXYColor,1);for(let o=0,d=i.length;o<d;o++){const u=i[o],m=u.data.length,c=l+u.worldX,g=h+u.worldY,p=l+m*u.a+u.worldX,y=h+m*u.b+u.worldY;if(u.data.name==="root"||u.data.parent===null)continue;const w=Math.abs(c-p),x=Math.abs(g-y),b=Math.pow(w,2),S=x,C=Math.pow(x,2),v=Math.sqrt(b+C),A=Math.pow(v,2),M=Math.PI/180,I=Math.acos((A+C-b)/(2*S*v))||0;if(v===0)continue;const E=new le.Graphics;e.bones.addChild(E);const P=v/50/n;E.beginFill(this.bonesColor,1),E.drawPolygon(0,0,0-P,v-P*3,0,v-P,0+P,v-P*3),E.endFill(),E.x=c,E.y=g,E.pivot.y=v;let R=0;c<p&&g<y?R=-I+180*M:c>p&&g<y?R=180*M+I:c>p&&g>y?R=-I:c<p&&g>y?R=I:g===y&&c<p?R=90*M:g===y&&c>p?R=-90*M:c===p&&g<y?R=180*M:c===p&&g>y&&(R=0),E.rotation=R,E.lineStyle(s+P/2.4,this.bonesColor,1),E.beginFill(0,.6),E.drawCircle(0,v,P*1.2),E.endFill()}const a=s*3;e.skeletonXY.moveTo(l-a,h-a),e.skeletonXY.lineTo(l+a,h+a),e.skeletonXY.moveTo(l+a,h-a),e.skeletonXY.lineTo(l-a,h+a)}drawRegionAttachmentsFunc(t,e,s){const r=t.skeleton.slots;e.regionAttachmentsShape.lineStyle(s,this.regionAttachmentsColor,1);for(let l=0,h=r.length;l<h;l++){const i=r[l],a=i.getAttachment();if(a==null||!(a instanceof Al))continue;const o=a,d=new Float32Array(8);o.computeWorldVertices(i,d,0,2),e.regionAttachmentsShape.drawPolygon(Array.from(d.slice(0,8)))}}drawMeshHullAndMeshTriangles(t,e,s){const r=t.skeleton.slots;e.meshHullLine.lineStyle(s,this.meshHullColor,1),e.meshTrianglesLine.lineStyle(s,this.meshTrianglesColor,1);for(let l=0,h=r.length;l<h;l++){const i=r[l];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||!(a instanceof vo))continue;const o=a,d=new Float32Array(o.worldVerticesLength),u=o.triangles;let m=o.hullLength;if(o.computeWorldVertices(i,0,o.worldVerticesLength,d,0,2),this.drawMeshTriangles)for(let c=0,g=u.length;c<g;c+=3){const p=u[c]*2,y=u[c+1]*2,w=u[c+2]*2;e.meshTrianglesLine.moveTo(d[p],d[p+1]),e.meshTrianglesLine.lineTo(d[y],d[y+1]),e.meshTrianglesLine.lineTo(d[w],d[w+1])}if(this.drawMeshHull&&m>0){m=(m>>1)*2;let c=d[m-2],g=d[m-1];for(let p=0,y=m;p<y;p+=2){const w=d[p],x=d[p+1];e.meshHullLine.moveTo(w,x),e.meshHullLine.lineTo(c,g),c=w,g=x}}}}drawClippingFunc(t,e,s){const r=t.skeleton.slots;e.clippingPolygon.lineStyle(s,this.clippingPolygonColor,1);for(let l=0,h=r.length;l<h;l++){const i=r[l];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||!(a instanceof qa))continue;const o=a,d=o.worldVerticesLength,u=new Float32Array(d);o.computeWorldVertices(i,0,d,u,0,2),e.clippingPolygon.drawPolygon(Array.from(u))}}drawBoundingBoxesFunc(t,e,s){e.boundingBoxesRect.lineStyle(s,this.boundingBoxesRectColor,5);const n=new fp;n.update(t.skeleton,!0),n.minX!==1/0&&e.boundingBoxesRect.drawRect(n.minX,n.minY,n.getWidth(),n.getHeight());const r=n.polygons,l=(h,i,a)=>{if(e.boundingBoxesPolygon.lineStyle(s,this.boundingBoxesPolygonColor,1),e.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),a<3)throw new Error("Polygon must contain at least 3 vertices");const o=[],d=s*2;for(let u=0,m=h.length;u<m;u+=2){const c=h[u],g=h[u+1];e.boundingBoxesCircle.lineStyle(0),e.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),e.boundingBoxesCircle.drawCircle(c,g,d),e.boundingBoxesCircle.endFill(),o.push(c,g)}e.boundingBoxesPolygon.drawPolygon(o),e.boundingBoxesPolygon.endFill()};for(let h=0,i=r.length;h<i;h++){const a=r[h];l(a,0,a.length)}}drawPathsFunc(t,e,s){const r=t.skeleton.slots;e.pathsCurve.lineStyle(s,this.pathsCurveColor,1),e.pathsLine.lineStyle(s,this.pathsLineColor,1);for(let l=0,h=r.length;l<h;l++){const i=r[l];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||!(a instanceof Ao))continue;const o=a;let d=o.worldVerticesLength;const u=new Float32Array(d);o.computeWorldVertices(i,0,d,u,0,2);let m=u[2],c=u[3],g=0,p=0;if(o.closed){const y=u[0],w=u[1],x=u[d-2],b=u[d-1];g=u[d-4],p=u[d-3],e.pathsCurve.moveTo(m,c),e.pathsCurve.bezierCurveTo(y,w,x,b,g,p),e.pathsLine.moveTo(m,c),e.pathsLine.lineTo(y,w),e.pathsLine.moveTo(g,p),e.pathsLine.lineTo(x,b)}d-=4;for(let y=4;y<d;y+=6){const w=u[y],x=u[y+1],b=u[y+2],S=u[y+3];g=u[y+4],p=u[y+5],e.pathsCurve.moveTo(m,c),e.pathsCurve.bezierCurveTo(w,x,b,S,g,p),e.pathsLine.moveTo(m,c),e.pathsLine.lineTo(w,x),e.pathsLine.moveTo(g,p),e.pathsLine.lineTo(b,S),m=g,c=p}}}unregisterSpine(t){this.registeredSpines.has(t)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",t);const e=this.registeredSpines.get(t);e&&(t.state.removeListener(e.eventCallback),e.parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(t))}};const Cv={extension:V.ExtensionType.Asset,resolver:{test:f=>Se.checkExtension(f,".atlas"),parse:f=>{var e,s,n;const t=f.split(".");return{resolution:parseFloat((n=(s=(e=V.settings.RETINA_PREFIX)==null?void 0:e.exec(f))==null?void 0:s[1])!=null?n:"1"),format:t[t.length-2],src:f}}},loader:{extension:{type:V.ExtensionType.LoadParser,priority:Se.LoaderParserPriority.Normal,name:"spineTextureAtlasLoader"},test(f){return Se.checkExtension(f,".atlas")},async load(f){return await(await V.settings.ADAPTER.fetch(f)).text()},testParse(f,t){const e=Se.checkExtension(t.src,".atlas"),s=typeof f=="string";return Promise.resolve(e&&s)},unload(f){f.dispose()},async parse(f,t,e){var i;const s=t.data||{};let n=V.utils.path.dirname(t.src);n&&n.lastIndexOf("/")!==n.length-1&&(n+="/");const r=new Mh(f);if(s.images instanceof V.BaseTexture||typeof s.images=="string"){const a=s.images;s.images={},s.images[r.pages[0].name]=a}const l=[];let h=!0;for(const a of e.parsers)if(a.name=="loadTextures"){h=(i=a.config)==null?void 0:i.preferCreateImageBitmap;break}Se.Assets.setPreferences({preferCreateImageBitmap:!1});for(const a of r.pages){const o=a.name,d=s!=null&&s.images?s.images[o]:void 0;if(d instanceof V.BaseTexture)a.setTexture(Ga.from(d));else{const u=d!=null?d:V.utils.path.normalize([...n.split(V.utils.path.sep),o].join(V.utils.path.sep)),m={src:Se.copySearchParams(u,t.src),data:Ef(Tf({},s.imageMetadata),{alphaMode:a.pma?V.ALPHA_MODES.PMA:V.ALPHA_MODES.UNPACK})},c=e.load(m).then(g=>{a.setTexture(Ga.from(g.baseTexture))});l.push(c)}}return await Promise.all(l),Se.Assets.setPreferences({preferCreateImageBitmap:h}),r}}};V.extensions.add(Cv);function vv(f){return f.hasOwnProperty("bones")}function Av(f){return f instanceof Uint8Array}const Mv={extension:V.ExtensionType.Asset,loader:{extension:{type:V.ExtensionType.LoadParser,priority:Se.LoaderParserPriority.Normal},test(f){return Se.checkExtension(f,".skel")},async load(f){const t=await V.settings.ADAPTER.fetch(f);return new Uint8Array(await t.arrayBuffer())},testParse(f,t){const e=Se.checkExtension(t.src,".json")&&vv(f),s=Se.checkExtension(t.src,".skel")&&Av(f);return Promise.resolve(e||s)}}};V.extensions.add(Mv);class mp extends V.Geometry{constructor(e=!1){super();T(this,"_buffer");T(this,"_indexBuffer");this._buffer=new V.Buffer(void 0,e,!1),this._indexBuffer=new V.Buffer(void 0,e,!0),this.addAttribute("aVertexPosition",this._buffer,2,!1,V.TYPES.FLOAT).addAttribute("aTextureCoord",this._buffer,2,!1,V.TYPES.FLOAT).addAttribute("aColor",this._buffer,4,!0,V.TYPES.UNSIGNED_BYTE).addAttribute("aDarkColor",this._buffer,4,!0,V.TYPES.UNSIGNED_BYTE).addAttribute("aTextureId",this._buffer,1,!0,V.TYPES.FLOAT).addIndex(this._indexBuffer)}}const Tv=`
precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute vec4 aDarkColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying vec4 vDarkColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
    vDarkColor = aDarkColor * tint;

}
`,Ev=`
varying vec2 vTextureCoord;
varying vec4 vColor;
varying vec4 vDarkColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%


    gl_FragColor.a = color.a * vColor.a;
    gl_FragColor.rgb = ((color.a - 1.0) * vDarkColor.a + 1.0 - color.rgb) * vDarkColor.rgb + color.rgb * vColor.rgb;
}
`;class du extends V.BatchRenderer{constructor(t){super(t),this.shaderGenerator=new V.BatchShaderGenerator(Tv,Ev),this.geometryClass=mp,this.vertexSize=7}packInterleavedGeometry(t,e,s,n,r){const{uint32View:l,float32View:h}=e,i=n/this.vertexSize,a=t.uvs,o=t.indices,d=t.vertexData,u=t._texture.baseTexture._batchLocation,m=Math.min(t.worldAlpha,1),c=V.Color.shared.setValue(t._tintRGB).toPremultiplied(m,!0),g=V.Color.shared.setValue(t._darkTintRGB).premultiply(m,!0).toPremultiplied(1,!1);for(let p=0;p<d.length;p+=2)h[n++]=d[p],h[n++]=d[p+1],h[n++]=a[p],h[n++]=a[p+1],l[n++]=c,l[n++]=g,h[n++]=u;for(let p=0;p<o.length;p++)s[r++]=i+o[p]}}T(du,"extension",{name:"darkTintBatch",type:V.ExtensionType.RendererPlugin}),V.extensions.add(du);class Iv{constructor(t,e="",s=new gp){T(this,"pathPrefix","");T(this,"textureLoader");T(this,"downloader");T(this,"assets",{});T(this,"assetsRefCount",{});T(this,"assetsLoaded",{});T(this,"errors",{});T(this,"toLoad",0);T(this,"loaded",0);this.textureLoader=t,this.pathPrefix=e,this.downloader=s}start(t){return this.toLoad++,this.pathPrefix+t}success(t,e,s){this.toLoad--,this.loaded++,this.assets[e]=s,this.assetsRefCount[e]=(this.assetsRefCount[e]||0)+1,t&&t(e,s)}error(t,e,s){this.toLoad--,this.loaded++,this.errors[e]=s,t&&t(e,s)}loadAll(){return new Promise((e,s)=>{let n=()=>{if(this.isLoadingComplete()){this.hasErrors()?s(this.errors):e(this);return}requestAnimationFrame(n)};requestAnimationFrame(n)})}setRawDataURI(t,e){this.downloader.rawDataUris[this.pathPrefix+t]=e}loadBinary(t,e=()=>{},s=()=>{}){t=this.start(t),!this.reuseAssets(t,e,s)&&(this.assetsLoaded[t]=new Promise((n,r)=>{this.downloader.downloadBinary(t,l=>{this.success(e,t,l),n(l)},(l,h)=>{const i=`Couldn't load binary ${t}: status ${l}, ${h}`;this.error(s,t,i),r(i)})}))}loadText(t,e=()=>{},s=()=>{}){t=this.start(t),this.downloader.downloadText(t,n=>{this.success(e,t,n)},(n,r)=>{this.error(s,t,`Couldn't load text ${t}: status ${n}, ${r}`)})}loadJson(t,e=()=>{},s=()=>{}){t=this.start(t),!this.reuseAssets(t,e,s)&&(this.assetsLoaded[t]=new Promise((n,r)=>{this.downloader.downloadJson(t,l=>{this.success(e,t,l),n(l)},(l,h)=>{const i=`Couldn't load JSON ${t}: status ${l}, ${h}`;this.error(s,t,i),r(i)})}))}reuseAssets(t,e=()=>{},s=()=>{}){const n=this.assetsLoaded[t],r=n!==void 0;return r&&n.then(l=>this.success(e,t,l)).catch(l=>this.error(s,t,l)),r}loadTexture(t,e=()=>{},s=()=>{}){t=this.start(t),!this.reuseAssets(t,e,s)&&(this.assetsLoaded[t]=new Promise((n,r)=>{if(!!!(typeof window!="undefined"&&typeof navigator!="undefined"&&window.document))fetch(t,{mode:"cors"}).then(i=>{if(i.ok)return i.blob();const a=`Couldn't load image: ${t}`;this.error(s,t,`Couldn't load image: ${t}`),r(a)}).then(i=>i?createImageBitmap(i,{premultiplyAlpha:"none",colorSpaceConversion:"none"}):null).then(i=>{if(i){const a=this.textureLoader(i);this.success(e,t,a),n(a)}});else{let i=new Image;i.crossOrigin="anonymous",i.onload=()=>{const a=this.textureLoader(i);this.success(e,t,a),n(a)},i.onerror=()=>{const a=`Couldn't load image: ${t}`;this.error(s,t,a),r(a)},this.downloader.rawDataUris[t]&&(t=this.downloader.rawDataUris[t]),i.src=t}}))}loadTextureAtlas(t,e=()=>{},s=()=>{},n){let r=t.lastIndexOf("/"),l=r>=0?t.substring(0,r+1):"";t=this.start(t),!this.reuseAssets(t,e,s)&&(this.assetsLoaded[t]=new Promise((h,i)=>{this.downloader.downloadText(t,a=>{try{let o=new Mh(a),d=o.pages.length,u=!1;for(let m of o.pages)this.loadTexture(n?n[m.name]:l+m.name,(c,g)=>{u||(m.setTexture(g),--d==0&&(this.success(e,t,o),h(o)))},(c,g)=>{if(!u){const p=`Couldn't load texture atlas ${t} page image: ${c}`;this.error(s,t,p),i(p)}u=!0})}catch(o){const d=`Couldn't parse texture atlas ${t}: ${o.message}`;this.error(s,t,d),i(d)}},(a,o)=>{const d=`Couldn't load texture atlas ${t}: status ${a}, ${o}`;this.error(s,t,d),i(d)})}))}loadTextureAtlasButNoTextures(t,e=()=>{},s=()=>{},n){t=this.start(t),!this.reuseAssets(t,e,s)&&(this.assetsLoaded[t]=new Promise((r,l)=>{this.downloader.downloadText(t,h=>{try{const i=new Mh(h);this.success(e,t,i),r(i)}catch(i){const a=`Couldn't parse texture atlas ${t}: ${i.message}`;this.error(s,t,a),l(a)}},(h,i)=>{const a=`Couldn't load texture atlas ${t}: status ${h}, ${i}`;this.error(s,t,a),l(a)})}))}async loadBinaryAsync(t){return new Promise((e,s)=>{this.loadBinary(t,(n,r)=>e(r),(n,r)=>s(r))})}async loadJsonAsync(t){return new Promise((e,s)=>{this.loadJson(t,(n,r)=>e(r),(n,r)=>s(r))})}async loadTextureAsync(t){return new Promise((e,s)=>{this.loadTexture(t,(n,r)=>e(r),(n,r)=>s(r))})}async loadTextureAtlasAsync(t){return new Promise((e,s)=>{this.loadTextureAtlas(t,(n,r)=>e(r),(n,r)=>s(r))})}async loadTextureAtlasButNoTexturesAsync(t){return new Promise((e,s)=>{this.loadTextureAtlasButNoTextures(t,(n,r)=>e(r),(n,r)=>s(r))})}get(t){return this.assets[this.pathPrefix+t]}require(t){t=this.pathPrefix+t;let e=this.assets[t];if(e)return e;let s=this.errors[t];throw Error("Asset not found: "+t+(s?`
`+s:""))}remove(t){t=this.pathPrefix+t;let e=this.assets[t];return e.dispose&&e.dispose(),delete this.assets[t],delete this.assetsRefCount[t],delete this.assetsLoaded[t],e}removeAll(){for(let t in this.assets){let e=this.assets[t];e.dispose&&e.dispose()}this.assets={},this.assetsLoaded={},this.assetsRefCount={}}isLoadingComplete(){return this.toLoad==0}getToLoad(){return this.toLoad}getLoaded(){return this.loaded}dispose(){this.removeAll()}disposeAsset(t){--this.assetsRefCount[t]===0&&this.remove(t)}hasErrors(){return Object.keys(this.errors).length>0}getErrors(){return this.errors}}class gp{constructor(){T(this,"callbacks",{});T(this,"rawDataUris",{})}dataUriToString(t){if(!t.startsWith("data:"))throw new Error("Not a data URI.");let e=t.indexOf("base64,");return e!=-1?(e+=7,atob(t.substr(e))):t.substr(t.indexOf(",")+1)}base64ToUint8Array(t){for(var e=window.atob(t),s=e.length,n=new Uint8Array(s),r=0;r<s;r++)n[r]=e.charCodeAt(r);return n}dataUriToUint8Array(t){if(!t.startsWith("data:"))throw new Error("Not a data URI.");let e=t.indexOf("base64,");if(e==-1)throw new Error("Not a binary data URI.");return e+=7,this.base64ToUint8Array(t.substr(e))}downloadText(t,e,s){if(this.start(t,e,s))return;const n=this.rawDataUris[t];if(n&&!n.includes(".")){try{this.finish(t,200,this.dataUriToString(n))}catch(h){this.finish(t,400,JSON.stringify(h))}return}let r=new XMLHttpRequest;r.overrideMimeType("text/html"),r.open("GET",n||t,!0);let l=()=>{this.finish(t,r.status,r.responseText)};r.onload=l,r.onerror=l,r.send()}downloadJson(t,e,s){this.downloadText(t,n=>{e(JSON.parse(n))},s)}downloadBinary(t,e,s){if(this.start(t,e,s))return;const n=this.rawDataUris[t];if(n&&!n.includes(".")){try{this.finish(t,200,this.dataUriToUint8Array(n))}catch(h){this.finish(t,400,JSON.stringify(h))}return}let r=new XMLHttpRequest;r.open("GET",n||t,!0),r.responseType="arraybuffer";let l=()=>{this.finish(t,r.status,r.response)};r.onload=()=>{r.status==200||r.status==0?this.finish(t,200,new Uint8Array(r.response)):l()},r.onerror=l,r.send()}start(t,e,s){let n=this.callbacks[t];try{if(n)return!0;this.callbacks[t]=n=[]}finally{n.push(e,s)}}finish(t,e,s){let n=this.callbacks[t];delete this.callbacks[t];let r=e==200||e==0?[s]:[e,s];for(let l=r.length-1,h=n.length;l<h;l+=2)n[l].apply(null,r)}}var pp=Object.freeze({__proto__:null,AABBRectangleBoundsProvider:xv,AlphaTimeline:Ed,Animation:yh,AnimationState:Ud,AnimationStateAdapter:YC,AnimationStateData:jg,AssetManagerBase:Iv,AtlasAttachmentLoader:Jd,Attachment:md,AttachmentTimeline:Ua,BinaryInput:lp,get BlendMode(){return hi},Bone:tu,BoneData:Qd,BoundingBoxAttachment:Hd,CURRENT:Qg,ClippingAttachment:qa,Color:Yt,ConstraintData:Ml,CurveTimeline:hr,CurveTimeline1:Wn,CurveTimeline2:Sh,DarkSlotMesh:To,DarkTintBatchGeometry:mp,DarkTintGeometry:hp,DarkTintMaterial:cp,DarkTintMesh:dp,DarkTintRenderer:du,DebugUtils:kC,DeformTimeline:Pd,Downloader:gp,DrawOrderTimeline:Co,Event:eu,EventData:su,EventQueue:Zg,EventTimeline:Ch,get EventType(){return tn},FIRST:qd,FakeTexture:FC,HOLD_FIRST:Ah,HOLD_MIX:Jg,HOLD_SUBSEQUENT:zd,IkConstraint:np,IkConstraintData:nu,IkConstraintTimeline:Rd,get Inherit(){return be},InheritTimeline:Ad,IntSet:EC,Interpolation:qg,MathUtils:ot,MeshAttachment:vo,get MixBlend(){return J},get MixDirection(){return Bs},PathAttachment:Ao,PathConstraint:rp,PathConstraintData:jd,PathConstraintMixTimeline:Xd,PathConstraintPositionTimeline:Fd,PathConstraintSpacingTimeline:Bd,get Physics(){return Un},PhysicsConstraintDampingTimeline:Vd,PhysicsConstraintGravityTimeline:Ld,PhysicsConstraintInertiaTimeline:$d,PhysicsConstraintMassTimeline:_d,PhysicsConstraintMixTimeline:Od,PhysicsConstraintResetTimeline:vl,PhysicsConstraintStrengthTimeline:Nd,PhysicsConstraintTimeline:Zi,PhysicsConstraintWindTimeline:Dd,PointAttachment:sp,Pool:So,get PositionMode(){return cr},Pow:zg,PowOut:IC,RGB2Timeline:kd,RGBA2Timeline:Id,RGBATimeline:Md,RGBTimeline:Td,RegionAttachment:Al,get RotateMode(){return Ji},RotateTimeline:Cl,SETUP:Gd,SUBSEQUENT:vh,ScaleTimeline:bd,ScaleXTimeline:wd,ScaleYTimeline:yd,SequenceTimeline:Wd,SetupPoseBoundsProvider:bv,ShearTimeline:Sd,ShearXTimeline:Cd,ShearYTimeline:vd,Skeleton:Mo,SkeletonBinary:ou,SkeletonBounds:fp,SkeletonClipping:za,SkeletonData:Tl,SkeletonJson:hu,Skin:El,SkinEntry:ru,SkinsAndAnimationBoundsProvider:wv,Slot:ip,SlotData:iu,SlotMesh:Th,get SpacingMode(){return He},Spine:yv,SpineDebugRenderer:Sv,SpineTexture:Ga,StringSet:fd,Texture:Kd,TextureAtlas:Mh,TextureAtlasPage:ep,TextureAtlasRegion:Zd,get TextureFilter(){return is},TextureRegion:tp,get TextureWrap(){return Ur},TimeKeeper:PC,Timeline:pe,TrackEntry:Kg,TransformConstraint:ap,TransformConstraintData:au,TransformConstraintTimeline:Yd,TranslateTimeline:gd,TranslateXTimeline:pd,TranslateYTimeline:xd,Triangulator:en,Utils:ht,Vector2:Sl,VertexAttachment:Wr,WindowedMean:RC}),kv=Object.defineProperty,Pv=(f,t,e)=>t in f?kv(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,xp=(f,t,e)=>Pv(f,typeof t!="symbol"?t+"":t,e);let Rv=class{constructor(t,e){xp(this,"jitterX",0),xp(this,"jitterY",0),this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,s,n){t.x+=rt.randomTriangular(-this.jitterX,this.jitterY),t.y+=rt.randomTriangular(-this.jitterX,this.jitterY)}end(){}};var Yv=Object.defineProperty,Fv=(f,t,e)=>t in f?Yv(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ha=(f,t,e)=>Fv(f,typeof t!="symbol"?t+"":t,e);let Bv=class{constructor(){Ha(this,"minX",0),Ha(this,"minY",0),Ha(this,"maxX",0),Ha(this,"maxY",0),Ha(this,"boundingBoxes",new Array),Ha(this,"polygons",new Array),Ha(this,"polygonPool",new Zf(()=>It.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,l=t.slots,h=l.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=l[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===un.BoundingBox){const d=o;s.push(d);let u=r.obtain();u.length!=d.worldVerticesLength&&(u=It.newFloatArray(d.worldVerticesLength)),n.push(u),d.computeWorldVertices(a,0,d.worldVerticesLength,u,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let l=0,h=r.length;l<h;l++){const i=r[l],a=i;for(let o=0,d=i.length;o<d;o+=2){const u=a[o],m=a[o+1];t=Math.min(t,u),e=Math.min(e,m),s=Math.max(s,u),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,l=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=l&&n<=l||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>l&&o<i||(o=a*(h-t)+e,o>l&&o<i))return!0;let d=(l-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let l=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[l+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[l]-d)<e&&(h=!h)}l=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let l=0,h=r.length;l<h;l++)if(this.intersectsSegmentPolygon(r[l],t,e,s,n))return this.boundingBoxes[l];return null}intersectsSegmentPolygon(t,e,s,n,r){const l=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=l[h-2],u=l[h-1];for(let m=0;m<h;m+=2){const c=l[m],g=l[m+1],p=d*g-u*c,y=d-c,w=u-g,x=i*w-a*y,b=(o*y-i*p)/x;if((b>=d&&b<=c||b>=c&&b<=d)&&(b>=e&&b<=n||b>=n&&b<=e)){const S=(o*w-a*p)/x;if((S>=u&&S<=g||S>=g&&S<=u)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=c,u=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}};var Xv=Object.freeze({__proto__:null,Animation:es,AnimationState:cm,AnimationStateAdapter2:xw,AnimationStateData:pm,AtlasAttachmentLoader:Sm,Attachment:qh,AttachmentTimeline:sh,Bone:sc,BoneData:Rm,BoundingBoxAttachment:bm,ClippingAttachment:wm,ColorTimeline:Hh,CurveTimeline:Br,DeformTimeline:om,DrawOrderTimeline:nh,Event:Im,EventData:$m,EventQueue:fm,EventTimeline:lm,EventType:mm,IkConstraint:Am,IkConstraintData:Ym,IkConstraintTimeline:Zh,JitterEffect:Rv,MeshAttachment:ec,PathAttachment:Qo,PathConstraint:vm,PathConstraintData:Cm,PathConstraintMixTimeline:Qh,PathConstraintPositionTimeline:rh,PathConstraintSpacingTimeline:hm,PointAttachment:ym,RegionAttachment:Gh,RotateTimeline:Gn,ScaleTimeline:rm,ShearTimeline:im,Skeleton:Em,SkeletonBounds:class extends Bv{},SkeletonData:km,SkeletonJson:Nm,Skin:Xm,Slot:zh,SlotData:Pm,SpacingMode:Qn,Spine:class extends em{createSkeleton(t){this.skeleton=new Em(t),this.skeleton.updateWorldTransform(),this.stateData=new pm(t),this.state=new cm(this.stateData)}},SwirlEffect:uw,TimelineType:nm,TrackEntry:dm,TransformConstraint:Mm,TransformConstraintData:Fm,TransformConstraintTimeline:Jh,TranslateTimeline:Ko,TwoColorTimeline:Kh,VertexAttachment:Sa}),$v=Object.defineProperty,Nv=(f,t,e)=>t in f?$v(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,bp=(f,t,e)=>Nv(f,typeof t!="symbol"?t+"":t,e);let Vv=class{constructor(t,e){bp(this,"jitterX",0),bp(this,"jitterY",0),this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,s,n){t.x+=nt.randomTriangular(-this.jitterX,this.jitterY),t.y+=nt.randomTriangular(-this.jitterX,this.jitterY)}end(){}};var _v=Object.defineProperty,Dv=(f,t,e)=>t in f?_v(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ka=(f,t,e)=>Dv(f,typeof t!="symbol"?t+"":t,e);let Lv=class{constructor(){Ka(this,"minX",0),Ka(this,"minY",0),Ka(this,"maxX",0),Ka(this,"maxY",0),Ka(this,"boundingBoxes",new Array),Ka(this,"polygons",new Array),Ka(this,"polygonPool",new _m(()=>dt.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,l=t.slots,h=l.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=l[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===Be.BoundingBox){const d=o;s.push(d);let u=r.obtain();u.length!=d.worldVerticesLength&&(u=dt.newFloatArray(d.worldVerticesLength)),n.push(u),d.computeWorldVertices(a,0,d.worldVerticesLength,u,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let l=0,h=r.length;l<h;l++){const i=r[l],a=i;for(let o=0,d=i.length;o<d;o+=2){const u=a[o],m=a[o+1];t=Math.min(t,u),e=Math.min(e,m),s=Math.max(s,u),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,l=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=l&&n<=l||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>l&&o<i||(o=a*(h-t)+e,o>l&&o<i))return!0;let d=(l-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let l=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[l+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[l]-d)<e&&(h=!h)}l=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let l=0,h=r.length;l<h;l++)if(this.intersectsSegmentPolygon(r[l],t,e,s,n))return this.boundingBoxes[l];return null}intersectsSegmentPolygon(t,e,s,n,r){const l=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=l[h-2],u=l[h-1];for(let m=0;m<h;m+=2){const c=l[m],g=l[m+1],p=d*g-u*c,y=d-c,w=u-g,x=i*w-a*y,b=(o*y-i*p)/x;if((b>=d&&b<=c||b>=c&&b<=d)&&(b>=e&&b<=n||b>=n&&b<=e)){const S=(o*w-a*p)/x;if((S>=u&&S<=g||S>=g&&S<=u)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=c,u=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}};var wp=Object.freeze({__proto__:null,Animation:Xe,AnimationState:Km,AnimationStateAdapter:V1,AnimationStateData:eg,AtlasAttachmentLoader:uc,Attachment:nc,AttachmentTimeline:Xa,Bone:mc,BoneData:bc,BoundingBoxAttachment:ng,ClippingAttachment:rg,ColorTimeline:rl,ConstraintData:hh,CurveTimeline:Xr,DeformTimeline:lc,DrawOrderTimeline:po,Event:gc,EventData:Cc,EventQueue:Qm,EventTimeline:ah,EventType:jm,IkConstraint:og,IkConstraintData:wc,IkConstraintTimeline:al,JitterEffect:Vv,MeshAttachment:lh,PathAttachment:dl,PathConstraint:ag,PathConstraintData:fc,PathConstraintMixTimeline:hl,PathConstraintPositionTimeline:xo,PathConstraintSpacingTimeline:hc,PointAttachment:ig,RegionAttachment:ic,RotateTimeline:Pn,ScaleTimeline:ac,ShearTimeline:oc,Skeleton:cg,SkeletonBinary:dg,SkeletonBounds:class extends Lv{},SkeletonData:pc,SkeletonJson:ug,Skin:dh,SkinEntry:Sc,Slot:rc,SlotData:xc,SpacingMode:ds,Spine:class extends Um{createSkeleton(t){this.skeleton=new cg(t),this.skeleton.updateWorldTransform(),this.stateData=new eg(t),this.state=new Km(this.stateData)}},SwirlEffect:F1,TimelineType:Gm,TrackEntry:Zm,TransformConstraint:lg,TransformConstraintData:yc,TransformConstraintTimeline:ol,TranslateTimeline:Ba,TwoColorTimeline:il,VertexAttachment:Ra}),Ov=Object.defineProperty,Wv=(f,t,e)=>t in f?Ov(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ms=(f,t,e)=>Wv(f,typeof t!="symbol"?t+"":t,e);let yp=class{constructor(){ms(this,"entries",{}),ms(this,"size",0)}add(t){const e=this.entries[t];return this.entries[t]=!0,e?!1:(this.size++,!0)}addAll(t){const e=this.size;for(let s=0,n=t.length;s<n;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}};const ur=class Hx{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new Hx().setFromString(t)}};ms(ur,"WHITE",new ur(1,1,1,1)),ms(ur,"RED",new ur(1,0,0,1)),ms(ur,"GREEN",new ur(0,1,0,1)),ms(ur,"BLUE",new ur(0,0,1,1)),ms(ur,"MAGENTA",new ur(1,0,1,1));let Lt=ur;const yn=class Zl{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Zl.degRad)}static sinDeg(t){return Math.sin(t*Zl.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Zl.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Zl.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};ms(yn,"PI",3.1415927),ms(yn,"PI2",yn.PI*2),ms(yn,"invPI2",1/yn.PI2),ms(yn,"radiansToDegrees",180/yn.PI),ms(yn,"radDeg",yn.radiansToDegrees),ms(yn,"degreesToRadians",yn.PI/180),ms(yn,"degRad",yn.degreesToRadians);let j=yn,Uv=class{apply(t,e,s){return t+(e-t)*this.applyInternal(s)}},qv=class extends Uv{constructor(t){super(),ms(this,"power",2),this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}},zv=class extends qv{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}};const Sp=class Do{static arrayCopy(t,e,s,n,r){for(let l=e,h=n;l<e+r;l++,h++)s[h]=t[l]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Do.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Do.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Do.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Do.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Do.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};ms(Sp,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let bt=Sp,Cp=class{constructor(t){ms(this,"items",new Array),ms(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},uu=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};var Ve=(f=>(f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping",f))(Ve||{}),Bn=(f=>(f[f.Normal=0]="Normal",f[f.OnlyTranslation=1]="OnlyTranslation",f[f.NoRotationOrReflection=2]="NoRotationOrReflection",f[f.NoScale=3]="NoScale",f[f.NoScaleOrReflection=4]="NoScaleOrReflection",f))(Bn||{}),vp=(f=>(f[f.none=0]="none",f[f.reset=1]="reset",f[f.update=2]="update",f[f.pose=3]="pose",f))(vp||{}),Gv=Object.defineProperty,Hv=(f,t,e)=>t in f?Gv(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Il=(f,t,e)=>Hv(f,typeof t!="symbol"?t+"":t,e);let Ap=class{constructor(){Il(this,"texture"),Il(this,"size",null),Il(this,"names",null),Il(this,"values",null),Il(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var Mp=(f=>(f[f.UNKNOWN=0]="UNKNOWN",f[f.VER37=37]="VER37",f[f.VER38=38]="VER38",f[f.VER40=40]="VER40",f[f.VER41=41]="VER41",f[f.VER42=42]="VER42",f))(Mp||{});function Kv(f){const t=f.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const Zv={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var Jv=Object.defineProperty,Qv=(f,t,e)=>t in f?Jv(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Xs=(f,t,e)=>Qv(f,typeof t!="symbol"?t+"":t,e);const Qi=[0,0,0];let jv=class extends $i.Sprite{constructor(){super(...arguments),Xs(this,"region",null),Xs(this,"attachment",null)}},tA=class extends Xi.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),Xs(this,"region",null),Xs(this,"attachment",null)}};const Tp=class Kx extends Et.Container{constructor(t){if(super(),Xs(this,"tintRgb"),Xs(this,"spineData"),Xs(this,"skeleton"),Xs(this,"stateData"),Xs(this,"state"),Xs(this,"slotContainers"),Xs(this,"tempClipContainers"),Xs(this,"localDelayLimit"),Xs(this,"_autoUpdate"),Xs(this,"_visible"),Xs(this,"_debug"),Xs(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),l=this.newContainer();if(this.slotContainers.push(l),this.addChild(l),this.tempClipContainers.push(null),!!r)if(r.type===Ve.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,l.addChild(i)}else if(r.type===Ve.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,l.addChild(h)}else r.type===Ve.Clipping&&(this.createGraphics(n,r),l.addChild(n.clippingContainer),l.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?Kx.prototype.autoUpdateTransform:Et.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=V.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:Zv.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=Kv(this.spineData.version||this.spineData.spine.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===Mp.VER42&&vp.update);const n=this.skeleton.slots,r=this.color;let l=null,h=null;r?(l=r.light,h=r.dark):l=this.tintRgb;for(let u=0,m=n.length;u<m;u++){const c=n[u],g=c.getAttachment(),p=this.slotContainers[u];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(c,g);let w=g.region;const x=g.color;switch(g!=null&&g.type){case Ve.Region:if(p.transform.setFromMatrix(c.bone.matrix),w=g.region,c.currentMesh&&(c.currentMesh.visible=!1,c.currentMesh=null,c.currentMeshId=void 0,c.currentMeshName=void 0),!w){c.currentSprite&&(c.currentSprite.renderable=!1);break}if(!c.currentSpriteName||c.currentSpriteName!==g.name){const C=g.name;if(c.currentSprite&&(c.currentSprite.visible=!1),c.sprites=c.sprites||{},c.sprites[C]!==void 0)c.sprites[C].visible=!0;else{const v=this.createSprite(c,g,C);p.addChild(v)}c.currentSprite=c.sprites[C],c.currentSpriteName=C}c.currentSprite.renderable=!0,c.hackRegion||this.setSpriteRegion(g,c.currentSprite,w),c.currentSprite.color?y=c.currentSprite.color:(Qi[0]=l[0]*c.color.r*x.r,Qi[1]=l[1]*c.color.g*x.g,Qi[2]=l[2]*c.color.b*x.b,c.currentSprite.tint=V.utils.rgb2hex(Qi)),c.currentSprite.blendMode=c.blendMode;break;case Ve.Mesh:if(c.currentSprite){c.currentSprite.visible=!1,c.currentSprite=null,c.currentSpriteName=void 0;const C=new V.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){c.currentMesh&&(c.currentMesh.renderable=!1);break}const S=g.id;if(c.currentMeshId===void 0||c.currentMeshId!==S){const C=S;if(c.currentMesh&&(c.currentMesh.visible=!1),c.meshes=c.meshes||{},c.meshes[C]!==void 0)c.meshes[C].visible=!0;else{const v=this.createMesh(c,g);p.addChild(v)}c.currentMesh=c.meshes[C],c.currentMeshName=g.name,c.currentMeshId=C}c.currentMesh.renderable=!0,g.computeWorldVerticesOld(c,c.currentMesh.vertices),c.currentMesh.color?y=c.currentMesh.color:(Qi[0]=l[0]*c.color.r*x.r,Qi[1]=l[1]*c.color.g*x.g,Qi[2]=l[2]*c.color.b*x.b,c.currentMesh.tint=V.utils.rgb2hex(Qi)),c.currentMesh.blendMode=c.blendMode,c.hackRegion||this.setMeshRegion(g,c.currentMesh,w);break;case Ve.Clipping:c.currentGraphics||(this.createGraphics(c,g),p.addChild(c.clippingContainer),p.addChild(c.currentGraphics)),this.updateGraphics(c,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let b=c.color.r*x.r,S=c.color.g*x.g,C=c.color.b*x.b;y.setLight(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C)),c.darkColor?(b=c.darkColor.r,S=c.darkColor.g,C=c.darkColor.b):(b=0,S=0,C=0),y.setDark(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C))}p.alpha=c.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let u=0,m=i.length;u<m;u++){const c=n[i[u].data.index],g=this.slotContainers[i[u].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),c.currentGraphics&&c.getAttachment())o=c.clippingContainer,a=c.getAttachment(),o.children.length=0,this.children[u]=g,a.endSlot===c.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[u];p||(p=this.tempClipContainers[u]=this.newContainer(),p.visible=!1),this.children[u]=p,g.parent=null,o.addChild(g),a.endSlot==c.data&&(o.renderable=!0,o=null,a=null)}else this.children[u]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*j.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Et.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,l=this.newSprite(r);return l.anchor.set(.5),n&&this.setSpriteRegion(e,l,e.region),t.sprites=t.sprites||{},t.sprites[s]=l,l}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),V.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new V.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let l=r.region;return e?(l=new Ap,l.texture=e,l.size=s,n.hackRegion=l,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,l):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,l),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),l=this.skeleton.getAttachmentByName(t,e);l.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=l.region;return s?(a=new Ap,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Et.Container}newSprite(t){return new jv(t)}newGraphics(){return new le.Graphics}newMesh(t,e,s,n,r){return new tA(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let l=0,h=this.skeleton.slots.length;l<h;l++){const i=this.skeleton.slots[l],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};Xs(Tp,"clippingPolygon",[]);let Ep=Tp;Object.defineProperty(Ep.prototype,"visible",{get(){return this._visible},set(f){f!==this._visible&&(this._visible=f,f&&(this.lastTime=0))}});var eA=Object.defineProperty,sA=(f,t,e)=>t in f?eA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ji=(f,t,e)=>sA(f,typeof t!="symbol"?t+"":t,e);let fu=class{constructor(t){if(ji(this,"name"),ji(this,"type"),!t)throw new Error("name cannot be null.");this.name=t}};const Ip=class Zx extends fu{constructor(t){super(t),ji(this,"id",Zx.nextID++),ji(this,"bones"),ji(this,"vertices"),ji(this,"worldVerticesLength",0),ji(this,"deformAttachment",this)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,l){s=r+(s>>1)*l;const h=t.bone.skeleton,i=t.deform;let a=this.vertices;const o=this.bones;if(!o){i.length>0&&(a=i);const c=t.bone.matrix,g=c.tx,p=c.ty,y=c.a,w=c.c,x=c.b,b=c.d;for(let S=e,C=r;C<s;S+=2,C+=l){const v=a[S],A=a[S+1];n[C]=v*y+A*w+g,n[C+1]=v*x+A*b+p}return}let d=0,u=0;for(let c=0;c<e;c+=2){const g=o[d];d+=g+1,u+=g}const m=h.bones;if(i.length==0)for(let c=r,g=u*3;c<s;c+=l){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const x=m[o[d]].matrix,b=a[g],S=a[g+1],C=a[g+2];p+=(b*x.a+S*x.c+x.tx)*C,y+=(b*x.b+S*x.d+x.ty)*C}n[c]=p,n[c+1]=y}else{const c=i;for(let g=r,p=u*3,y=u<<1;g<s;g+=l){let w=0,x=0,b=o[d++];for(b+=d;d<b;d++,p+=3,y+=2){const S=m[o[d]].matrix,C=a[p]+c[y],v=a[p+1]+c[y+1],A=a[p+2];w+=(C*S.a+v*S.c+S.tx)*A,x+=(C*S.b+v*S.d+S.ty)*A}n[g]=w,n[g+1]=x}}}copyTo(t){this.bones?(t.bones=new Array(this.bones.length),bt.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices?(t.vertices=bt.newFloatArray(this.vertices.length),bt.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)):t.vertices=null,t.worldVerticesLength=this.worldVerticesLength,t.deformAttachment=this.deformAttachment}};ji(Ip,"nextID",0);let Za=Ip;var nA=Object.defineProperty,rA=(f,t,e)=>t in f?nA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,kp=(f,t,e)=>rA(f,typeof t!="symbol"?t+"":t,e);let Pp=class Jx extends Za{constructor(t){super(t),kp(this,"type",Ve.BoundingBox),kp(this,"color",new Lt(1,1,1,1))}copy(){const t=new Jx(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}};var iA=Object.defineProperty,aA=(f,t,e)=>t in f?iA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,mu=(f,t,e)=>aA(f,typeof t!="symbol"?t+"":t,e);let Rp=class Qx extends Za{constructor(t){super(t),mu(this,"type",Ve.Clipping),mu(this,"endSlot"),mu(this,"color",new Lt(.2275,.2275,.8078,1))}copy(){const t=new Qx(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}};var oA=Object.defineProperty,lA=(f,t,e)=>t in f?oA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,qn=(f,t,e)=>lA(f,typeof t!="symbol"?t+"":t,e);let Eh=class Xf extends Za{constructor(t){super(t),qn(this,"type",Ve.Mesh),qn(this,"region"),qn(this,"path"),qn(this,"regionUVs"),qn(this,"triangles"),qn(this,"color",new Lt(1,1,1,1)),qn(this,"width"),qn(this,"height"),qn(this,"hullLength"),qn(this,"edges"),qn(this,"parentMesh"),qn(this,"tempColor",new Lt(0,0,0,0))}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new Xf(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),bt.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),bt.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,this.edges&&(t.edges=new Array(this.edges.length),bt.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}newLinkedMesh(){const t=new Xf(this.name);return t.region=this.region,t.path=this.path,t.color.setFromColor(this.color),t.deformAttachment=this.deformAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}};var hA=Object.defineProperty,cA=(f,t,e)=>t in f?hA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,kl=(f,t,e)=>cA(f,typeof t!="symbol"?t+"":t,e);let Pl=class jx extends Za{constructor(t){super(t),kl(this,"type",Ve.Path),kl(this,"lengths"),kl(this,"closed",!1),kl(this,"constantSpeed",!1),kl(this,"color",new Lt(1,1,1,1))}copy(){const t=new jx(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),bt.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}};var dA=Object.defineProperty,uA=(f,t,e)=>t in f?dA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Rl=(f,t,e)=>uA(f,typeof t!="symbol"?t+"":t,e);let Yp=class tb extends Za{constructor(t){super(t),Rl(this,"type",Ve.Point),Rl(this,"x"),Rl(this,"y"),Rl(this,"rotation"),Rl(this,"color",new Lt(.38,.94,0,1))}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=j.cosDeg(this.rotation),n=j.sinDeg(this.rotation),r=s*e.a+n*e.c,l=s*e.b+n*e.d;return Math.atan2(l,r)*j.radDeg}copy(){const t=new tb(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}};var fA=Object.defineProperty,mA=(f,t,e)=>t in f?fA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,di=(f,t,e)=>mA(f,typeof t!="symbol"?t+"":t,e);let gu=class{constructor(t,e){if(di(this,"blendMode"),di(this,"data"),di(this,"bone"),di(this,"color"),di(this,"darkColor"),di(this,"attachment"),di(this,"attachmentTime"),di(this,"attachmentState"),di(this,"deform",new Array),t==null)throw new Error("data cannot be null.");if(e==null)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new Lt,this.darkColor=t.darkColor==null?null:new Lt,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&(this.attachment=t,this.attachmentTime=this.bone.skeleton.time,this.deform.length=0)}setAttachmentTime(t){this.attachmentTime=this.bone.skeleton.time-t}getAttachmentTime(){return this.bone.skeleton.time-this.attachmentTime}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor!=null&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName==null?this.attachment=null:(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName)))}};var gA=Object.defineProperty,pA=(f,t,e)=>t in f?gA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,At=(f,t,e)=>pA(f,typeof t!="symbol"?t+"":t,e);const Nt=class ws extends fu{constructor(t){super(t),At(this,"type",Ve.Region),At(this,"x",0),At(this,"y",0),At(this,"scaleX",1),At(this,"scaleY",1),At(this,"rotation",0),At(this,"width",0),At(this,"height",0),At(this,"color",new Lt(1,1,1,1)),At(this,"path"),At(this,"rendererObject"),At(this,"region"),At(this,"offset",bt.newFloatArray(8)),At(this,"uvs",bt.newFloatArray(8)),At(this,"tempColor",new Lt(1,1,1,1))}updateOffset(){const t=this.width/this.region.originalWidth*this.scaleX,e=this.height/this.region.originalHeight*this.scaleY,s=-this.width/2*this.scaleX+this.region.offsetX*t,n=-this.height/2*this.scaleY+this.region.offsetY*e,r=s+this.region.width*t,l=n+this.region.height*e,h=this.rotation*Math.PI/180,i=Math.cos(h),a=Math.sin(h),o=s*i+this.x,d=s*a,u=n*i+this.y,m=n*a,c=r*i+this.x,g=r*a,p=l*i+this.y,y=l*a,w=this.offset;w[ws.OX1]=o-m,w[ws.OY1]=u+d,w[ws.OX2]=o-y,w[ws.OY2]=p+d,w[ws.OX3]=c-y,w[ws.OY3]=p+g,w[ws.OX4]=c-m,w[ws.OY4]=u+g}setRegion(t){this.region=t;const e=this.uvs;t.degrees==90?(e[2]=t.u,e[3]=t.v2,e[4]=t.u,e[5]=t.v,e[6]=t.u2,e[7]=t.v,e[0]=t.u2,e[1]=t.v2):(e[0]=t.u,e[1]=t.v2,e[2]=t.u,e[3]=t.v,e[4]=t.u2,e[5]=t.v,e[6]=t.u2,e[7]=t.v2)}computeWorldVertices(t,e,s,n){const r=this.offset,l=t instanceof gu?t.bone.matrix:t.matrix,h=l.tx,i=l.ty,a=l.a,o=l.c,d=l.b,u=l.d;let m=0,c=0;m=r[ws.OX1],c=r[ws.OY1],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i,s+=n,m=r[ws.OX2],c=r[ws.OY2],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i,s+=n,m=r[ws.OX3],c=r[ws.OY3],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i,s+=n,m=r[ws.OX4],c=r[ws.OY4],e[s]=m*a+c*o+h,e[s+1]=m*d+c*u+i}copy(){const t=new ws(this.name);return t.region=this.region,t.rendererObject=this.rendererObject,t.path=this.path,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,bt.arrayCopy(this.uvs,0,t.uvs,0,8),bt.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t}};At(Nt,"OX1",0),At(Nt,"OY1",1),At(Nt,"OX2",2),At(Nt,"OY2",3),At(Nt,"OX3",4),At(Nt,"OY3",5),At(Nt,"OX4",6),At(Nt,"OY4",7),At(Nt,"X1",0),At(Nt,"Y1",1),At(Nt,"C1R",2),At(Nt,"C1G",3),At(Nt,"C1B",4),At(Nt,"C1A",5),At(Nt,"U1",6),At(Nt,"V1",7),At(Nt,"X2",8),At(Nt,"Y2",9),At(Nt,"C2R",10),At(Nt,"C2G",11),At(Nt,"C2B",12),At(Nt,"C2A",13),At(Nt,"U2",14),At(Nt,"V2",15),At(Nt,"X3",16),At(Nt,"Y3",17),At(Nt,"C3R",18),At(Nt,"C3G",19),At(Nt,"C3B",20),At(Nt,"C3A",21),At(Nt,"U3",22),At(Nt,"V3",23),At(Nt,"X4",24),At(Nt,"Y4",25),At(Nt,"C4R",26),At(Nt,"C4G",27),At(Nt,"C4B",28),At(Nt,"C4A",29),At(Nt,"U4",30),At(Nt,"V4",31);let pu=Nt;var xA=Object.defineProperty,bA=(f,t,e)=>t in f?xA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Fp=(f,t,e)=>bA(f,typeof t!="symbol"?t+"":t,e);class wA{constructor(t,e){Fp(this,"jitterX",0),Fp(this,"jitterY",0),this.jitterX=t,this.jitterY=e}begin(t){}transform(t,e,s,n){t.x+=j.randomTriangular(-this.jitterX,this.jitterY),t.y+=j.randomTriangular(-this.jitterX,this.jitterY)}end(){}}var yA=Object.defineProperty,SA=(f,t,e)=>t in f?yA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ja=(f,t,e)=>SA(f,typeof t!="symbol"?t+"":t,e);const Bp=class eb{constructor(t){Ja(this,"centerX",0),Ja(this,"centerY",0),Ja(this,"radius",0),Ja(this,"angle",0),Ja(this,"worldX",0),Ja(this,"worldY",0),this.radius=t}begin(t){this.worldX=t.x+this.centerX,this.worldY=t.y+this.centerY}transform(t,e,s,n){const r=this.angle*j.degreesToRadians,l=t.x-this.worldX,h=t.y-this.worldY,i=Math.sqrt(l*l+h*h);if(i<this.radius){const a=eb.interpolation.apply(0,r,(this.radius-i)/this.radius),o=Math.cos(a),d=Math.sin(a);t.x=o*l-d*h+this.worldX,t.y=d*l+o*h+this.worldY}}end(){}};Ja(Bp,"interpolation",new zv(2));let CA=Bp;var K=(f=>(f[f.setup=0]="setup",f[f.first=1]="first",f[f.replace=2]="replace",f[f.add=3]="add",f))(K||{}),Sn=(f=>(f[f.mixIn=0]="mixIn",f[f.mixOut=1]="mixOut",f))(Sn||{}),vA=Object.defineProperty,AA=(f,t,e)=>t in f?vA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,qt=(f,t,e)=>AA(f,typeof t!="symbol"?t+"":t,e);let Ih=class{constructor(t,e,s){if(qt(this,"name"),qt(this,"timelines",null),qt(this,"timelineIds",null),qt(this,"duration"),!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(e),this.duration=s}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds=new yp;for(let e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,s,n,r,l,h,i){if(!t)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,l,h,i)}};const he={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18};let Ke=class{constructor(t,e){qt(this,"propertyIds",null),qt(this,"frames",null),this.propertyIds=e,this.frames=bt.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){const s=t.length;for(let n=1;n<s;n++)if(t[n]>e)return n-1;return s-1}static search(t,e,s){const n=t.length;for(let r=s;r<n;r+=s)if(t[r]>e)return r-s;return n-s}},fr=class extends Ke{constructor(t,e,s){super(t,s),qt(this,"curves",null),this.curves=bt.newFloatArray(t+e*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const e=this.getFrameCount()+t*18;if(this.curves.length>e){const s=bt.newFloatArray(e);bt.arrayCopy(this.curves,0,s,0,e),this.curves=s}}setBezier(t,e,s,n,r,l,h,i,a,o,d){const u=this.curves;let m=this.getFrameCount()+t*18;s==0&&(u[e]=2+m);const c=(n-l*2+i)*.03,g=(r-h*2+a)*.03,p=((l-i)*3-n+o)*.006,y=((h-a)*3-r+d)*.006;let w=c*2+p,x=g*2+y,b=(l-n)*.3+c+p*.16666667,S=(h-r)*.3+g+y*.16666667,C=n+b,v=r+S;for(let A=m+18;m<A;m+=2)u[m]=C,u[m+1]=v,b+=w,S+=x,w+=p,x+=y,C+=b,v+=S}getBezierValue(t,e,s,n){const r=this.curves;if(r[n]>t){const a=this.frames[e],o=this.frames[e+s];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}const l=n+18;for(n+=2;n<l;n+=2)if(r[n]>=t){const a=r[n-2],o=r[n-1];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}e+=this.getFrameEntries();const h=r[l-2],i=r[l-1];return i+(t-h)/(this.frames[e]-h)*(this.frames[e+s]-i)}},mr=class extends fr{constructor(t,e,s){super(t,e,[s])}getFrameEntries(){return 2}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+1]=s}getCurveValue(t){const e=this.frames;let s=e.length-2;for(let r=2;r<=s;r+=2)if(e[r]>t){s=r-2;break}const n=this.curves[s>>1];switch(n){case 0:const r=e[s],l=e[s+1];return l+(t-r)/(e[s+2]-r)*(e[s+2+1]-l);case 1:return e[s+1]}return this.getBezierValue(t,s,1,n-2)}},kh=class extends fr{constructor(t,e,s,n){super(t,e,[s,n])}getFrameEntries(){return 3}setFrame(t,e,s,n){t*=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n}},Yl=class extends mr{constructor(t,e,s){super(t,e,`${he.rotate}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.rotation=i.data.rotation;return;case K.first:i.rotation+=(i.data.rotation-i.rotation)*r}return}let o=this.getCurveValue(s);switch(l){case K.setup:i.rotation=i.data.rotation+o*r;break;case K.first:case K.replace:o+=i.data.rotation-i.rotation;case K.add:i.rotation+=o*r}}},xu=class extends kh{constructor(t,e,s){super(t,e,`${he.x}|${s}`,`${he.y}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.x=i.data.x,i.y=i.data.y;return;case K.first:i.x+=(i.data.x-i.x)*r,i.y+=(i.data.y-i.y)*r}return}let o=0,d=0;const u=Ke.search(a,s,3),m=this.curves[u/3];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+3]-c);o+=(a[u+3+1]-o)*g,d+=(a[u+3+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}switch(l){case K.setup:i.x=i.data.x+o*r,i.y=i.data.y+d*r;break;case K.first:case K.replace:i.x+=(i.data.x+o-i.x)*r,i.y+=(i.data.y+d-i.y)*r;break;case K.add:i.x+=o*r,i.y+=d*r}}},bu=class extends mr{constructor(t,e,s){super(t,e,`${he.x}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.x=i.data.x;return;case K.first:i.x+=(i.data.x-i.x)*r}return}const o=this.getCurveValue(s);switch(l){case K.setup:i.x=i.data.x+o*r;break;case K.first:case K.replace:i.x+=(i.data.x+o-i.x)*r;break;case K.add:i.x+=o*r}}},wu=class extends mr{constructor(t,e,s){super(t,e,`${he.y}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.y=i.data.y;return;case K.first:i.y+=(i.data.y-i.y)*r}return}const o=this.getCurveValue(s);switch(l){case K.setup:i.y=i.data.y+o*r;break;case K.first:case K.replace:i.y+=(i.data.y+o-i.y)*r;break;case K.add:i.y+=o*r}}},yu=class extends kh{constructor(t,e,s){super(t,e,`${he.scaleX}|${s}`,`${he.scaleY}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case K.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r,i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}let o,d;const u=Ke.search(a,s,3),m=this.curves[u/3];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+3]-c);o+=(a[u+3+1]-o)*g,d+=(a[u+3+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}if(o*=i.data.scaleX,d*=i.data.scaleY,r==1)l==K.add?(i.scaleX+=o-i.data.scaleX,i.scaleY+=d-i.data.scaleY):(i.scaleX=o,i.scaleY=d);else{let c=0,g=0;if(h==Sn.mixOut)switch(l){case K.setup:c=i.data.scaleX,g=i.data.scaleY,i.scaleX=c+(Math.abs(o)*j.signum(c)-c)*r,i.scaleY=g+(Math.abs(d)*j.signum(g)-g)*r;break;case K.first:case K.replace:c=i.scaleX,g=i.scaleY,i.scaleX=c+(Math.abs(o)*j.signum(c)-c)*r,i.scaleY=g+(Math.abs(d)*j.signum(g)-g)*r;break;case K.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}else switch(l){case K.setup:c=Math.abs(i.data.scaleX)*j.signum(o),g=Math.abs(i.data.scaleY)*j.signum(d),i.scaleX=c+(o-c)*r,i.scaleY=g+(d-g)*r;break;case K.first:case K.replace:c=Math.abs(i.scaleX)*j.signum(o),g=Math.abs(i.scaleY)*j.signum(d),i.scaleX=c+(o-c)*r,i.scaleY=g+(d-g)*r;break;case K.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}}}},Su=class extends mr{constructor(t,e,s){super(t,e,`${he.scaleX}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.scaleX=i.data.scaleX;return;case K.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r}return}const o=this.getCurveValue(s)*i.data.scaleX;if(r==1)l==K.add?i.scaleX+=o-i.data.scaleX:i.scaleX=o;else{let d=0;if(h==Sn.mixOut)switch(l){case K.setup:d=i.data.scaleX,i.scaleX=d+(Math.abs(o)*j.signum(d)-d)*r;break;case K.first:case K.replace:d=i.scaleX,i.scaleX=d+(Math.abs(o)*j.signum(d)-d)*r;break;case K.add:i.scaleX+=(o-i.data.scaleX)*r}else switch(l){case K.setup:d=Math.abs(i.data.scaleX)*j.signum(o),i.scaleX=d+(o-d)*r;break;case K.first:case K.replace:d=Math.abs(i.scaleX)*j.signum(o),i.scaleX=d+(o-d)*r;break;case K.add:i.scaleX+=(o-i.data.scaleX)*r}}}},Cu=class extends mr{constructor(t,e,s){super(t,e,`${he.scaleY}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.scaleY=i.data.scaleY;return;case K.first:i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}const o=this.getCurveValue(s)*i.data.scaleY;if(r==1)l==K.add?i.scaleY+=o-i.data.scaleY:i.scaleY=o;else{let d=0;if(h==Sn.mixOut)switch(l){case K.setup:d=i.data.scaleY,i.scaleY=d+(Math.abs(o)*j.signum(d)-d)*r;break;case K.first:case K.replace:d=i.scaleY,i.scaleY=d+(Math.abs(o)*j.signum(d)-d)*r;break;case K.add:i.scaleY+=(o-i.data.scaleY)*r}else switch(l){case K.setup:d=Math.abs(i.data.scaleY)*j.signum(o),i.scaleY=d+(o-d)*r;break;case K.first:case K.replace:d=Math.abs(i.scaleY)*j.signum(o),i.scaleY=d+(o-d)*r;break;case K.add:i.scaleY+=(o-i.data.scaleY)*r}}}},vu=class extends kh{constructor(t,e,s){super(t,e,`${he.shearX}|${s}`,`${he.shearY}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case K.first:i.shearX+=(i.data.shearX-i.shearX)*r,i.shearY+=(i.data.shearY-i.shearY)*r}return}let o=0,d=0;const u=Ke.search(a,s,3),m=this.curves[u/3];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+3]-c);o+=(a[u+3+1]-o)*g,d+=(a[u+3+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}switch(l){case K.setup:i.shearX=i.data.shearX+o*r,i.shearY=i.data.shearY+d*r;break;case K.first:case K.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r,i.shearY+=(i.data.shearY+d-i.shearY)*r;break;case K.add:i.shearX+=o*r,i.shearY+=d*r}}},Au=class extends mr{constructor(t,e,s){super(t,e,`${he.shearX}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.shearX=i.data.shearX;return;case K.first:i.shearX+=(i.data.shearX-i.shearX)*r}return}const o=this.getCurveValue(s);switch(l){case K.setup:i.shearX=i.data.shearX+o*r;break;case K.first:case K.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r;break;case K.add:i.shearX+=o*r}}},Mu=class extends mr{constructor(t,e,s){super(t,e,`${he.shearY}|${s}`),qt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.shearY=i.data.shearY;return;case K.first:i.shearY+=(i.data.shearY-i.shearY)*r}return}const o=this.getCurveValue(s);switch(l){case K.setup:i.shearY=i.data.shearY+o*r;break;case K.first:case K.replace:i.shearY+=(i.data.shearY+o-i.shearY)*r;break;case K.add:i.shearY+=o*r}}},Tu=class extends fr{constructor(t,e,s){super(t,e,[`${he.rgb}|${s}`,`${he.alpha}|${s}`]),qt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 5}setFrame(t,e,s,n,r,l){t*=5,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const y=i.data.color;switch(l){case K.setup:o.setFromColor(y);return;case K.first:o.add((y.r-o.r)*r,(y.g-o.g)*r,(y.b-o.b)*r,(y.a-o.a)*r)}return}let d=0,u=0,m=0,c=0;const g=Ke.search(a,s,5),p=this.curves[g/5];switch(p){case 0:const y=a[g];d=a[g+1],u=a[g+2],m=a[g+3],c=a[g+4];const w=(s-y)/(a[g+5]-y);d+=(a[g+5+1]-d)*w,u+=(a[g+5+2]-u)*w,m+=(a[g+5+3]-m)*w,c+=(a[g+5+4]-c)*w;break;case 1:d=a[g+1],u=a[g+2],m=a[g+3],c=a[g+4];break;default:d=this.getBezierValue(s,g,1,p-2),u=this.getBezierValue(s,g,2,p+18-2),m=this.getBezierValue(s,g,3,p+18*2-2),c=this.getBezierValue(s,g,4,p+18*3-2)}r==1?o.set(d,u,m,c):(l==K.setup&&o.setFromColor(i.data.color),o.add((d-o.r)*r,(u-o.g)*r,(m-o.b)*r,(c-o.a)*r))}},Eu=class extends fr{constructor(t,e,s){super(t,e,[`${he.rgb}|${s}`]),qt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){t<<=2,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const p=i.data.color;switch(l){case K.setup:o.r=p.r,o.g=p.g,o.b=p.b;return;case K.first:o.r+=(p.r-o.r)*r,o.g+=(p.g-o.g)*r,o.b+=(p.b-o.b)*r}return}let d=0,u=0,m=0;const c=Ke.search(a,s,4),g=this.curves[c>>2];switch(g){case 0:const p=a[c];d=a[c+1],u=a[c+2],m=a[c+3];const y=(s-p)/(a[c+4]-p);d+=(a[c+4+1]-d)*y,u+=(a[c+4+2]-u)*y,m+=(a[c+4+3]-m)*y;break;case 1:d=a[c+1],u=a[c+2],m=a[c+3];break;default:d=this.getBezierValue(s,c,1,g-2),u=this.getBezierValue(s,c,2,g+18-2),m=this.getBezierValue(s,c,3,g+18*2-2)}if(r==1)o.r=d,o.g=u,o.b=m;else{if(l==K.setup){const p=i.data.color;o.r=p.r,o.g=p.g,o.b=p.b}o.r+=(d-o.r)*r,o.g+=(u-o.g)*r,o.b+=(m-o.b)*r}}},Iu=class extends mr{constructor(t,e,s){super(t,e,`${he.alpha}|${s}`),qt(this,"slotIndex",0),this.slotIndex=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.color;if(s<this.frames[0]){const d=i.data.color;switch(l){case K.setup:a.a=d.a;return;case K.first:a.a+=(d.a-a.a)*r}return}const o=this.getCurveValue(s);r==1?a.a=o:(l==K.setup&&(a.a=i.data.color.a),a.a+=(o-a.a)*r)}},ku=class extends fr{constructor(t,e,s){super(t,e,[`${he.rgb}|${s}`,`${he.alpha}|${s}`,`${he.rgb2}|${s}`]),qt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 8}setFrame(t,e,s,n,r,l,h,i,a){t<<=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l,this.frames[t+5]=h,this.frames[t+6]=i,this.frames[t+7]=a}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const S=i.data.color,C=i.data.darkColor;switch(l){case K.setup:o.setFromColor(S),d.r=C.r,d.g=C.g,d.b=C.b;return;case K.first:o.add((S.r-o.r)*r,(S.g-o.g)*r,(S.b-o.b)*r,(S.a-o.a)*r),d.r+=(C.r-d.r)*r,d.g+=(C.g-d.g)*r,d.b+=(C.b-d.b)*r}return}let u=0,m=0,c=0,g=0,p=0,y=0,w=0;const x=Ke.search(a,s,8),b=this.curves[x>>3];switch(b){case 0:const S=a[x];u=a[x+1],m=a[x+2],c=a[x+3],g=a[x+4],p=a[x+5],y=a[x+6],w=a[x+7];const C=(s-S)/(a[x+8]-S);u+=(a[x+8+1]-u)*C,m+=(a[x+8+2]-m)*C,c+=(a[x+8+3]-c)*C,g+=(a[x+8+4]-g)*C,p+=(a[x+8+5]-p)*C,y+=(a[x+8+6]-y)*C,w+=(a[x+8+7]-w)*C;break;case 1:u=a[x+1],m=a[x+2],c=a[x+3],g=a[x+4],p=a[x+5],y=a[x+6],w=a[x+7];break;default:u=this.getBezierValue(s,x,1,b-2),m=this.getBezierValue(s,x,2,b+18-2),c=this.getBezierValue(s,x,3,b+18*2-2),g=this.getBezierValue(s,x,4,b+18*3-2),p=this.getBezierValue(s,x,5,b+18*4-2),y=this.getBezierValue(s,x,6,b+18*5-2),w=this.getBezierValue(s,x,7,b+18*6-2)}if(r==1)o.set(u,m,c,g),d.r=p,d.g=y,d.b=w;else{if(l==K.setup){o.setFromColor(i.data.color);const S=i.data.darkColor;d.r=S.r,d.g=S.g,d.b=S.b}o.add((u-o.r)*r,(m-o.g)*r,(c-o.b)*r,(g-o.a)*r),d.r+=(p-d.r)*r,d.g+=(y-d.g)*r,d.b+=(w-d.b)*r}}},Pu=class extends fr{constructor(t,e,s){super(t,e,[`${he.rgb}|${s}`,`${he.rgb2}|${s}`]),qt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,l,h,i){t*=7,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l,this.frames[t+5]=h,this.frames[t+6]=i}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const b=i.data.color,S=i.data.darkColor;switch(l){case K.setup:o.r=b.r,o.g=b.g,o.b=b.b,d.r=S.r,d.g=S.g,d.b=S.b;return;case K.first:o.r+=(b.r-o.r)*r,o.g+=(b.g-o.g)*r,o.b+=(b.b-o.b)*r,d.r+=(S.r-d.r)*r,d.g+=(S.g-d.g)*r,d.b+=(S.b-d.b)*r}return}let u=0,m=0,c=0,g=0,p=0,y=0;const w=Ke.search(a,s,7),x=this.curves[w/7];switch(x){case 0:const b=a[w];u=a[w+1],m=a[w+2],c=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];const S=(s-b)/(a[w+7]-b);u+=(a[w+7+1]-u)*S,m+=(a[w+7+2]-m)*S,c+=(a[w+7+3]-c)*S,g+=(a[w+7+4]-g)*S,p+=(a[w+7+5]-p)*S,y+=(a[w+7+6]-y)*S;break;case 1:u=a[w+1],m=a[w+2],c=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];break;default:u=this.getBezierValue(s,w,1,x-2),m=this.getBezierValue(s,w,2,x+18-2),c=this.getBezierValue(s,w,3,x+18*2-2),g=this.getBezierValue(s,w,4,x+18*3-2),p=this.getBezierValue(s,w,5,x+18*4-2),y=this.getBezierValue(s,w,6,x+18*5-2)}if(r==1)o.r=u,o.g=m,o.b=c,d.r=g,d.g=p,d.b=y;else{if(l==K.setup){const b=i.data.color,S=i.data.darkColor;o.r=b.r,o.g=b.g,o.b=b.b,d.r=S.r,d.g=S.g,d.b=S.b}o.r+=(u-o.r)*r,o.g+=(m-o.g)*r,o.b+=(c-o.b)*r,d.r+=(g-d.r)*r,d.g+=(p-d.g)*r,d.b+=(y-d.b)*r}}},Qa=class extends Ke{constructor(t,e){super(t,[`${he.attachment}|${e}`]),qt(this,"slotIndex",0),qt(this,"attachmentNames"),this.slotIndex=e,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(i.bone.active){if(h==Sn.mixOut){l==K.setup&&this.setAttachment(t,i,i.data.attachmentName);return}if(s<this.frames[0]){(l==K.setup||l==K.first)&&this.setAttachment(t,i,i.data.attachmentName);return}this.setAttachment(t,i,this.attachmentNames[Ke.search1(this.frames,s)])}}setAttachment(t,e,s){e.setAttachment(s?t.getAttachment(this.slotIndex,s):null)}},Ru=class extends fr{constructor(t,e,s,n){super(t,e,[`${he.deform}|${s}|${n.id}`]),qt(this,"slotIndex",0),qt(this,"attachment",null),qt(this,"vertices",null),this.slotIndex=s,this.attachment=n,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.vertices[t]=s}setBezier(t,e,s,n,r,l,h,i,a,o,d){const u=this.curves;let m=this.getFrameCount()+t*18;s==0&&(u[e]=2+m);const c=(n-l*2+i)*.03,g=a*.03-h*.06,p=((l-i)*3-n+o)*.006,y=(h-a+.33333333)*.018;let w=c*2+p,x=g*2+y,b=(l-n)*.3+c+p*.16666667,S=h*.3+g+y*.16666667,C=n+b,v=S;for(let A=m+18;m<A;m+=2)u[m]=C,u[m+1]=v,b+=w,S+=x,w+=p,x+=y,C+=b,v+=S}getCurvePercent(t,e){const s=this.curves;let n=s[e];switch(n){case 0:const i=this.frames[e];return(t-i)/(this.frames[e+this.getFrameEntries()]-i);case 1:return 0}if(n-=2,s[n]>t){const i=this.frames[e];return s[n+1]*(t-i)/(s[n]-i)}const r=n+18;for(n+=2;n<r;n+=2)if(s[n]>=t){const i=s[n-2],a=s[n-1];return a+(t-i)/(s[n]-i)*(s[n+1]-a)}const l=s[r-2],h=s[r-1];return h+(1-h)*(t-l)/(this.frames[e+this.getFrameEntries()]-l)}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.getAttachment();if(!(a instanceof Za)||a.deformAttachment!=this.attachment)return;const o=i.deform;o.length==0&&(l=K.setup);const d=this.vertices,u=d[0].length,m=this.frames;if(s<m[0]){const w=a;switch(l){case K.setup:o.length=0;return;case K.first:if(r==1){o.length=0;return}if(o.length=u,w.bones){r=1-r;for(let x=0;x<u;x++)o[x]*=r}else{const x=w.vertices;for(let b=0;b<u;b++)o[b]+=(x[b]-o[b])*r}}return}if(o.length=u,s>=m[m.length-1]){const w=d[m.length-1];if(r==1)if(l==K.add){const x=a;if(x.bones)for(let b=0;b<u;b++)o[b]+=w[b];else{const b=x.vertices;for(let S=0;S<u;S++)o[S]+=w[S]-b[S]}}else bt.arrayCopy(w,0,o,0,u);else switch(l){case K.setup:{const b=a;if(b.bones)for(let S=0;S<u;S++)o[S]=w[S]*r;else{const S=b.vertices;for(let C=0;C<u;C++){const v=S[C];o[C]=v+(w[C]-v)*r}}break}case K.first:case K.replace:for(let b=0;b<u;b++)o[b]+=(w[b]-o[b])*r;break;case K.add:const x=a;if(x.bones)for(let b=0;b<u;b++)o[b]+=w[b]*r;else{const b=x.vertices;for(let S=0;S<u;S++)o[S]+=(w[S]-b[S])*r}}return}const c=Ke.search1(m,s),g=this.getCurvePercent(s,c),p=d[c],y=d[c+1];if(r==1)if(l==K.add){const w=a;if(w.bones)for(let x=0;x<u;x++){const b=p[x];o[x]+=b+(y[x]-b)*g}else{const x=w.vertices;for(let b=0;b<u;b++){const S=p[b];o[b]+=S+(y[b]-S)*g-x[b]}}}else for(let w=0;w<u;w++){const x=p[w];o[w]=x+(y[w]-x)*g}else switch(l){case K.setup:{const x=a;if(x.bones)for(let b=0;b<u;b++){const S=p[b];o[b]=(S+(y[b]-S)*g)*r}else{const b=x.vertices;for(let S=0;S<u;S++){const C=p[S],v=b[S];o[S]=v+(C+(y[S]-C)*g-v)*r}}break}case K.first:case K.replace:for(let x=0;x<u;x++){const b=p[x];o[x]+=(b+(y[x]-b)*g-o[x])*r}break;case K.add:const w=a;if(w.bones)for(let x=0;x<u;x++){const b=p[x];o[x]+=(b+(y[x]-b)*g)*r}else{const x=w.vertices;for(let b=0;b<u;b++){const S=p[b];o[b]+=(S+(y[b]-S)*g-x[b])*r}}}}};const Xp=class sb extends Ke{constructor(t){super(t,sb.propertyIds),qt(this,"events",null),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,l,h){if(!n)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,l,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=Ke.search1(i,e)+1;const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}};qt(Xp,"propertyIds",[`${he.event}`]);let Ph=Xp;const $p=class nb extends Ke{constructor(t){super(t,nb.propertyIds),qt(this,"drawOrders",null),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,l,h){if(h==Sn.mixOut){l==K.setup&&bt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(s<this.frames[0]){(l==K.setup||l==K.first)&&bt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const i=this.drawOrders[Ke.search1(this.frames,s)];if(!i)bt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const a=t.drawOrder,o=t.slots;for(let d=0,u=i.length;d<u;d++)a[d]=o[i[d]]}}};qt($p,"propertyIds",[`${he.drawOrder}`]);let Eo=$p,Yu=class extends fr{constructor(t,e,s){super(t,e,[`${he.ikConstraint}|${s}`]),qt(this,"ikConstraintIndex",0),this.ikConstraintIndex=s}getFrameEntries(){return 6}setFrame(t,e,s,n,r,l,h){t*=6,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l?1:0,this.frames[t+5]=h?1:0}apply(t,e,s,n,r,l,h){const i=t.ikConstraints[this.ikConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.mix=i.data.mix,i.softness=i.data.softness,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch;return;case K.first:i.mix+=(i.data.mix-i.mix)*r,i.softness+=(i.data.softness-i.softness)*r,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch}return}let o=0,d=0;const u=Ke.search(a,s,6),m=this.curves[u/6];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+6]-c);o+=(a[u+6+1]-o)*g,d+=(a[u+6+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}l==K.setup?(i.mix=i.data.mix+(o-i.data.mix)*r,i.softness=i.data.softness+(d-i.data.softness)*r,h==Sn.mixOut?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=a[u+3],i.compress=a[u+4]!=0,i.stretch=a[u+5]!=0)):(i.mix+=(o-i.mix)*r,i.softness+=(d-i.softness)*r,h==Sn.mixIn&&(i.bendDirection=a[u+3],i.compress=a[u+4]!=0,i.stretch=a[u+5]!=0))}},Fu=class extends fr{constructor(t,e,s){super(t,e,[`${he.transformConstraint}|${s}`]),qt(this,"transformConstraintIndex",0),this.transformConstraintIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,l,h,i){const a=this.frames;t*=7,a[t]=e,a[t+1]=s,a[t+2]=n,a[t+3]=r,a[t+4]=l,a[t+5]=h,a[t+6]=i}apply(t,e,s,n,r,l,h){const i=t.transformConstraints[this.transformConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){const w=i.data;switch(l){case K.setup:i.mixRotate=w.mixRotate,i.mixX=w.mixX,i.mixY=w.mixY,i.mixScaleX=w.mixScaleX,i.mixScaleY=w.mixScaleY,i.mixShearY=w.mixShearY;return;case K.first:i.mixRotate+=(w.mixRotate-i.mixRotate)*r,i.mixX+=(w.mixX-i.mixX)*r,i.mixY+=(w.mixY-i.mixY)*r,i.mixScaleX+=(w.mixScaleX-i.mixScaleX)*r,i.mixScaleY+=(w.mixScaleY-i.mixScaleY)*r,i.mixShearY+=(w.mixShearY-i.mixShearY)*r}return}let o,d,u,m,c,g;const p=Ke.search(a,s,7),y=this.curves[p/7];switch(y){case 0:const w=a[p];o=a[p+1],d=a[p+2],u=a[p+3],m=a[p+4],c=a[p+5],g=a[p+6];const x=(s-w)/(a[p+7]-w);o+=(a[p+7+1]-o)*x,d+=(a[p+7+2]-d)*x,u+=(a[p+7+3]-u)*x,m+=(a[p+7+4]-m)*x,c+=(a[p+7+5]-c)*x,g+=(a[p+7+6]-g)*x;break;case 1:o=a[p+1],d=a[p+2],u=a[p+3],m=a[p+4],c=a[p+5],g=a[p+6];break;default:o=this.getBezierValue(s,p,1,y-2),d=this.getBezierValue(s,p,2,y+18-2),u=this.getBezierValue(s,p,3,y+18*2-2),m=this.getBezierValue(s,p,4,y+18*3-2),c=this.getBezierValue(s,p,5,y+18*4-2),g=this.getBezierValue(s,p,6,y+18*5-2)}if(l==K.setup){const w=i.data;i.mixRotate=w.mixRotate+(o-w.mixRotate)*r,i.mixX=w.mixX+(d-w.mixX)*r,i.mixY=w.mixY+(u-w.mixY)*r,i.mixScaleX=w.mixScaleX+(m-w.mixScaleX)*r,i.mixScaleY=w.mixScaleY+(c-w.mixScaleY)*r,i.mixShearY=w.mixShearY+(g-w.mixShearY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(u-i.mixY)*r,i.mixScaleX+=(m-i.mixScaleX)*r,i.mixScaleY+=(c-i.mixScaleY)*r,i.mixShearY+=(g-i.mixShearY)*r}},Bu=class extends mr{constructor(t,e,s){super(t,e,`${he.pathConstraintPosition}|${s}`),qt(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,l,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.position=i.data.position;return;case K.first:i.position+=(i.data.position-i.position)*r}return}const o=this.getCurveValue(s);l==K.setup?i.position=i.data.position+(o-i.data.position)*r:i.position+=(o-i.position)*r}},Xu=class extends mr{constructor(t,e,s){super(t,e,`${he.pathConstraintSpacing}|${s}`),qt(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,l,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.spacing=i.data.spacing;return;case K.first:i.spacing+=(i.data.spacing-i.spacing)*r}return}const o=this.getCurveValue(s);l==K.setup?i.spacing=i.data.spacing+(o-i.data.spacing)*r:i.spacing+=(o-i.spacing)*r}},$u=class extends fr{constructor(t,e,s){super(t,e,[`${he.pathConstraintMix}|${s}`]),qt(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){const l=this.frames;t<<=2,l[t]=e,l[t+1]=s,l[t+2]=n,l[t+3]=r}apply(t,e,s,n,r,l,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case K.setup:i.mixRotate=i.data.mixRotate,i.mixX=i.data.mixX,i.mixY=i.data.mixY;return;case K.first:i.mixRotate+=(i.data.mixRotate-i.mixRotate)*r,i.mixX+=(i.data.mixX-i.mixX)*r,i.mixY+=(i.data.mixY-i.mixY)*r}return}let o,d,u;const m=Ke.search(a,s,4),c=this.curves[m>>2];switch(c){case 0:const g=a[m];o=a[m+1],d=a[m+2],u=a[m+3];const p=(s-g)/(a[m+4]-g);o+=(a[m+4+1]-o)*p,d+=(a[m+4+2]-d)*p,u+=(a[m+4+3]-u)*p;break;case 1:o=a[m+1],d=a[m+2],u=a[m+3];break;default:o=this.getBezierValue(s,m,1,c-2),d=this.getBezierValue(s,m,2,c+18-2),u=this.getBezierValue(s,m,3,c+18*2-2)}if(l==K.setup){const g=i.data;i.mixRotate=g.mixRotate+(o-g.mixRotate)*r,i.mixX=g.mixX+(d-g.mixX)*r,i.mixY=g.mixY+(u-g.mixY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(u-i.mixY)*r}};var MA=Object.defineProperty,TA=(f,t,e)=>t in f?MA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,yt=(f,t,e)=>TA(f,typeof t!="symbol"?t+"":t,e);const Rh=class Pi{constructor(t){yt(this,"data",null),yt(this,"tracks",new Array),yt(this,"timeScale",1),yt(this,"unkeyedState",0),yt(this,"events",new Array),yt(this,"listeners",new Array),yt(this,"queue",new _p(this)),yt(this,"propertyIDs",new yp),yt(this,"animationsChanged",!1),yt(this,"trackEntryPool",new Cp(()=>new Vp)),yt(this,"onComplete"),yt(this,"onEvent"),yt(this,"onStart"),yt(this,"onEnd"),this.data=t}static emptyAnimation(){return Du||(Du=new Ih("<empty>",[],0)),Du}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let l=t*r.timeScale;if(r.delay>0){if(r.delay-=l,r.delay>0)continue;l=-r.delay,r.delay=0}let h=r.next;if(h){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=l,this.setCurrent(s,h,!0);h.mixingFrom;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){e[s]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i&&(i.mixingTo=null);i;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=l}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(!s)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let h=0,i=s.length;h<i;h++){const a=s[h];if(!a||a.delay>0)continue;n=!0;const o=h==0?K.first:a.mixBlend;let d=a.alpha;a.mixingFrom?d*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&!a.next&&(d=0);const u=a.animationLast,m=a.getAnimationTime();let c=m,g=e;a.reverse&&(c=a.animation.duration-c,g=null);const p=a.animation.timelines,y=p.length;if(h==0&&d==1||o==K.add)for(let w=0;w<y;w++){bt.webkit602BugfixHelper(d,o);const x=p[w];x instanceof Qa?this.applyAttachmentTimeline(x,t,c,o,!0):x.apply(t,u,c,g,d,o,Sn.mixIn)}else{const w=a.timelineMode,x=a.timelinesRotation.length!=y<<1;x&&(a.timelinesRotation.length=y<<1);for(let b=0;b<y;b++){const S=p[b],C=w[b]==Vu?o:K.setup;S instanceof Yl?this.applyRotateTimeline(S,t,c,d,C,a.timelinesRotation,b<<1,x):S instanceof Qa?this.applyAttachmentTimeline(S,t,c,o,!0):(bt.webkit602BugfixHelper(d,o),S.apply(t,u,c,g,d,C,Sn.mixIn))}}this.queueEvents(a,m),e.length=0,a.nextAnimationLast=m,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+Wp,l=t.slots;for(let h=0,i=t.slots.length;h<i;h++){const a=l[h];if(a.attachmentState==r){const o=a.data.attachmentName;a.setAttachment(o?t.getAttachment(a.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==K.first&&(s=K.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=K.first&&(s=n.mixBlend));const l=r<n.attachmentThreshold,h=r<n.drawOrderThreshold,i=n.animation.timelines,a=i.length,o=n.alpha*t.interruptAlpha,d=o*(1-r),u=n.animationLast,m=n.getAnimationTime();let c=m,g=null;if(n.reverse?c=n.animation.duration-c:r<n.eventThreshold&&(g=this.events),s==K.add)for(let p=0;p<a;p++)i[p].apply(e,u,c,g,d,s,Sn.mixOut);else{const p=n.timelineMode,y=n.timelineHoldMix,w=n.timelinesRotation.length!=a<<1;w&&(n.timelinesRotation.length=a<<1),n.totalAlpha=0;for(let x=0;x<a;x++){const b=i[x];let S=Sn.mixOut,C,v=0;switch(p[x]){case Vu:if(!h&&b instanceof Eo)continue;C=s,v=d;break;case Lp:C=K.setup,v=d;break;case Op:C=s,v=o;break;case _u:C=K.setup,v=o;break;default:C=K.setup;const A=y[x];v=o*Math.max(0,1-A.mixTime/A.mixDuration);break}n.totalAlpha+=v,b instanceof Yl?this.applyRotateTimeline(b,e,c,v,C,n.timelinesRotation,x<<1,w):b instanceof Qa?this.applyAttachmentTimeline(b,e,c,C,l):(bt.webkit602BugfixHelper(v,s),h&&b instanceof Eo&&C==K.setup&&(S=Sn.mixIn),b.apply(e,u,c,g,v,C,S))}}return t.mixDuration>0&&this.queueEvents(n,m),this.events.length=0,n.nextAnimationLast=m,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(t,e,s,n,r){const l=e.slots[t.slotIndex];l.bone.active&&(s<t.frames[0]?(n==K.setup||n==K.first)&&this.setAttachment(e,l,l.data.attachmentName,r):this.setAttachment(e,l,t.attachmentNames[Ke.search1(t.frames,s)],r),l.attachmentState<=this.unkeyedState&&(l.attachmentState=this.unkeyedState+Wp))}setAttachment(t,e,s,n){e.setAttachment(s?t.getAttachment(e.data.index,s):null),n&&(e.attachmentState=this.unkeyedState+kA)}applyRotateTimeline(t,e,s,n,r,l,h,i){if(i&&(l[h]=0),n==1){t.apply(e,0,s,null,1,r,Sn.mixIn);return}const a=e.bones[t.boneIndex];if(!a.active)return;const o=t.frames;let d=0,u=0;if(s<o[0])switch(r){case K.setup:a.rotation=a.data.rotation;default:return;case K.first:d=a.rotation,u=a.data.rotation}else d=r==K.setup?a.data.rotation:a.rotation,u=a.data.rotation+t.getCurveValue(s);let m=0,c=u-d;if(c-=(16384-(16384.499999999996-c/360|0))*360,c==0)m=l[h];else{let g=0,p=0;i?(g=0,p=c):(g=l[h],p=l[h+1]);const y=c>0;let w=g>=0;j.signum(p)!=j.signum(c)&&Math.abs(p)<=90&&(Math.abs(g)>180&&(g+=360*j.signum(g)),w=y),m=c+g-g%360,w!=y&&(m+=360*j.signum(g)),l[h]=m}l[h+1]=c,a.rotation=d+m*n}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,l=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<l)break;d.time>n||this.queue.event(t,d)}let o=!1;for(t.loop?o=r==0||l>t.trackTime%r:o=e>=n&&t.animationLast<n,o&&this.queue.complete(t);i<a;i++){const d=h[i];d.time<s||this.queue.event(t,d)}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let s=e;for(;;){const n=s.mixingFrom;if(!n)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,n&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s=!1){const n=this.data.skeletonData.findAnimation(e);if(!n)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s=!1){if(!e)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,n=!1):this.clearNext(r));const l=this.trackEntry(t,e,s,r);return this.setCurrent(t,l,n),this.queue.drain(),l}addAnimation(t,e,s=!1,n=0){const r=this.data.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s=!1,n=0){if(!e)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r)for(;r.next;)r=r.next;const l=this.trackEntry(t,e,s,r);return r?(r.next=l,l.previous=r,n<=0&&(n+=r.getTrackComplete()-l.mixDuration)):(this.setCurrent(t,l,!0),this.queue.drain()),l.delay=n,l}setEmptyAnimation(t,e=0){const s=this.setAnimationWith(t,Pi.emptyAnimation(),!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e=0,s=0){const n=this.addAnimationWith(t,Pi.emptyAnimation(),!1,s);return s<=0&&(n.delay+=n.mixDuration-e),n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t=0){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(bt.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.interruptAlpha=1,r.mixTime=0,r.mixDuration=n?this.data.getMix(n.animation,e):0,r.mixBlend=K.replace,r}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const t=this.tracks;for(let e=0,s=t.length;e<s;e++){let n=t[e];if(n){for(;n.mixingFrom;)n=n.mixingFrom;do(!n.mixingTo||n.mixBlend!=K.add)&&this.computeHold(n),n=n.mixingTo;while(n)}}}computeHold(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=t.timelineMode;r.length=n;const l=t.timelineHoldMix;l.length=0;const h=this.propertyIDs;if(e&&e.holdPrevious){for(let i=0;i<n;i++)r[i]=h.addAll(s[i].getPropertyIds())?_u:Op;return}t:for(let i=0;i<n;i++){const a=s[i],o=a.getPropertyIds();if(!h.addAll(o))r[i]=Vu;else if(!e||a instanceof Qa||a instanceof Eo||a instanceof Ph||!e.animation.hasTimeline(o))r[i]=Lp;else{for(let d=e.mixingTo;d;d=d.mixingTo)if(!d.animation.hasTimeline(o)){if(t.mixDuration>0){r[i]=IA,l[i]=d;continue t}break}r[i]=_u}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){Pi.deprecatedWarning1||(Pi.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){Pi.deprecatedWarning2||(Pi.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return Pi.deprecatedWarning3||(Pi.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};yt(Rh,"deprecatedWarning1",!1),yt(Rh,"deprecatedWarning2",!1),yt(Rh,"deprecatedWarning3",!1);let Np=Rh;const Nu=class Ri{constructor(){yt(this,"animation",null),yt(this,"previous",null),yt(this,"next",null),yt(this,"mixingFrom",null),yt(this,"mixingTo",null),yt(this,"listener",null),yt(this,"trackIndex",0),yt(this,"loop",!1),yt(this,"holdPrevious",!1),yt(this,"reverse",!1),yt(this,"eventThreshold",0),yt(this,"attachmentThreshold",0),yt(this,"drawOrderThreshold",0),yt(this,"animationStart",0),yt(this,"animationEnd",0),yt(this,"animationLast",0),yt(this,"nextAnimationLast",0),yt(this,"delay",0),yt(this,"trackTime",0),yt(this,"trackLast",0),yt(this,"nextTrackLast",0),yt(this,"trackEnd",0),yt(this,"timeScale",0),yt(this,"alpha",0),yt(this,"mixTime",0),yt(this,"mixDuration",0),yt(this,"interruptAlpha",0),yt(this,"totalAlpha",0),yt(this,"mixBlend",K.replace),yt(this,"timelineMode",new Array),yt(this,"timelineHoldMix",new Array),yt(this,"timelinesRotation",new Array),yt(this,"onComplete"),yt(this,"onEvent"),yt(this,"onStart"),yt(this,"onEnd")}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return Ri.deprecatedWarning1||(Ri.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Ri.deprecatedWarning1||(Ri.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Ri.deprecatedWarning2||(Ri.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Ri.deprecatedWarning2||(Ri.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};yt(Nu,"deprecatedWarning1",!1),yt(Nu,"deprecatedWarning2",!1);let Vp=Nu,_p=class{constructor(t){yt(this,"objects",[]),yt(this,"drainDisabled",!1),yt(this,"animState",null),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener&&r.listener.start&&r.listener.start(r);for(let h=0;h<e.length;h++)e[h].start&&e[h].start(r);break;case 1:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let h=0;h<e.length;h++)e[h].interrupt&&e[h].interrupt(r);break;case 2:r.listener&&r.listener.end&&r.listener.end(r);for(let h=0;h<e.length;h++)e[h].end&&e[h].end(r);case 3:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let h=0;h<e.length;h++)e[h].dispose&&e[h].dispose(r);this.animState.trackEntryPool.free(r);break;case 4:r.listener&&r.listener.complete&&r.listener.complete(r);for(let h=0;h<e.length;h++)e[h].complete&&e[h].complete(r);break;case 5:const l=t[s+++2];r.listener&&r.listener.event&&r.listener.event(r,l);for(let h=0;h<e.length;h++)e[h].event&&e[h].event(r,l);break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}};var Dp=(f=>(f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event",f))(Dp||{});let EA=class{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}};const Vu=0,Lp=1,Op=2,_u=3,IA=4,Wp=1,kA=2;let Du=null;var PA=Object.defineProperty,RA=(f,t,e)=>t in f?PA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Lu=(f,t,e)=>RA(f,typeof t!="symbol"?t+"":t,e);let Up=class{constructor(t){if(Lu(this,"skeletonData"),Lu(this,"animationToMixTime",{}),Lu(this,"defaultMix",0),t==null)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(n==null)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(r==null)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixWith(t,e,s){if(t==null)throw new Error("from cannot be null.");if(e==null)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};var YA=Object.defineProperty,FA=(f,t,e)=>t in f?YA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,BA=(f,t,e)=>FA(f,typeof t!="symbol"?t+"":t,e);let XA=class{constructor(t){BA(this,"atlas"),this.atlas=t}newRegionAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);const r=new pu(e);return r.region=n,r}newMeshAttachment(t,e,s){const n=this.atlas.findRegion(s);if(n==null)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);const r=new Eh(e);return r.region=n,r}newBoundingBoxAttachment(t,e){return new Pp(e)}newPathAttachment(t,e){return new Pl(e)}newPointAttachment(t,e){return new Yp(e)}newClippingAttachment(t,e){return new Rp(e)}};var $A=Object.defineProperty,NA=(f,t,e)=>t in f?$A(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,_e=(f,t,e)=>NA(f,typeof t!="symbol"?t+"":t,e);let Ou=class{constructor(t,e,s){if(_e(this,"matrix",new V.Matrix),_e(this,"data",null),_e(this,"skeleton",null),_e(this,"parent",null),_e(this,"children",new Array),_e(this,"x",0),_e(this,"y",0),_e(this,"rotation",0),_e(this,"scaleX",0),_e(this,"scaleY",0),_e(this,"shearX",0),_e(this,"shearY",0),_e(this,"ax",0),_e(this,"ay",0),_e(this,"arotation",0),_e(this,"ascaleX",0),_e(this,"ascaleY",0),_e(this,"ashearX",0),_e(this,"ashearY",0),_e(this,"sorted",!1),_e(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,l,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=l,this.ashearY=h;const i=this.parent,a=this.matrix,o=this.skeleton.scaleX,d=-this.skeleton.scaleY;if(!i){const p=this.skeleton,y=s+90+h;a.a=j.cosDeg(s+l)*n*o,a.c=j.cosDeg(y)*r*o,a.b=j.sinDeg(s+l)*n*d,a.d=j.sinDeg(y)*r*d,a.tx=t*o+p.x,a.ty=e*d+p.y;return}let u=i.matrix.a,m=i.matrix.c,c=i.matrix.b,g=i.matrix.d;switch(a.tx=u*t+m*e+i.matrix.tx,a.ty=c*t+g*e+i.matrix.ty,this.data.transformMode){case Bn.Normal:{const p=s+90+h,y=j.cosDeg(s+l)*n,w=j.cosDeg(p)*r,x=j.sinDeg(s+l)*n,b=j.sinDeg(p)*r;a.a=u*y+m*x,a.c=u*w+m*b,a.b=c*y+g*x,a.d=c*w+g*b;return}case Bn.OnlyTranslation:{const p=s+90+h;a.a=j.cosDeg(s+l)*n,a.c=j.cosDeg(p)*r,a.b=j.sinDeg(s+l)*n,a.d=j.sinDeg(p)*r;break}case Bn.NoRotationOrReflection:{let p=u*u+c*c,y=0;p>1e-4?(p=Math.abs(u*g-m*c)/p,u/=o,c/=d,m=c*p,g=u*p,y=Math.atan2(c,u)*j.radDeg):(u=0,c=0,y=90-Math.atan2(g,m)*j.radDeg);const w=s+l-y,x=s+h-y+90,b=j.cosDeg(w)*n,S=j.cosDeg(x)*r,C=j.sinDeg(w)*n,v=j.sinDeg(x)*r;a.a=u*b-m*C,a.c=u*S-m*v,a.b=c*b+g*C,a.d=c*S+g*v;break}case Bn.NoScale:case Bn.NoScaleOrReflection:{const p=j.cosDeg(s),y=j.sinDeg(s);let w=(u*p+m*y)/o,x=(c*p+g*y)/d,b=Math.sqrt(w*w+x*x);b>1e-5&&(b=1/b),w*=b,x*=b,b=Math.sqrt(w*w+x*x),this.data.transformMode==Bn.NoScale&&u*g-m*c<0!=(o<0!=d<0)&&(b=-b);const S=Math.PI/2+Math.atan2(x,w),C=Math.cos(S)*b,v=Math.sin(S)*b,A=j.cosDeg(l)*n,M=j.cosDeg(90+h)*r,I=j.sinDeg(l)*n,E=j.sinDeg(90+h)*r;a.a=w*A+C*I,a.c=w*M+C*E,a.b=x*A+v*I,a.d=x*M+v*E;break}}a.a*=o,a.c*=o,a.b*=d,a.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*j.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*j.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,e=this.matrix;if(!t){this.ax=e.tx,this.ay=e.ty,this.arotation=Math.atan2(e.b,e.a)*j.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*j.radDeg;return}const s=t.matrix,n=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,l=e.ty-s.ty;this.ax=r*s.d*n-l*s.c*n,this.ay=l*s.a*n-r*s.b*n;const h=n*s.d,i=n*s.a,a=n*s.c,o=n*s.b,d=h*e.a-a*e.b,u=h*e.c-a*e.d,m=i*e.b-o*e.a,c=i*e.d-o*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*c-u*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*u+m*c,g)*j.radDeg,this.arotation=Math.atan2(m,d)*j.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+c*c),this.ashearY=0,this.arotation=90-Math.atan2(c,u)*j.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=1/(s*l-n*r),i=t.x-e.tx,a=t.y-e.ty;return t.x=i*l*h-a*n*h,t.y=a*s*h-i*r*h,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=j.sinDeg(t),s=j.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*s,n.d*s-n.c*e)*j.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const e=j.sinDeg(t),s=j.cosDeg(t),n=this.matrix;return Math.atan2(s*n.b+e*n.d,s*n.a+e*n.c)*j.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=j.cosDeg(t),i=j.sinDeg(t);e.a=h*s-i*r,e.c=h*n-i*l,e.b=i*s+h*r,e.d=i*n+h*l}};var VA=Object.defineProperty,_A=(f,t,e)=>t in f?VA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Cn=(f,t,e)=>_A(f,typeof t!="symbol"?t+"":t,e);let Wu=class{constructor(t,e,s){if(Cn(this,"index"),Cn(this,"name"),Cn(this,"parent"),Cn(this,"length"),Cn(this,"x",0),Cn(this,"y",0),Cn(this,"rotation",0),Cn(this,"scaleX",1),Cn(this,"scaleY",1),Cn(this,"shearX",0),Cn(this,"shearY",0),Cn(this,"transformMode",Bn.Normal),Cn(this,"skinRequired",!1),Cn(this,"color",new Lt),t<0)throw new Error("index must be >= 0.");if(e==null)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}},Yh=class{constructor(t,e,s){this.name=t,this.order=e,this.skinRequired=s}};var DA=Object.defineProperty,LA=(f,t,e)=>t in f?DA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ja=(f,t,e)=>LA(f,typeof t!="symbol"?t+"":t,e);let Uu=class{constructor(t,e){if(ja(this,"data"),ja(this,"intValue"),ja(this,"floatValue"),ja(this,"stringValue"),ja(this,"time"),ja(this,"volume"),ja(this,"balance"),e==null)throw new Error("data cannot be null.");this.time=t,this.data=e}};var OA=Object.defineProperty,WA=(f,t,e)=>t in f?OA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,to=(f,t,e)=>WA(f,typeof t!="symbol"?t+"":t,e);let qu=class{constructor(t){to(this,"name"),to(this,"intValue"),to(this,"floatValue"),to(this,"stringValue"),to(this,"audioPath"),to(this,"volume"),to(this,"balance"),this.name=t}};var UA=Object.defineProperty,qA=(f,t,e)=>t in f?UA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ui=(f,t,e)=>qA(f,typeof t!="symbol"?t+"":t,e);let qp=class{constructor(t,e){if(ui(this,"data"),ui(this,"bones"),ui(this,"target"),ui(this,"bendDirection",0),ui(this,"compress",!1),ui(this,"stretch",!1),ui(this,"mix",1),ui(this,"softness",0),ui(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,e,s,n,r,l,h){const i=t.parent.matrix,a=i.a;let o=i.c;const d=i.b;let u=i.d,m=-t.ashearX-t.arotation,c=0,g=0;const p=t.skeleton.scaleX,y=-t.skeleton.scaleY;switch(t.data.transformMode){case Bn.OnlyTranslation:c=e-t.worldX,g=s-t.worldY,g=-g;break;case Bn.NoRotationOrReflection:const b=Math.abs(a*u-o*d)/(a*a+d*d),S=a/p,C=d/y;o=-C*b*p,u=S*b*y,m+=Math.atan2(C,S)*j.radDeg;default:const v=e-i.tx,A=s-i.ty,M=a*u-o*d;c=(v*u-A*o)/M-t.ax,g=(A*a-v*d)/M-t.ay}m+=Math.atan2(g,c)*j.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let w=t.ascaleX,x=t.ascaleY;if(n||r){switch(t.data.transformMode){case Bn.NoScale:case Bn.NoScaleOrReflection:c=e-t.worldX,g=s-t.worldY}const b=t.data.length*w,S=Math.sqrt(c*c+g*g);if(n&&S<b||r&&S>b&&b>1e-4){const C=(S/b-1)*h+1;w*=C,l&&(x*=C)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,w,x,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,l,h,i,a){const o=t.ax,d=t.ay;let u=t.ascaleX,m=t.ascaleY,c=u,g=m,p=e.ascaleX;const y=t.matrix;let w=0,x=0,b=0;u<0?(u=-u,w=180,b=-1):(w=0,b=1),m<0&&(m=-m,b=-b),p<0?(p=-p,x=180):x=0;const S=e.ax;let C=0,v=0,A=0,M=y.a,I=y.c,E=y.b,P=y.d;const R=Math.abs(u-m)<=1e-4;!R||l?(C=0,v=M*S+y.tx,A=E*S+y.ty):(C=e.ay,v=M*S+I*C+y.tx,A=E*S+P*C+y.ty);const k=t.parent.matrix;M=k.a,I=k.c,E=k.b,P=k.d;const Y=1/(M*P-I*E);let F=v-k.tx,X=A-k.ty;const W=(F*P-X*I)*Y-o,B=(X*M-F*E)*Y-d,N=Math.sqrt(W*W+B*B);let O=e.data.length*p,Z,$;if(N<1e-4){this.apply1(t,s,n,!1,l,!1,a),e.updateWorldTransformWith(S,C,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);return}F=s-k.tx,X=n-k.ty;let D=(F*P-X*I)*Y-o,_=(X*M-F*E)*Y-d,lt=D*D+_*_;if(i!=0){i*=u*(p+1)*.5;const ct=Math.sqrt(lt),Mt=ct-N-O*u+i;if(Mt>0){let Rt=Math.min(1,Mt/(i*2))-1;Rt=(Mt-i*(1-Rt*Rt))/ct,D-=Rt*D,_-=Rt*_,lt=D*D+_*_}}t:if(R){O*=u;let ct=(lt-N*N-O*O)/(2*N*O);ct<-1?(ct=-1,$=Math.PI*r):ct>1?(ct=1,$=0,l&&(M=(Math.sqrt(lt)/(N+O)-1)*a+1,c*=M,h&&(g*=M))):$=Math.acos(ct)*r,M=N+O*ct,I=O*Math.sin($),Z=Math.atan2(_*M-D*I,D*M+_*I)}else{M=u*O,I=m*O;const ct=M*M,Mt=I*I,Rt=Math.atan2(_,D);E=Mt*N*N+ct*lt-ct*Mt;const de=-2*Mt*N,Ze=Mt-ct;if(P=de*de-4*Ze*E,P>=0){let Kt=Math.sqrt(P);de<0&&(Kt=-Kt),Kt=-(de+Kt)*.5;const ps=Kt/Ze,Vn=E/Kt,ts=Math.abs(ps)<Math.abs(Vn)?ps:Vn;if(ts*ts<=lt){X=Math.sqrt(lt-ts*ts)*r,Z=Rt-Math.atan2(X,ts),$=Math.atan2(X/m,(ts-N)/u);break t}}let Je=j.PI,we=N-M,Ye=we*we,Qe=0,je=0,ue=N+M,ye=ue*ue,Ue=0;E=-M*N/(ct-Mt),E>=-1&&E<=1&&(E=Math.acos(E),F=M*Math.cos(E)+N,X=I*Math.sin(E),P=F*F+X*X,P<Ye&&(Je=E,Ye=P,we=F,Qe=X),P>ye&&(je=E,ye=P,ue=F,Ue=X)),lt<=(Ye+ye)*.5?(Z=Rt-Math.atan2(Qe*r,we),$=Je*r):(Z=Rt-Math.atan2(Ue*r,ue),$=je*r)}const wt=Math.atan2(C,S)*b;let Tt=t.arotation;Z=(Z-wt)*j.radDeg+w-Tt,Z>180?Z-=360:Z<-180&&(Z+=360),t.updateWorldTransformWith(o,d,Tt+Z*a,c,g,0,0),Tt=e.arotation,$=(($+wt)*j.radDeg-e.ashearX)*b+x-Tt,$>180?$-=360:$<-180&&($+=360),e.updateWorldTransformWith(S,C,Tt+$*a,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}};var zA=Object.defineProperty,GA=(f,t,e)=>t in f?zA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ta=(f,t,e)=>GA(f,typeof t!="symbol"?t+"":t,e);let zu=class extends Yh{constructor(t){super(t,0,!1),ta(this,"bones",new Array),ta(this,"target"),ta(this,"bendDirection",1),ta(this,"compress",!1),ta(this,"stretch",!1),ta(this,"uniform",!1),ta(this,"mix",1),ta(this,"softness",0)}};var ea=(f=>(f[f.Fixed=0]="Fixed",f[f.Percent=1]="Percent",f))(ea||{}),Fl=(f=>(f[f.Tangent=0]="Tangent",f[f.Chain=1]="Chain",f[f.ChainScale=2]="ChainScale",f))(Fl||{}),HA=Object.defineProperty,KA=(f,t,e)=>t in f?HA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,gr=(f,t,e)=>KA(f,typeof t!="symbol"?t+"":t,e);let Gu=class extends Yh{constructor(t){super(t,0,!1),gr(this,"bones",new Array),gr(this,"target"),gr(this,"positionMode"),gr(this,"spacingMode"),gr(this,"rotateMode"),gr(this,"offsetRotation"),gr(this,"position"),gr(this,"spacing"),gr(this,"mixRotate",0),gr(this,"mixX",0),gr(this,"mixY",0)}};var gs=(f=>(f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f[f.Proportional=3]="Proportional",f))(gs||{}),ZA=Object.defineProperty,JA=(f,t,e)=>t in f?ZA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,as=(f,t,e)=>JA(f,typeof t!="symbol"?t+"":t,e);const Bl=class Yi{constructor(t,e){if(as(this,"data",null),as(this,"bones",null),as(this,"target",null),as(this,"position",0),as(this,"spacing",0),as(this,"mixRotate",0),as(this,"mixX",0),as(this,"mixY",0),as(this,"spaces",new Array),as(this,"positions",new Array),as(this,"world",new Array),as(this,"curves",new Array),as(this,"lengths",new Array),as(this,"segments",new Array),as(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let s=0,n=t.bones.length;s<n;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findSlot(t.target.name),this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}update(){let t=this.target.getAttachment();if(!(t instanceof Pl))return;let e=this.mixRotate,s=this.mixX,n=this.mixY;if(e==0&&s==0&&n==0)return;let r=this.data,l=r.rotateMode==Fl.Tangent,h=r.rotateMode==Fl.ChainScale,i=this.bones,a=i.length,o=l?a:a+1,d=bt.setArraySize(this.spaces,o),u=h?this.lengths=bt.setArraySize(this.lengths,a):null,m=this.spacing;switch(r.spacingMode){case gs.Percent:if(h)for(let S=0,C=o-1;S<C;S++){let v=i[S],A=v.data.length;if(A<Yi.epsilon)u[S]=0;else{let M=A*v.matrix.a,I=A*v.matrix.b;u[S]=Math.sqrt(M*M+I*I)}}bt.arrayFill(d,1,o,m);break;case gs.Proportional:let x=0;for(let S=0,C=o-1;S<C;){let v=i[S],A=v.data.length;if(A<Yi.epsilon)h&&(u[S]=0),d[++S]=m;else{let M=A*v.matrix.a,I=A*v.matrix.b,E=Math.sqrt(M*M+I*I);h&&(u[S]=E),d[++S]=E,x+=E}}if(x>0){x=o/x*m;for(let S=1;S<o;S++)d[S]*=x}break;default:let b=r.spacingMode==gs.Length;for(let S=0,C=o-1;S<C;){let v=i[S],A=v.data.length;if(A<Yi.epsilon)h&&(u[S]=0),d[++S]=m;else{let M=A*v.matrix.a,I=A*v.matrix.b,E=Math.sqrt(M*M+I*I);h&&(u[S]=E),d[++S]=(b?A+m:m)*E/A}}}let c=this.computeWorldPositions(t,o,l),g=c[0],p=c[1],y=r.offsetRotation,w=!1;if(y==0)w=r.rotateMode==Fl.Chain;else{w=!1;let x=this.target.bone.matrix;y*=x.a*x.d-x.b*x.c>0?j.degRad:-j.degRad}for(let x=0,b=3;x<a;x++,b+=3){let S=i[x],C=S.matrix;C.tx+=(g-C.tx)*s,C.ty+=(p-C.ty)*n;let v=c[b],A=c[b+1],M=v-g,I=A-p;if(h){let E=u[x];if(E!=0){let P=(Math.sqrt(M*M+I*I)/E-1)*e+1;C.a*=P,C.b*=P}}if(g=v,p=A,e>0){let E=C.a,P=C.c,R=C.b,k=C.d,Y=0,F=0,X=0;if(l?Y=c[b-1]:d[x+1]==0?Y=c[b+2]:Y=Math.atan2(I,M),Y-=Math.atan2(R,E),w){F=Math.cos(Y),X=Math.sin(Y);let W=S.data.length;g+=(W*(F*E-X*R)-M)*e,p+=(W*(X*E+F*R)-I)*e}else Y+=y;Y>j.PI?Y-=j.PI2:Y<-j.PI&&(Y+=j.PI2),Y*=e,F=Math.cos(Y),X=Math.sin(Y),C.a=F*E-X*R,C.c=F*P-X*k,C.b=X*E+F*R,C.d=X*P+F*k}S.updateAppliedTransform()}}computeWorldPositions(t,e,s){let n=this.target,r=this.position,l=this.spaces,h=bt.setArraySize(this.positions,e*3+2),i=null,a=t.closed,o=t.worldVerticesLength,d=o/6,u=Yi.NONE;if(!t.constantSpeed){let W=t.lengths;d-=a?1:2;let B=W[d];this.data.positionMode==ea.Percent&&(r*=B);let N;switch(this.data.spacingMode){case gs.Percent:N=B;break;case gs.Proportional:N=B/e;break;default:N=1}i=bt.setArraySize(this.world,8);for(let O=0,Z=0,$=0;O<e;O++,Z+=3){let D=l[O]*N;r+=D;let _=r;if(a)_%=B,_<0&&(_+=B),$=0;else if(_<0){u!=Yi.BEFORE&&(u=Yi.BEFORE,t.computeWorldVertices(n,2,4,i,0,2)),this.addBeforePosition(_,i,0,h,Z);continue}else if(_>B){u!=Yi.AFTER&&(u=Yi.AFTER,t.computeWorldVertices(n,o-6,4,i,0,2)),this.addAfterPosition(_-B,i,0,h,Z);continue}for(;;$++){let lt=W[$];if(!(_>lt)){if($==0)_/=lt;else{let wt=W[$-1];_=(_-wt)/(lt-wt)}break}}$!=u&&(u=$,a&&$==d?(t.computeWorldVertices(n,o-4,4,i,0,2),t.computeWorldVertices(n,0,4,i,4,2)):t.computeWorldVertices(n,$*6+2,8,i,0,2)),this.addCurvePosition(_,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],h,Z,s||O>0&&D==0)}return h}a?(o+=2,i=bt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o-4,i,0,2),t.computeWorldVertices(n,0,2,i,o-4,2),i[o-2]=i[0],i[o-1]=i[1]):(d--,o-=4,i=bt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o,i,0,2));let m=bt.setArraySize(this.curves,d),c=0,g=i[0],p=i[1],y=0,w=0,x=0,b=0,S=0,C=0,v=0,A=0,M=0,I=0,E=0,P=0,R=0,k=0;for(let W=0,B=2;W<d;W++,B+=6)y=i[B],w=i[B+1],x=i[B+2],b=i[B+3],S=i[B+4],C=i[B+5],v=(g-y*2+x)*.1875,A=(p-w*2+b)*.1875,M=((y-x)*3-g+S)*.09375,I=((w-b)*3-p+C)*.09375,E=v*2+M,P=A*2+I,R=(y-g)*.75+v+M*.16666667,k=(w-p)*.75+A+I*.16666667,c+=Math.sqrt(R*R+k*k),R+=E,k+=P,E+=M,P+=I,c+=Math.sqrt(R*R+k*k),R+=E,k+=P,c+=Math.sqrt(R*R+k*k),R+=E+M,k+=P+I,c+=Math.sqrt(R*R+k*k),m[W]=c,g=S,p=C;this.data.positionMode==ea.Percent&&(r*=c);let Y;switch(this.data.spacingMode){case gs.Percent:Y=c;break;case gs.Proportional:Y=c/e;break;default:Y=1}let F=this.segments,X=0;for(let W=0,B=0,N=0,O=0;W<e;W++,B+=3){let Z=l[W]*Y;r+=Z;let $=r;if(a)$%=c,$<0&&($+=c),N=0;else if($<0){this.addBeforePosition($,i,0,h,B);continue}else if($>c){this.addAfterPosition($-c,i,o-4,h,B);continue}for(;;N++){let D=m[N];if(!($>D)){if(N==0)$/=D;else{let _=m[N-1];$=($-_)/(D-_)}break}}if(N!=u){u=N;let D=N*6;for(g=i[D],p=i[D+1],y=i[D+2],w=i[D+3],x=i[D+4],b=i[D+5],S=i[D+6],C=i[D+7],v=(g-y*2+x)*.03,A=(p-w*2+b)*.03,M=((y-x)*3-g+S)*.006,I=((w-b)*3-p+C)*.006,E=v*2+M,P=A*2+I,R=(y-g)*.3+v+M*.16666667,k=(w-p)*.3+A+I*.16666667,X=Math.sqrt(R*R+k*k),F[0]=X,D=1;D<8;D++)R+=E,k+=P,E+=M,P+=I,X+=Math.sqrt(R*R+k*k),F[D]=X;R+=E,k+=P,X+=Math.sqrt(R*R+k*k),F[8]=X,R+=E+M,k+=P+I,X+=Math.sqrt(R*R+k*k),F[9]=X,O=0}for($*=X;;O++){let D=F[O];if(!($>D)){if(O==0)$/=D;else{let _=F[O-1];$=O+($-_)/(D-_)}break}}this.addCurvePosition($*.1,g,p,y,w,x,b,S,C,h,B,s||W>0&&Z==0)}return h}addBeforePosition(t,e,s,n,r){let l=e[s],h=e[s+1],i=e[s+2]-l,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){let l=e[s+2],h=e[s+3],i=l-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,l,h,i,a,o,d,u){if(t==0||isNaN(t)){o[d]=e,o[d+1]=s,o[d+2]=Math.atan2(r-s,n-e);return}let m=t*t,c=m*t,g=1-t,p=g*g,y=p*g,w=g*t,x=w*3,b=g*x,S=x*t,C=e*y+n*b+l*S+i*c,v=s*y+r*b+h*S+a*c;o[d]=C,o[d+1]=v,u&&(t<.001?o[d+2]=Math.atan2(r-s,n-e):o[d+2]=Math.atan2(v-(s*p+r*w*2+h*m),C-(e*p+n*w*2+l*m)))}};as(Bl,"NONE",-1),as(Bl,"BEFORE",-2),as(Bl,"AFTER",-3),as(Bl,"epsilon",1e-5);let zp=Bl;var QA=Object.defineProperty,jA=(f,t,e)=>t in f?QA(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,pr=(f,t,e)=>jA(f,typeof t!="symbol"?t+"":t,e);let Gp=class{constructor(t,e){if(pr(this,"data"),pr(this,"bones"),pr(this,"target"),pr(this,"mixRotate",0),pr(this,"mixX",0),pr(this,"mixY",0),pr(this,"mixScaleX",0),pr(this,"mixScaleY",0),pr(this,"mixShearY",0),pr(this,"temp",new uu),pr(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let s=0;s<t.bones.length;s++)this.bones.push(e.findBone(t.bones[s].name));this.target=e.findBone(t.target.name)}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleY==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,u=a.b,m=a.d,c=o*m-d*u>0?j.degRad:-j.degRad,g=this.data.offsetRotation*c,p=this.data.offsetShearY*c,y=this.bones;for(let w=0,x=y.length;w<x;w++){const b=y[w],S=b.matrix;if(t!=0){const C=S.a,v=S.c,A=S.b,M=S.d;let I=Math.atan2(u,o)-Math.atan2(A,C)+g;I>j.PI?I-=j.PI2:I<-j.PI&&(I+=j.PI2),I*=t;const E=Math.cos(I),P=Math.sin(I);S.a=E*C-P*A,S.c=E*v-P*M,S.b=P*C+E*A,S.d=P*v+E*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=(C.x-S.tx)*e,S.ty+=(C.y-S.ty)*s}if(n!=0){let C=Math.sqrt(S.a*S.a+S.b*S.b);C!=0&&(C=(C+(Math.sqrt(o*o+u*u)-C+this.data.offsetScaleX)*n)/C),S.a*=C,S.b*=C}if(r!=0){let C=Math.sqrt(S.c*S.c+S.d*S.d);C!=0&&(C=(C+(Math.sqrt(d*d+m*m)-C+this.data.offsetScaleY)*r)/C),S.c*=C,S.d*=C}if(l>0){const C=S.c,v=S.d,A=Math.atan2(v,C);let M=Math.atan2(m,d)-Math.atan2(u,o)-(A-Math.atan2(S.b,S.a));M>j.PI?M-=j.PI2:M<-j.PI&&(M+=j.PI2),M=A+(M+p)*l;const I=Math.sqrt(C*C+v*v);S.c=Math.cos(M)*I,S.d=Math.sin(M)*I}b.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,u=a.b,m=a.d,c=o*m-d*u>0?j.degRad:-j.degRad,g=this.data.offsetRotation*c,p=this.data.offsetShearY*c,y=this.bones;for(let w=0,x=y.length;w<x;w++){const b=y[w],S=b.matrix;if(t!=0){const C=S.a,v=S.c,A=S.b,M=S.d;let I=Math.atan2(u,o)+g;I>j.PI?I-=j.PI2:I<-j.PI&&(I+=j.PI2),I*=t;const E=Math.cos(I),P=Math.sin(I);S.a=E*C-P*A,S.c=E*v-P*M,S.b=P*C+E*A,S.d=P*v+E*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=C.x*e,S.ty+=C.y*s}if(n!=0){const C=(Math.sqrt(o*o+u*u)-1+this.data.offsetScaleX)*n+1;S.a*=C,S.b*=C}if(r!=0){const C=(Math.sqrt(d*d+m*m)-1+this.data.offsetScaleY)*r+1;S.c*=C,S.d*=C}if(l>0){let C=Math.atan2(m,d)-Math.atan2(u,o);C>j.PI?C-=j.PI2:C<-j.PI&&(C+=j.PI2);const v=S.c,A=S.d;C=Math.atan2(A,v)+(C-j.PI/2+p)*l;const M=Math.sqrt(v*v+A*A);S.c=Math.cos(C)*M,S.d=Math.sin(C)*M}b.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a];let u=d.arotation;if(t!=0){let w=h.arotation-u+this.data.offsetRotation;w-=(16384-(16384.499999999996-w/360|0))*360,u+=w*t}let m=d.ax,c=d.ay;m+=(h.ax-m+this.data.offsetX)*e,c+=(h.ay-c+this.data.offsetY)*s;let g=d.ascaleX,p=d.ascaleY;n!=0&&g!=0&&(g=(g+(h.ascaleX-g+this.data.offsetScaleX)*n)/g),r!=0&&p!=0&&(p=(p+(h.ascaleY-p+this.data.offsetScaleY)*r)/p);let y=d.ashearY;if(l!=0){let w=h.ashearY-y+this.data.offsetShearY;w-=(16384-(16384.499999999996-w/360|0))*360,y+=w*l}d.updateWorldTransformWith(m,c,u,g,p,d.ashearX,y)}}applyRelativeLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a],u=d.arotation+(h.arotation+this.data.offsetRotation)*t,m=d.ax+(h.ax+this.data.offsetX)*e,c=d.ay+(h.ay+this.data.offsetY)*s,g=d.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*n+1),p=d.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*r+1),y=d.ashearY+(h.ashearY+this.data.offsetShearY)*l;d.updateWorldTransformWith(m,c,u,g,p,d.ashearX,y)}}};var t2=Object.defineProperty,e2=(f,t,e)=>t in f?t2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,zs=(f,t,e)=>e2(f,typeof t!="symbol"?t+"":t,e);const Hp=class Jl{constructor(t){if(zs(this,"data",null),zs(this,"bones",null),zs(this,"slots",null),zs(this,"drawOrder",null),zs(this,"ikConstraints",null),zs(this,"transformConstraints",null),zs(this,"pathConstraints",null),zs(this,"_updateCache",new Array),zs(this,"skin",null),zs(this,"color",null),zs(this,"time",0),zs(this,"scaleX",1),zs(this,"scaleY",1),zs(this,"x",0),zs(this,"y",0),!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(!s.parent)n=new Ou(s,this,null);else{const r=this.bones[s.parent.index];n=new Ou(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new gu(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new qp(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new Gp(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new zp(s,this))}this.color=new Lt(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0;const e=this.bones;for(let o=0,d=e.length;o<d;o++){const u=e[o];u.sorted=u.data.skinRequired,u.active=!u.sorted}if(this.skin){const o=this.skin.bones;for(let d=0,u=this.skin.bones.length;d<u;d++){let m=this.bones[o[d].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m)}}const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,l=s.length,h=n.length,i=r.length,a=l+h+i;t:for(let o=0;o<a;o++){for(let d=0;d<l;d++){const u=s[d];if(u.data.order==o){this.sortIkConstraint(u);continue t}}for(let d=0;d<h;d++){const u=n[d];if(u.data.order==o){this.sortTransformConstraint(u);continue t}}for(let d=0;d<i;d++){const u=r[d];if(u.data.order==o){this.sortPathConstraint(u);continue t}}}for(let o=0,d=e.length;o<d;o++)this.sortBone(e[o])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&bt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length==1)this._updateCache.push(t),this.sortReset(n.children);else{const r=s[s.length-1];this.sortBone(r),this._updateCache.push(t),this.sortReset(n.children),r.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&bt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,s=e.data.index,n=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof Pl&&this.sortPathConstraintAttachmentWith(r,n);const l=t.bones,h=l.length;for(let i=0;i<h;i++)this.sortBone(l[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(l[i].children);for(let i=0;i<h;i++)l[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&bt.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this.sortBone(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof Pl))return;const s=t.bones;if(!s)this.sortBone(e);else{const n=this.bones;for(let r=0,l=s.length;r<l;){let h=s[r++];for(h+=r;r<h;)this.sortBone(n[s[r++]])}}}sortBone(t){if(t.sorted)return;const e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.bones;for(let s=0,n=t.length;s<n;s++){const r=t[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const e=this._updateCache;for(let s=0,n=e.length;s<n;s++)e[s].update()}updateWorldTransformWith(t){const e=this.getRootBone(),s=t.matrix.a,n=t.matrix.c,r=t.matrix.b,l=t.matrix.d;e.matrix.tx=s*this.x+n*this.y+t.worldX,e.matrix.ty=r*this.x+l*this.y+t.worldY;const h=e.rotation+90+e.shearY,i=j.cosDeg(e.rotation+e.shearX)*e.scaleX,a=j.cosDeg(h)*e.scaleY,o=j.sinDeg(e.rotation+e.shearX)*e.scaleX,d=j.sinDeg(h)*e.scaleY,u=this.scaleX,m=-this.scaleY;e.matrix.a=(s*i+n*o)*u,e.matrix.c=(s*a+n*d)*u,e.matrix.b=(r*i+l*o)*m,e.matrix.d=(r*a+l*d)*m;const c=this._updateCache;for(let g=0,p=c.length;g<p;g++){const y=c[g];y!=e&&y.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let r=0,l=t.length;r<l;r++)t[r].setToSetupPose();const e=this.ikConstraints;for(let r=0,l=e.length;r<l;r++){const h=e[r];h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}const s=this.transformConstraints;for(let r=0,l=s.length;r<l;r++){const h=s[r],i=h.data;h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY,h.mixScaleX=i.mixScaleX,h.mixScaleY=i.mixScaleY,h.mixShearY=i.mixShearY}const n=this.pathConstraints;for(let r=0,l=n.length;r<l;r++){const h=n[r],i=h.data;h.position=i.position,h.spacing=i.spacing,h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY}}setSlotsToSetupPose(){const t=this.slots;bt.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(!e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],l=r.data.attachmentName;if(l){const h=t.getAttachment(s,l);h&&r.setAttachment(h)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){return this.getAttachment(this.data.findSlot(t).index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){const s=this.skin.getAttachment(t,e);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.data.name==t){let h=null;if(e&&(h=this.getAttachment(n,e),!h))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);l.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}getBoundsRect(){const t=new uu,e=new uu;return this.getBounds(t,e),{x:t.x,y:t.y,width:e.x,height:e.y}}getBounds(t,e,s=new Array(2)){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let a=0,o=n.length;a<o;a++){const d=n[a];if(!d.bone.active)continue;let u=0,m=null;const c=d.getAttachment();if(c instanceof pu)u=8,m=bt.setArraySize(s,u,0),c.computeWorldVertices(d.bone,m,0,2);else if(c instanceof Eh){const g=c;u=g.worldVerticesLength,m=bt.setArraySize(s,u,0),g.computeWorldVertices(d,0,u,m,0,2)}if(m)for(let g=0,p=m.length;g<p;g+=2){const y=m[g],w=m[g+1];r=Math.min(r,y),l=Math.min(l,w),h=Math.max(h,y),i=Math.max(i,w)}}t.set(r,l),e.set(h-r,i-l)}update(t){this.time+=t}get flipX(){return this.scaleX==-1}set flipX(t){Jl.deprecatedWarning1||(Jl.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){Jl.deprecatedWarning1||(Jl.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};zs(Hp,"deprecatedWarning1",!1);let Kp=Hp;var s2=Object.defineProperty,n2=(f,t,e)=>t in f?s2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,os=(f,t,e)=>n2(f,typeof t!="symbol"?t+"":t,e);let Hu=class{constructor(){os(this,"name",null),os(this,"bones",new Array),os(this,"slots",new Array),os(this,"skins",new Array),os(this,"defaultSkin",null),os(this,"events",new Array),os(this,"animations",new Array),os(this,"ikConstraints",new Array),os(this,"transformConstraints",new Array),os(this,"pathConstraints",new Array),os(this,"x",0),os(this,"y",0),os(this,"width",0),os(this,"height",0),os(this,"version",null),os(this,"hash",null),os(this,"fps",0),os(this,"imagesPath",null),os(this,"audioPath",null)}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}};var r2=Object.defineProperty,i2=(f,t,e)=>t in f?r2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,eo=(f,t,e)=>i2(f,typeof t!="symbol"?t+"":t,e);let Ku=class{constructor(t,e,s){if(eo(this,"index"),eo(this,"name"),eo(this,"boneData"),eo(this,"color",new Lt(1,1,1,1)),eo(this,"darkColor"),eo(this,"attachmentName"),eo(this,"blendMode"),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");if(!s)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}};var a2=Object.defineProperty,o2=(f,t,e)=>t in f?a2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Gs=(f,t,e)=>o2(f,typeof t!="symbol"?t+"":t,e);let Zu=class extends Yh{constructor(t){super(t,0,!1),Gs(this,"bones",new Array),Gs(this,"target"),Gs(this,"mixRotate",0),Gs(this,"mixX",0),Gs(this,"mixY",0),Gs(this,"mixScaleX",0),Gs(this,"mixScaleY",0),Gs(this,"mixShearY",0),Gs(this,"offsetRotation",0),Gs(this,"offsetX",0),Gs(this,"offsetY",0),Gs(this,"offsetScaleX",0),Gs(this,"offsetScaleY",0),Gs(this,"offsetShearY",0),Gs(this,"relative",!1),Gs(this,"local",!1)}};var l2=Object.defineProperty,h2=(f,t,e)=>t in f?l2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Fh=(f,t,e)=>h2(f,typeof t!="symbol"?t+"":t,e);let Ju=class{constructor(t,e,s){this.slotIndex=t,this.name=e,this.attachment=s}},Bh=class{constructor(t){if(Fh(this,"name"),Fh(this,"attachments",new Array),Fh(this,"bones",Array()),Fh(this,"constraints",new Array),!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(!s)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let l=0;l<this.bones.length;l++)if(this.bones[l]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let l=0;l<this.constraints.length;l++)if(this.constraints[l]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let l=0;l<this.bones.length;l++)if(this.bones[l]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let l=0;l<this.constraints.length;l++)if(this.constraints[l]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];n.attachment&&(n.attachment instanceof Eh?(n.attachment=n.attachment.newLinkedMesh(),this.setAttachment(n.slotIndex,n.name,n.attachment)):(n.attachment=n.attachment.copy(),this.setAttachment(n.slotIndex,n.name,n.attachment)))}}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){const s=this.attachments[t];s&&(s[e]=null)}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const s=this.attachments[e];if(s)for(const n in s){const r=s[n];r&&t.push(new Ju(e,n,r))}}return t}getAttachmentsForSlot(t,e){const s=this.attachments[t];if(s)for(const n in s){const r=s[n];r&&e.push(new Ju(t,n,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],l=r.getAttachment();if(l&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(l==a){const o=this.getAttachment(s,i);o&&r.setAttachment(o);break}}}s++}}},c2=class{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<7,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<14,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<21,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}};var d2=Object.defineProperty,u2=(f,t,e)=>t in f?d2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,fi=(f,t,e)=>u2(f,typeof t!="symbol"?t+"":t,e);const Zp=class rb{constructor(t){fi(this,"scale",1),fi(this,"attachmentLoader",null),fi(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new Hu;s.name="";const n=new c2(t),r=n.readInt32(),l=n.readInt32();if(s.hash=l==0&&r==0?null:l.toString(16)+r.toString(16),s.version=n.readString(),s.version.substr(0,3)!=="4.0"){const o=`Spine 4.0 loader cant load version ${s.version}. Please configure your pixi-spine bundle`;console.error(o)}s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat();const h=n.readBoolean();h&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let i=0;i=n.readInt(!0);for(let o=0;o<i;o++)n.strings.push(n.readString());i=n.readInt(!0);for(let o=0;o<i;o++){const d=n.readString(),u=o==0?null:s.bones[n.readInt(!0)],m=new Wu(o,d,u);m.rotation=n.readFloat(),m.x=n.readFloat()*e,m.y=n.readFloat()*e,m.scaleX=n.readFloat(),m.scaleY=n.readFloat(),m.shearX=n.readFloat(),m.shearY=n.readFloat(),m.length=n.readFloat()*e,m.transformMode=n.readInt(!0),m.skinRequired=n.readBoolean(),h&&Lt.rgba8888ToColor(m.color,n.readInt32()),s.bones.push(m)}i=n.readInt(!0);for(let o=0;o<i;o++){const d=n.readString(),u=s.bones[n.readInt(!0)],m=new Ku(o,d,u);Lt.rgba8888ToColor(m.color,n.readInt32());const c=n.readInt32();c!=-1&&Lt.rgb888ToColor(m.darkColor=new Lt,c),m.attachmentName=n.readStringRef(),m.blendMode=rb.BlendModeValues[n.readInt(!0)],s.slots.push(m)}i=n.readInt(!0);for(let o=0,d;o<i;o++){const u=new zu(n.readString());u.order=n.readInt(!0),u.skinRequired=n.readBoolean(),d=n.readInt(!0);for(let m=0;m<d;m++)u.bones.push(s.bones[n.readInt(!0)]);u.target=s.bones[n.readInt(!0)],u.mix=n.readFloat(),u.softness=n.readFloat()*e,u.bendDirection=n.readByte(),u.compress=n.readBoolean(),u.stretch=n.readBoolean(),u.uniform=n.readBoolean(),s.ikConstraints.push(u)}i=n.readInt(!0);for(let o=0,d;o<i;o++){const u=new Zu(n.readString());u.order=n.readInt(!0),u.skinRequired=n.readBoolean(),d=n.readInt(!0);for(let m=0;m<d;m++)u.bones.push(s.bones[n.readInt(!0)]);u.target=s.bones[n.readInt(!0)],u.local=n.readBoolean(),u.relative=n.readBoolean(),u.offsetRotation=n.readFloat(),u.offsetX=n.readFloat()*e,u.offsetY=n.readFloat()*e,u.offsetScaleX=n.readFloat(),u.offsetScaleY=n.readFloat(),u.offsetShearY=n.readFloat(),u.mixRotate=n.readFloat(),u.mixX=n.readFloat(),u.mixY=n.readFloat(),u.mixScaleX=n.readFloat(),u.mixScaleY=n.readFloat(),u.mixShearY=n.readFloat(),s.transformConstraints.push(u)}i=n.readInt(!0);for(let o=0,d;o<i;o++){const u=new Gu(n.readString());u.order=n.readInt(!0),u.skinRequired=n.readBoolean(),d=n.readInt(!0);for(let m=0;m<d;m++)u.bones.push(s.bones[n.readInt(!0)]);u.target=s.slots[n.readInt(!0)],u.positionMode=n.readInt(!0),u.spacingMode=n.readInt(!0),u.rotateMode=n.readInt(!0),u.offsetRotation=n.readFloat(),u.position=n.readFloat(),u.positionMode==ea.Fixed&&(u.position*=e),u.spacing=n.readFloat(),(u.spacingMode==gs.Length||u.spacingMode==gs.Fixed)&&(u.spacing*=e),u.mixRotate=n.readFloat(),u.mixX=n.readFloat(),u.mixY=n.readFloat(),s.pathConstraints.push(u)}const a=this.readSkin(n,s,!0,h);a&&(s.defaultSkin=a,s.skins.push(a));{let o=s.skins.length;for(bt.setArraySize(s.skins,i=o+n.readInt(!0));o<i;o++)s.skins[o]=this.readSkin(n,s,!1,h)}i=this.linkedMeshes.length;for(let o=0;o<i;o++){const d=this.linkedMeshes[o],m=(d.skin?s.findSkin(d.skin):s.defaultSkin).getAttachment(d.slotIndex,d.parent);d.mesh.deformAttachment=d.inheritDeform?m:d.mesh,d.mesh.setParentMesh(m)}this.linkedMeshes.length=0,i=n.readInt(!0);for(let o=0;o<i;o++){const d=new qu(n.readStringRef());d.intValue=n.readInt(!1),d.floatValue=n.readFloat(),d.stringValue=n.readString(),d.audioPath=n.readString(),d.audioPath&&(d.volume=n.readFloat(),d.balance=n.readFloat()),s.events.push(d)}i=n.readInt(!0);for(let o=0;o<i;o++)s.animations.push(this.readAnimation(n,n.readString(),s));return s}readSkin(t,e,s,n){let r=null,l=0;if(s){if(l=t.readInt(!0),l==0)return null;r=new Bh("default")}else{r=new Bh(t.readStringRef()),r.bones.length=t.readInt(!0);for(let h=0,i=r.bones.length;h<i;h++)r.bones[h]=e.bones[t.readInt(!0)];for(let h=0,i=t.readInt(!0);h<i;h++)r.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let h=0,i=t.readInt(!0);h<i;h++)r.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let h=0,i=t.readInt(!0);h<i;h++)r.constraints.push(e.pathConstraints[t.readInt(!0)]);l=t.readInt(!0)}for(let h=0;h<l;h++){const i=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readStringRef(),u=this.readAttachment(t,e,r,i,d,n);u&&r.setAttachment(i,d,u)}}return r}readAttachment(t,e,s,n,r,l){const h=this.scale;let i=t.readStringRef();switch(i||(i=r),t.readByte()){case Ve.Region:{let a=t.readStringRef();const o=t.readFloat(),d=t.readFloat(),u=t.readFloat(),m=t.readFloat(),c=t.readFloat(),g=t.readFloat(),p=t.readFloat(),y=t.readInt32();a||(a=i);const w=this.attachmentLoader.newRegionAttachment(s,i,a);return w?(w.path=a,w.x=d*h,w.y=u*h,w.scaleX=m,w.scaleY=c,w.rotation=o,w.width=g*h,w.height=p*h,Lt.rgba8888ToColor(w.color,y),w):null}case Ve.BoundingBox:{const a=t.readInt(!0),o=this.readVertices(t,a),d=l?t.readInt32():0,u=this.attachmentLoader.newBoundingBoxAttachment(s,i);return u?(u.worldVerticesLength=a<<1,u.vertices=o.vertices,u.bones=o.bones,l&&Lt.rgba8888ToColor(u.color,d),u):null}case Ve.Mesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readInt(!0),u=this.readFloatArray(t,d<<1,1),m=this.readShortArray(t),c=this.readVertices(t,d),g=t.readInt(!0);let p=null,y=0,w=0;l&&(p=this.readShortArray(t),y=t.readFloat(),w=t.readFloat()),a||(a=i);const x=this.attachmentLoader.newMeshAttachment(s,i,a);return x?(x.path=a,Lt.rgba8888ToColor(x.color,o),x.bones=c.bones,x.vertices=c.vertices,x.worldVerticesLength=d<<1,x.triangles=m,x.regionUVs=new Float32Array(u),x.hullLength=g<<1,l&&(x.edges=p,x.width=y*h,x.height=w*h),x):null}case Ve.LinkedMesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readStringRef(),u=t.readStringRef(),m=t.readBoolean();let c=0,g=0;l&&(c=t.readFloat(),g=t.readFloat()),a||(a=i);const p=this.attachmentLoader.newMeshAttachment(s,i,a);return p?(p.path=a,Lt.rgba8888ToColor(p.color,o),l&&(p.width=c*h,p.height=g*h),this.linkedMeshes.push(new m2(p,d,n,u,m)),p):null}case Ve.Path:{const a=t.readBoolean(),o=t.readBoolean(),d=t.readInt(!0),u=this.readVertices(t,d),m=bt.newArray(d/3,0);for(let p=0,y=m.length;p<y;p++)m[p]=t.readFloat()*h;const c=l?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(s,i);return g?(g.closed=a,g.constantSpeed=o,g.worldVerticesLength=d<<1,g.vertices=u.vertices,g.bones=u.bones,g.lengths=m,l&&Lt.rgba8888ToColor(g.color,c),g):null}case Ve.Point:{const a=t.readFloat(),o=t.readFloat(),d=t.readFloat(),u=l?t.readInt32():0,m=this.attachmentLoader.newPointAttachment(s,i);return m?(m.x=o*h,m.y=d*h,m.rotation=a,l&&Lt.rgba8888ToColor(m.color,u),m):null}case Ve.Clipping:{const a=t.readInt(!0),o=t.readInt(!0),d=this.readVertices(t,o),u=l?t.readInt32():0,m=this.attachmentLoader.newClippingAttachment(s,i);return m?(m.endSlot=e.slots[a],m.worldVerticesLength=o<<1,m.vertices=d.vertices,m.bones=d.bones,l&&Lt.rgba8888ToColor(m.color,u),m):null}}return null}readVertices(t,e){const s=this.scale,n=e<<1,r=new g2;if(!t.readBoolean())return r.vertices=this.readFloatArray(t,n,s),r;const l=new Array,h=new Array;for(let i=0;i<e;i++){const a=t.readInt(!0);h.push(a);for(let o=0;o<a;o++)h.push(t.readInt(!0)),l.push(t.readFloat()*s),l.push(t.readFloat()*s),l.push(t.readFloat())}return r.vertices=bt.toFloatArray(l),r.bones=h,r}readFloatArray(t,e,s){const n=new Array(e);if(s==1)for(let r=0;r<e;r++)n[r]=t.readFloat();else for(let r=0;r<e;r++)n[r]=t.readFloat()*s;return n}readShortArray(t){const e=t.readInt(!0),s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readShort();return s}readAnimation(t,e,s){t.readInt(!0);const n=new Array,r=this.scale;for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readByte(),g=t.readInt(!0),p=g-1;switch(c){case T2:{const y=new Qa(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat(),t.readStringRef());n.push(y);break}case E2:{const y=t.readInt(!0),w=new Tu(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255;for(let A=0,M=0;w.setFrame(A,x,b,S,C,v),A!=p;A++){const I=t.readFloat(),E=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255;switch(t.readByte()){case xr:w.setStepped(A);break;case br:zt(t,w,M++,A,0,x,I,b,E,1),zt(t,w,M++,A,1,x,I,S,P,1),zt(t,w,M++,A,2,x,I,C,R,1),zt(t,w,M++,A,3,x,I,v,k,1)}x=I,b=E,S=P,C=R,v=k}n.push(w);break}case I2:{const y=t.readInt(!0),w=new Eu(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let v=0,A=0;w.setFrame(v,x,b,S,C),v!=p;v++){const M=t.readFloat(),I=t.readUnsignedByte()/255,E=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255;switch(t.readByte()){case xr:w.setStepped(v);break;case br:zt(t,w,A++,v,0,x,M,b,I,1),zt(t,w,A++,v,1,x,M,S,E,1),zt(t,w,A++,v,2,x,M,C,P,1)}x=M,b=I,S=E,C=P}n.push(w);break}case k2:{const y=t.readInt(!0),w=new ku(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255;for(let E=0,P=0;w.setFrame(E,x,b,S,C,v,A,M,I),E!=p;E++){const R=t.readFloat(),k=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255;switch(t.readByte()){case xr:w.setStepped(E);break;case br:zt(t,w,P++,E,0,x,R,b,k,1),zt(t,w,P++,E,1,x,R,S,Y,1),zt(t,w,P++,E,2,x,R,C,F,1),zt(t,w,P++,E,3,x,R,v,X,1),zt(t,w,P++,E,4,x,R,A,W,1),zt(t,w,P++,E,5,x,R,M,B,1),zt(t,w,P++,E,6,x,R,I,N,1)}x=R,b=k,S=Y,C=F,v=X,A=W,M=B,I=N}n.push(w);break}case P2:{const y=t.readInt(!0),w=new Pu(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let I=0,E=0;w.setFrame(I,x,b,S,C,v,A,M),I!=p;I++){const P=t.readFloat(),R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255;switch(t.readByte()){case xr:w.setStepped(I);break;case br:zt(t,w,E++,I,0,x,P,b,R,1),zt(t,w,E++,I,1,x,P,S,k,1),zt(t,w,E++,I,2,x,P,C,Y,1),zt(t,w,E++,I,3,x,P,v,F,1),zt(t,w,E++,I,4,x,P,A,X,1),zt(t,w,E++,I,5,x,P,M,W,1)}x=P,b=R,S=k,C=Y,v=F,A=X,M=W}n.push(w);break}case R2:{const y=new Iu(g,t.readInt(!0),d);let w=t.readFloat(),x=t.readUnsignedByte()/255;for(let b=0,S=0;y.setFrame(b,w,x),b!=p;b++){const C=t.readFloat(),v=t.readUnsignedByte()/255;switch(t.readByte()){case xr:y.setStepped(b);break;case br:zt(t,y,S++,b,0,w,C,x,v,1)}w=C,x=v}n.push(y);break}}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readByte(),g=t.readInt(!0),p=t.readInt(!0);switch(c){case p2:n.push(mi(t,new Yl(g,p,d),1));break;case x2:n.push(Qu(t,new xu(g,p,d),r));break;case b2:n.push(mi(t,new bu(g,p,d),r));break;case w2:n.push(mi(t,new wu(g,p,d),r));break;case y2:n.push(Qu(t,new yu(g,p,d),1));break;case S2:n.push(mi(t,new Su(g,p,d),1));break;case C2:n.push(mi(t,new Cu(g,p,d),1));break;case v2:n.push(Qu(t,new vu(g,p,d),1));break;case A2:n.push(mi(t,new Au(g,p,d),1));break;case M2:n.push(mi(t,new Mu(g,p,d),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),u=t.readInt(!0),m=u-1,c=new Yu(u,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat()*r;for(let w=0,x=0;c.setFrame(w,g,p,y,t.readByte(),t.readBoolean(),t.readBoolean()),w!=m;w++){const b=t.readFloat(),S=t.readFloat(),C=t.readFloat()*r;switch(t.readByte()){case xr:c.setStepped(w);break;case br:zt(t,c,x++,w,0,g,b,p,S,1),zt(t,c,x++,w,1,g,b,y,C,r)}g=b,p=S,y=C}n.push(c)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),u=t.readInt(!0),m=u-1,c=new Fu(u,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),x=t.readFloat(),b=t.readFloat(),S=t.readFloat();for(let C=0,v=0;c.setFrame(C,g,p,y,w,x,b,S),C!=m;C++){const A=t.readFloat(),M=t.readFloat(),I=t.readFloat(),E=t.readFloat(),P=t.readFloat(),R=t.readFloat(),k=t.readFloat();switch(t.readByte()){case xr:c.setStepped(C);break;case br:zt(t,c,v++,C,0,g,A,p,M,1),zt(t,c,v++,C,1,g,A,y,I,1),zt(t,c,v++,C,2,g,A,w,E,1),zt(t,c,v++,C,3,g,A,x,P,1),zt(t,c,v++,C,4,g,A,b,R,1),zt(t,c,v++,C,5,g,A,S,k,1)}g=A,p=M,y=I,w=E,x=P,b=R,S=k}n.push(c)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),u=s.pathConstraints[d];for(let m=0,c=t.readInt(!0);m<c;m++)switch(t.readByte()){case Y2:n.push(mi(t,new Bu(t.readInt(!0),t.readInt(!0),d),u.positionMode==ea.Fixed?r:1));break;case F2:n.push(mi(t,new Xu(t.readInt(!0),t.readInt(!0),d),u.spacingMode==gs.Length||u.spacingMode==gs.Fixed?r:1));break;case B2:const g=new $u(t.readInt(!0),t.readInt(!0),d);let p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),x=t.readFloat();for(let b=0,S=0,C=g.getFrameCount()-1;g.setFrame(b,p,y,w,x),b!=C;b++){const v=t.readFloat(),A=t.readFloat(),M=t.readFloat(),I=t.readFloat();switch(t.readByte()){case xr:g.setStepped(b);break;case br:zt(t,g,S++,b,0,p,v,y,A,1),zt(t,g,S++,b,1,p,v,w,M,1),zt(t,g,S++,b,2,p,v,x,I,1)}p=v,y=A,w=M,x=I}n.push(g)}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=s.skins[t.readInt(!0)];for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readInt(!0);for(let g=0,p=t.readInt(!0);g<p;g++){const y=t.readStringRef(),w=d.getAttachment(c,y),x=w.bones,b=w.vertices,S=x?b.length/3*2:b.length,C=t.readInt(!0),v=C-1,A=t.readInt(!0),M=new Ru(C,A,c,w);let I=t.readFloat();for(let E=0,P=0;;E++){let R,k=t.readInt(!0);if(k==0)R=x?bt.newFloatArray(S):b;else{R=bt.newFloatArray(S);const F=t.readInt(!0);if(k+=F,r==1)for(let X=F;X<k;X++)R[X]=t.readFloat();else for(let X=F;X<k;X++)R[X]=t.readFloat()*r;if(!x)for(let X=0,W=R.length;X<W;X++)R[X]+=b[X]}if(M.setFrame(E,I,R),E==v)break;const Y=t.readFloat();switch(t.readByte()){case xr:M.setStepped(E);break;case br:zt(t,M,P++,E,0,I,Y,0,1,1)}I=Y}n.push(M)}}}const l=t.readInt(!0);if(l>0){const a=new Eo(l),o=s.slots.length;for(let d=0;d<l;d++){const u=t.readFloat(),m=t.readInt(!0),c=bt.newArray(o,0);for(let w=o-1;w>=0;w--)c[w]=-1;const g=bt.newArray(o-m,0);let p=0,y=0;for(let w=0;w<m;w++){const x=t.readInt(!0);for(;p!=x;)g[y++]=p++;c[p+t.readInt(!0)]=p++}for(;p<o;)g[y++]=p++;for(let w=o-1;w>=0;w--)c[w]==-1&&(c[w]=g[--y]);a.setFrame(d,u,c)}n.push(a)}const h=t.readInt(!0);if(h>0){const a=new Ph(h);for(let o=0;o<h;o++){const d=t.readFloat(),u=s.events[t.readInt(!0)],m=new Uu(d,u);m.intValue=t.readInt(!1),m.floatValue=t.readFloat(),m.stringValue=t.readBoolean()?t.readString():u.stringValue,m.data.audioPath&&(m.volume=t.readFloat(),m.balance=t.readFloat()),a.setFrame(o,m)}n.push(a)}let i=0;for(let a=0,o=n.length;a<o;a++)i=Math.max(i,n[a].getDuration());return new Ih(e,n,i)}};fi(Zp,"BlendModeValues",[V.BLEND_MODES.NORMAL,V.BLEND_MODES.ADD,V.BLEND_MODES.MULTIPLY,V.BLEND_MODES.SCREEN]);let f2=Zp,m2=class{constructor(t,e,s,n,r){fi(this,"parent"),fi(this,"skin"),fi(this,"slotIndex"),fi(this,"mesh"),fi(this,"inheritDeform"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritDeform=r}},g2=class{constructor(t=null,e=null){this.bones=t,this.vertices=e}};function mi(f,t,e){let s=f.readFloat(),n=f.readFloat()*e;for(let r=0,l=0,h=t.getFrameCount()-1;t.setFrame(r,s,n),r!=h;r++){const i=f.readFloat(),a=f.readFloat()*e;switch(f.readByte()){case xr:t.setStepped(r);break;case br:zt(f,t,l++,r,0,s,i,n,a,e)}s=i,n=a}return t}function Qu(f,t,e){let s=f.readFloat(),n=f.readFloat()*e,r=f.readFloat()*e;for(let l=0,h=0,i=t.getFrameCount()-1;t.setFrame(l,s,n,r),l!=i;l++){const a=f.readFloat(),o=f.readFloat()*e,d=f.readFloat()*e;switch(f.readByte()){case xr:t.setStepped(l);break;case br:zt(f,t,h++,l,0,s,a,n,o,e),zt(f,t,h++,l,1,s,a,r,d,e)}s=a,n=o,r=d}return t}function zt(f,t,e,s,n,r,l,h,i,a){t.setBezier(e,s,n,r,h,f.readFloat(),f.readFloat()*a,f.readFloat(),f.readFloat()*a,l,i)}const p2=0,x2=1,b2=2,w2=3,y2=4,S2=5,C2=6,v2=7,A2=8,M2=9,T2=0,E2=1,I2=2,k2=3,P2=4,R2=5,Y2=0,F2=1,B2=2,xr=1,br=2;var X2=Object.defineProperty,$2=(f,t,e)=>t in f?X2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,so=(f,t,e)=>$2(f,typeof t!="symbol"?t+"":t,e);let N2=class{constructor(){so(this,"minX",0),so(this,"minY",0),so(this,"maxX",0),so(this,"maxY",0),so(this,"boundingBoxes",new Array),so(this,"polygons",new Array),so(this,"polygonPool",new Cp(()=>bt.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,l=t.slots,h=l.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=l[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===Ve.BoundingBox){const d=o;s.push(d);let u=r.obtain();u.length!=d.worldVerticesLength&&(u=bt.newFloatArray(d.worldVerticesLength)),n.push(u),d.computeWorldVertices(a,0,d.worldVerticesLength,u,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let l=0,h=r.length;l<h;l++){const i=r[l],a=i;for(let o=0,d=i.length;o<d;o+=2){const u=a[o],m=a[o+1];t=Math.min(t,u),e=Math.min(e,m),s=Math.max(s,u),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,l=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=l&&n<=l||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>l&&o<i||(o=a*(h-t)+e,o>l&&o<i))return!0;let d=(l-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let l=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[l+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[l]-d)<e&&(h=!h)}l=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let l=0,h=r.length;l<h;l++)if(this.intersectsSegmentPolygon(r[l],t,e,s,n))return this.boundingBoxes[l];return null}intersectsSegmentPolygon(t,e,s,n,r){const l=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=l[h-2],u=l[h-1];for(let m=0;m<h;m+=2){const c=l[m],g=l[m+1],p=d*g-u*c,y=d-c,w=u-g,x=i*w-a*y,b=(o*y-i*p)/x;if((b>=d&&b<=c||b>=c&&b<=d)&&(b>=e&&b<=n||b>=n&&b<=e)){const S=(o*w-a*p)/x;if((S>=u&&S<=g||S>=g&&S<=u)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=c,u=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}},V2=class extends N2{};var _2=Object.defineProperty,D2=(f,t,e)=>t in f?_2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,sa=(f,t,e)=>D2(f,typeof t!="symbol"?t+"":t,e);let L2=class ib{constructor(t){sa(this,"attachmentLoader",null),sa(this,"scale",1),sa(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new Hu,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r){if(s.hash=r.hash,s.version=r.spine,s.version.substr(0,3)!=="4.0"){const l=`Spine 4.0 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(l)}s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images}if(n.bones)for(let l=0;l<n.bones.length;l++){const h=n.bones[l];let i=null;const a=z(h,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const o=new Wu(s.bones.length,h.name,i);o.length=z(h,"length",0)*e,o.x=z(h,"x",0)*e,o.y=z(h,"y",0)*e,o.rotation=z(h,"rotation",0),o.scaleX=z(h,"scaleX",1),o.scaleY=z(h,"scaleY",1),o.shearX=z(h,"shearX",0),o.shearY=z(h,"shearY",0),o.transformMode=bt.enumValue(Bn,z(h,"transform","Normal")),o.skinRequired=z(h,"skin",!1);const d=z(h,"color",null);d&&o.color.setFromString(d),s.bones.push(o)}if(n.slots)for(let l=0;l<n.slots.length;l++){const h=n.slots[l],i=s.findBone(h.bone),a=new Ku(s.slots.length,h.name,i),o=z(h,"color",null);o&&a.color.setFromString(o);const d=z(h,"dark",null);d&&(a.darkColor=Lt.fromString(d)),a.attachmentName=z(h,"attachment",null),a.blendMode=ib.blendModeFromString(z(h,"blend","normal")),s.slots.push(a)}if(n.ik)for(let l=0;l<n.ik.length;l++){const h=n.ik[l],i=new zu(h.name);i.order=z(h,"order",0),i.skinRequired=z(h,"skin",!1);for(let a=0;a<h.bones.length;a++){const o=h.bones[a],d=s.findBone(o);if(d==null)throw new Error(`IK bone not found: ${o}`);i.bones.push(d)}i.target=s.findBone(h.target),i.mix=z(h,"mix",1),i.softness=z(h,"softness",0)*e,i.bendDirection=z(h,"bendPositive",!0)?1:-1,i.compress=z(h,"compress",!1),i.stretch=z(h,"stretch",!1),i.uniform=z(h,"uniform",!1),s.ikConstraints.push(i)}if(n.transform)for(let l=0;l<n.transform.length;l++){const h=n.transform[l],i=new Zu(h.name);i.order=z(h,"order",0),i.skinRequired=z(h,"skin",!1);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],u=s.findBone(d);if(u==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(u)}const a=h.target;if(i.target=s.findBone(a),i.target==null)throw new Error(`Transform constraint target bone not found: ${a}`);i.local=z(h,"local",!1),i.relative=z(h,"relative",!1),i.offsetRotation=z(h,"rotation",0),i.offsetX=z(h,"x",0)*e,i.offsetY=z(h,"y",0)*e,i.offsetScaleX=z(h,"scaleX",0),i.offsetScaleY=z(h,"scaleY",0),i.offsetShearY=z(h,"shearY",0),i.mixRotate=z(h,"mixRotate",1),i.mixX=z(h,"mixX",1),i.mixY=z(h,"mixY",i.mixX),i.mixScaleX=z(h,"mixScaleX",1),i.mixScaleY=z(h,"mixScaleY",i.mixScaleX),i.mixShearY=z(h,"mixShearY",1),s.transformConstraints.push(i)}if(n.path)for(let l=0;l<n.path.length;l++){const h=n.path[l],i=new Gu(h.name);i.order=z(h,"order",0),i.skinRequired=z(h,"skin",!1);for(let o=0;o<h.bones.length;o++){const d=h.bones[o],u=s.findBone(d);if(u==null)throw new Error(`Transform constraint bone not found: ${d}`);i.bones.push(u)}const a=h.target;if(i.target=s.findSlot(a),i.target==null)throw new Error(`Path target slot not found: ${a}`);i.positionMode=bt.enumValue(ea,z(h,"positionMode","Percent")),i.spacingMode=bt.enumValue(gs,z(h,"spacingMode","Length")),i.rotateMode=bt.enumValue(Fl,z(h,"rotateMode","Tangent")),i.offsetRotation=z(h,"rotation",0),i.position=z(h,"position",0),i.positionMode==ea.Fixed&&(i.position*=e),i.spacing=z(h,"spacing",0),(i.spacingMode==gs.Length||i.spacingMode==gs.Fixed)&&(i.spacing*=e),i.mixRotate=z(h,"mixRotate",1),i.mixX=z(h,"mixX",1),i.mixY=z(h,"mixY",i.mixX),s.pathConstraints.push(i)}if(n.skins)for(let l=0;l<n.skins.length;l++){const h=n.skins[l],i=new Bh(h.name);if(h.bones)for(let a=0;a<h.bones.length;a++){const o=s.findBone(h.bones[a]);if(o==null)throw new Error(`Skin bone not found: ${h.bones[l]}`);i.bones.push(o)}if(h.ik)for(let a=0;a<h.ik.length;a++){const o=s.findIkConstraint(h.ik[a]);if(o==null)throw new Error(`Skin IK constraint not found: ${h.ik[l]}`);i.constraints.push(o)}if(h.transform)for(let a=0;a<h.transform.length;a++){const o=s.findTransformConstraint(h.transform[a]);if(o==null)throw new Error(`Skin transform constraint not found: ${h.transform[l]}`);i.constraints.push(o)}if(h.path)for(let a=0;a<h.path.length;a++){const o=s.findPathConstraint(h.path[a]);if(o==null)throw new Error(`Skin path constraint not found: ${h.path[l]}`);i.constraints.push(o)}for(const a in h.attachments){const o=s.findSlot(a);if(o==null)throw new Error(`Slot not found: ${a}`);const d=h.attachments[a];for(const u in d){const m=this.readAttachment(d[u],i,o.index,u,s);m&&i.setAttachment(o.index,u,m)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let l=0,h=this.linkedMeshes.length;l<h;l++){const i=this.linkedMeshes[l],o=(i.skin?s.findSkin(i.skin):s.defaultSkin).getAttachment(i.slotIndex,i.parent);i.mesh.deformAttachment=i.inheritDeform?o:i.mesh,i.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,n.events)for(const l in n.events){const h=n.events[l],i=new qu(l);i.intValue=z(h,"int",0),i.floatValue=z(h,"float",0),i.stringValue=z(h,"string",""),i.audioPath=z(h,"audio",null),i.audioPath&&(i.volume=z(h,"volume",1),i.balance=z(h,"balance",0)),s.events.push(i)}if(n.animations)for(const l in n.animations){const h=n.animations[l];this.readAnimation(h,l,s)}return s}readAttachment(t,e,s,n,r){const l=this.scale;switch(n=z(t,"name",n),z(t,"type","region")){case"region":{const h=z(t,"path",n),i=this.attachmentLoader.newRegionAttachment(e,n,h);if(!i)return null;i.path=h,i.x=z(t,"x",0)*l,i.y=z(t,"y",0)*l,i.scaleX=z(t,"scaleX",1),i.scaleY=z(t,"scaleY",1),i.rotation=z(t,"rotation",0),i.width=t.width*l,i.height=t.height*l;const a=z(t,"color",null);return a&&i.color.setFromString(a),i}case"boundingbox":{const h=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);const i=z(t,"color",null);return i&&h.color.setFromString(i),h}case"mesh":case"linkedmesh":{const h=z(t,"path",n),i=this.attachmentLoader.newMeshAttachment(e,n,h);if(!i)return null;i.path=h;const a=z(t,"color",null);a&&i.color.setFromString(a),i.width=z(t,"width",0)*l,i.height=z(t,"height",0)*l;const o=z(t,"parent",null);if(o)return this.linkedMeshes.push(new O2(i,z(t,"skin",null),s,o,z(t,"deform",!0))),i;const d=t.uvs;return this.readVertices(t,i,d.length),i.triangles=t.triangles,i.regionUVs=new Float32Array(d),i.edges=z(t,"edges",null),i.hullLength=z(t,"hull",0)*2,i}case"path":{const h=this.attachmentLoader.newPathAttachment(e,n);if(!h)return null;h.closed=z(t,"closed",!1),h.constantSpeed=z(t,"constantSpeed",!0);const i=t.vertexCount;this.readVertices(t,h,i<<1);const a=bt.newArray(i/3,0);for(let d=0;d<t.lengths.length;d++)a[d]=t.lengths[d]*l;h.lengths=a;const o=z(t,"color",null);return o&&h.color.setFromString(o),h}case"point":{const h=this.attachmentLoader.newPointAttachment(e,n);if(!h)return null;h.x=z(t,"x",0)*l,h.y=z(t,"y",0)*l,h.rotation=z(t,"rotation",0);const i=z(t,"color",null);return i&&h.color.setFromString(i),h}case"clipping":{const h=this.attachmentLoader.newClippingAttachment(e,n);if(!h)return null;const i=z(t,"end",null);if(i!=null){const d=r.findSlot(i);if(d==null)throw new Error(`Clipping end slot not found: ${i}`);h.endSlot=d}const a=t.vertexCount;this.readVertices(t,h,a<<1);const o=z(t,"color",null);return o&&h.color.setFromString(o),h}}return null}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=bt.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const l=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),l.push(r[i+1]*n),l.push(r[i+2]*n),l.push(r[i+3])}e.bones=h,e.vertices=bt.toFloatArray(l)}readAnimation(t,e,s){const n=this.scale,r=new Array;if(t.slots)for(const h in t.slots){const i=t.slots[h],a=s.findSlot(h).index;if(a==-1)throw new Error(`Slot not found: ${h}`);for(const o in i){const d=i[o];if(!d)continue;const u=d.length;if(o=="attachment"){const m=new Qa(u,a);for(let c=0;c<u;c++){const g=d[c];m.setFrame(c,z(g,"time",0),g.name)}r.push(m)}else if(o=="rgba"){const m=new Tu(u,u<<2,a);let c=d[0],g=z(c,"time",0),p=Lt.fromString(c.color);for(let y=0,w=0;;y++){m.setFrame(y,g,p.r,p.g,p.b,p.a);const x=d[y+1];if(!x){m.shrink(w);break}const b=z(x,"time",0),S=Lt.fromString(x.color),C=c.curve;C&&(w=Qt(C,m,w,y,0,g,b,p.r,S.r,1),w=Qt(C,m,w,y,1,g,b,p.g,S.g,1),w=Qt(C,m,w,y,2,g,b,p.b,S.b,1),w=Qt(C,m,w,y,3,g,b,p.a,S.a,1)),g=b,p=S,c=x}r.push(m)}else if(o=="rgb"){const m=new Eu(u,u*3,a);let c=d[0],g=z(c,"time",0),p=Lt.fromString(c.color);for(let y=0,w=0;;y++){m.setFrame(y,g,p.r,p.g,p.b);const x=d[y+1];if(!x){m.shrink(w);break}const b=z(x,"time",0),S=Lt.fromString(x.color),C=c.curve;C&&(w=Qt(C,m,w,y,0,g,b,p.r,S.r,1),w=Qt(C,m,w,y,1,g,b,p.g,S.g,1),w=Qt(C,m,w,y,2,g,b,p.b,S.b,1)),g=b,p=S,c=x}r.push(m)}else if(o=="alpha")r.push(Gr(d,new Iu(u,u,a),0,1));else if(o=="rgba2"){const m=new ku(u,u*7,a);let c=d[0],g=z(c,"time",0),p=Lt.fromString(c.light),y=Lt.fromString(c.dark);for(let w=0,x=0;;w++){m.setFrame(w,g,p.r,p.g,p.b,p.a,y.r,y.g,y.b);const b=d[w+1];if(!b){m.shrink(x);break}const S=z(b,"time",0),C=Lt.fromString(b.light),v=Lt.fromString(b.dark),A=c.curve;A&&(x=Qt(A,m,x,w,0,g,S,p.r,C.r,1),x=Qt(A,m,x,w,1,g,S,p.g,C.g,1),x=Qt(A,m,x,w,2,g,S,p.b,C.b,1),x=Qt(A,m,x,w,3,g,S,p.a,C.a,1),x=Qt(A,m,x,w,4,g,S,y.r,v.r,1),x=Qt(A,m,x,w,5,g,S,y.g,v.g,1),x=Qt(A,m,x,w,6,g,S,y.b,v.b,1)),g=S,p=C,y=v,c=b}r.push(m)}else if(o=="rgb2"){const m=new Pu(u,u*6,a);let c=d[0],g=z(c,"time",0),p=Lt.fromString(c.light),y=Lt.fromString(c.dark);for(let w=0,x=0;;w++){m.setFrame(w,g,p.r,p.g,p.b,y.r,y.g,y.b);const b=d[w+1];if(!b){m.shrink(x);break}const S=z(b,"time",0),C=Lt.fromString(b.light),v=Lt.fromString(b.dark),A=c.curve;A&&(x=Qt(A,m,x,w,0,g,S,p.r,C.r,1),x=Qt(A,m,x,w,1,g,S,p.g,C.g,1),x=Qt(A,m,x,w,2,g,S,p.b,C.b,1),x=Qt(A,m,x,w,3,g,S,y.r,v.r,1),x=Qt(A,m,x,w,4,g,S,y.g,v.g,1),x=Qt(A,m,x,w,5,g,S,y.b,v.b,1)),g=S,p=C,y=v,c=b}r.push(m)}else throw new Error(`Invalid timeline type for a slot: ${o} (${h})`)}}if(t.bones)for(const h in t.bones){const i=t.bones[h],a=s.findBone(h).index;if(a==-1)throw new Error(`Bone not found: ${h}`);for(const o in i){const d=i[o],u=d.length;if(u!=0){if(o==="rotate")r.push(Gr(d,new Yl(u,u,a),0,1));else if(o==="translate"){const m=new xu(u,u<<1,a);r.push(ju(d,m,"x","y",0,n))}else if(o==="translatex"){const m=new bu(u,u,a);r.push(Gr(d,m,0,n))}else if(o==="translatey"){const m=new wu(u,u,a);r.push(Gr(d,m,0,n))}else if(o==="scale"){const m=new yu(u,u<<1,a);r.push(ju(d,m,"x","y",1,1))}else if(o==="scalex"){const m=new Su(u,u,a);r.push(Gr(d,m,1,1))}else if(o==="scaley"){const m=new Cu(u,u,a);r.push(Gr(d,m,1,1))}else if(o==="shear"){const m=new vu(u,u<<1,a);r.push(ju(d,m,"x","y",0,1))}else if(o==="shearx"){const m=new Au(u,u,a);r.push(Gr(d,m,0,1))}else if(o==="sheary"){const m=new Mu(u,u,a);r.push(Gr(d,m,0,1))}}}}if(t.ik)for(const h in t.ik){const i=t.ik[h];let a=i[0];if(!a)continue;const o=s.findIkConstraint(h),d=s.ikConstraints.indexOf(o),u=new Yu(i.length,i.length<<1,d);let m=z(a,"time",0),c=z(a,"mix",1),g=z(a,"softness",0)*n;for(let p=0,y=0;;p++){u.setFrame(p,m,c,g,z(a,"bendPositive",!0)?1:-1,z(a,"compress",!1),z(a,"stretch",!1));const w=i[p+1];if(!w){u.shrink(y);break}const x=z(w,"time",0),b=z(w,"mix",1),S=z(w,"softness",0)*n,C=a.curve;C&&(y=Qt(C,u,y,p,0,m,x,c,b,1),y=Qt(C,u,y,p,1,m,x,g,S,n)),m=x,c=b,g=S,a=w}r.push(u)}if(t.transform)for(const h in t.transform){const i=t.transform[h];let a=i[0];if(!a)continue;const o=s.findTransformConstraint(h),d=s.transformConstraints.indexOf(o),u=new Fu(i.length,i.length*6,d);let m=z(a,"time",0),c=z(a,"mixRotate",1),g=z(a,"mixX",1),p=z(a,"mixY",g),y=z(a,"mixScaleX",1),w=z(a,"mixScaleY",y);const x=z(a,"mixShearY",1);for(let b=0,S=0;;b++){u.setFrame(b,m,c,g,p,y,w,x);const C=i[b+1];if(!C){u.shrink(S);break}const v=z(C,"time",0),A=z(C,"mixRotate",1),M=z(C,"mixX",1),I=z(C,"mixY",M),E=z(C,"mixScaleX",1),P=z(C,"mixScaleY",E),R=z(C,"mixShearY",1),k=a.curve;k&&(S=Qt(k,u,S,b,0,m,v,c,A,1),S=Qt(k,u,S,b,1,m,v,g,M,1),S=Qt(k,u,S,b,2,m,v,p,I,1),S=Qt(k,u,S,b,3,m,v,y,E,1),S=Qt(k,u,S,b,4,m,v,w,P,1),S=Qt(k,u,S,b,5,m,v,x,R,1)),m=v,c=A,g=M,p=I,y=E,w=P,y=E,a=C}r.push(u)}if(t.path)for(const h in t.path){const i=t.path[h],a=s.findPathConstraintIndex(h);if(a==-1)throw new Error(`Path constraint not found: ${h}`);const o=s.pathConstraints[a];for(const d in i){const u=i[d];let m=u[0];if(!m)continue;const c=u.length;if(d==="position"){const g=new Bu(c,c,a);r.push(Gr(u,g,0,o.positionMode==ea.Fixed?n:1))}else if(d==="spacing"){const g=new Xu(c,c,a);r.push(Gr(u,g,0,o.spacingMode==gs.Length||o.spacingMode==gs.Fixed?n:1))}else if(d==="mix"){const g=new $u(c,c*3,a);let p=z(m,"time",0),y=z(m,"mixRotate",1),w=z(m,"mixX",1),x=z(m,"mixY",w);for(let b=0,S=0;;b++){g.setFrame(b,p,y,w,x);const C=u[b+1];if(!C){g.shrink(S);break}const v=z(C,"time",0),A=z(C,"mixRotate",1),M=z(C,"mixX",1),I=z(C,"mixY",M),E=m.curve;E&&(S=Qt(E,g,S,b,0,p,v,y,A,1),S=Qt(E,g,S,b,1,p,v,w,M,1),S=Qt(E,g,S,b,2,p,v,x,I,1)),p=v,y=A,w=M,x=I,m=C}r.push(g)}}}if(t.deform)for(const h in t.deform){const i=t.deform[h],a=s.findSkin(h);if(a!=null)for(const o in i){const d=i[o],u=s.findSlot(o).index;for(const m in d){const c=d[m];let g=c[0];if(!g)continue;const p=a.getAttachment(u,m),y=p.bones,w=p.vertices,x=y?w.length/3*2:w.length,b=new Ru(c.length,c.length,u,p);let S=z(g,"time",0);for(let C=0,v=0;;C++){let A;const M=z(g,"vertices",null);if(!M)A=y?bt.newFloatArray(x):w;else{A=bt.newFloatArray(x);const R=z(g,"offset",0);if(bt.arrayCopy(M,0,A,R,M.length),n!=1)for(let k=R,Y=k+M.length;k<Y;k++)A[k]*=n;if(!y)for(let k=0;k<x;k++)A[k]+=w[k]}b.setFrame(C,S,A);const I=c[C+1];if(!I){b.shrink(v);break}const E=z(I,"time",0),P=g.curve;P&&(v=Qt(P,b,v,C,0,S,E,0,1,1)),S=E,g=I}r.push(b)}}}if(t.drawOrder){const h=new Eo(t.drawOrder.length),i=s.slots.length;let a=0;for(let o=0;o<t.drawOrder.length;o++,a++){const d=t.drawOrder[o];let u=null;const m=z(d,"offsets",null);if(m){u=bt.newArray(i,-1);const c=bt.newArray(i-m.length,0);let g=0,p=0;for(let y=0;y<m.length;y++){const w=m[y],x=s.findSlot(w.slot).index;for(;g!=x;)c[p++]=g++;u[g+w.offset]=g++}for(;g<i;)c[p++]=g++;for(let y=i-1;y>=0;y--)u[y]==-1&&(u[y]=c[--p])}h.setFrame(a,z(d,"time",0),u)}r.push(h)}if(t.events){const h=new Ph(t.events.length);let i=0;for(let a=0;a<t.events.length;a++,i++){const o=t.events[a],d=s.findEvent(o.name),u=new Uu(bt.toSinglePrecision(z(o,"time",0)),d);u.intValue=z(o,"int",d.intValue),u.floatValue=z(o,"float",d.floatValue),u.stringValue=z(o,"string",d.stringValue),u.data.audioPath&&(u.volume=z(o,"volume",1),u.balance=z(o,"balance",0)),h.setFrame(i,u)}r.push(h)}let l=0;for(let h=0,i=r.length;h<i;h++)l=Math.max(l,r[h].getDuration());if(isNaN(l))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new Ih(e,r,l))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return V.BLEND_MODES.NORMAL;if(t=="additive")return V.BLEND_MODES.ADD;if(t=="multiply")return V.BLEND_MODES.MULTIPLY;if(t=="screen")return V.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}},O2=class{constructor(t,e,s,n,r){sa(this,"parent"),sa(this,"skin"),sa(this,"slotIndex"),sa(this,"mesh"),sa(this,"inheritDeform"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritDeform=r}};function Gr(f,t,e,s){let n=f[0],r=z(n,"time",0),l=z(n,"value",e)*s,h=0;for(let i=0;;i++){t.setFrame(i,r,l);const a=f[i+1];if(!a)return t.shrink(h),t;const o=z(a,"time",0),d=z(a,"value",e)*s;n.curve&&(h=Qt(n.curve,t,h,i,0,r,o,l,d,s)),r=o,l=d,n=a}}function ju(f,t,e,s,n,r){let l=f[0],h=z(l,"time",0),i=z(l,e,n)*r,a=z(l,s,n)*r,o=0;for(let d=0;;d++){t.setFrame(d,h,i,a);const u=f[d+1];if(!u)return t.shrink(o),t;const m=z(u,"time",0),c=z(u,e,n)*r,g=z(u,s,n)*r,p=l.curve;p&&(o=Qt(p,t,o,d,0,h,m,i,c,r),o=Qt(p,t,o,d,1,h,m,a,g,r)),h=m,i=c,a=g,l=u}}function Qt(f,t,e,s,n,r,l,h,i,a){if(f=="stepped")return t.setStepped(s),e;const o=n<<2,d=f[o],u=f[o+1]*a,m=f[o+2],c=f[o+3]*a;return t.setBezier(e,s,n,r,h,d,u,m,c,l,i),e+1}function z(f,t,e){return f[t]!==void 0?f[t]:e}var Jp=Object.freeze({__proto__:null,AlphaTimeline:Iu,Animation:Ih,AnimationState:Np,AnimationStateAdapter:EA,AnimationStateData:Up,AtlasAttachmentLoader:XA,Attachment:fu,AttachmentTimeline:Qa,Bone:Ou,BoneData:Wu,BoundingBoxAttachment:Pp,ClippingAttachment:Rp,ConstraintData:Yh,CurveTimeline:fr,CurveTimeline1:mr,CurveTimeline2:kh,DeformTimeline:Ru,DrawOrderTimeline:Eo,Event:Uu,EventData:qu,EventQueue:_p,EventTimeline:Ph,EventType:Dp,IkConstraint:qp,IkConstraintData:zu,IkConstraintTimeline:Yu,JitterEffect:wA,MeshAttachment:Eh,PathAttachment:Pl,PathConstraint:zp,PathConstraintData:Gu,PathConstraintMixTimeline:$u,PathConstraintPositionTimeline:Bu,PathConstraintSpacingTimeline:Xu,PointAttachment:Yp,RGB2Timeline:Pu,RGBA2Timeline:ku,RGBATimeline:Tu,RGBTimeline:Eu,RegionAttachment:pu,RotateTimeline:Yl,ScaleTimeline:yu,ScaleXTimeline:Su,ScaleYTimeline:Cu,ShearTimeline:vu,ShearXTimeline:Au,ShearYTimeline:Mu,Skeleton:Kp,SkeletonBinary:f2,SkeletonBounds:V2,SkeletonData:Hu,SkeletonJson:L2,Skin:Bh,SkinEntry:Ju,Slot:gu,SlotData:Ku,SpacingMode:gs,Spine:class extends Ep{createSkeleton(t){this.skeleton=new Kp(t),this.skeleton.updateWorldTransform(),this.stateData=new Up(t),this.state=new Np(this.stateData)}},SwirlEffect:CA,Timeline:Ke,TrackEntry:Vp,TransformConstraint:Gp,TransformConstraintData:Zu,TransformConstraintTimeline:Fu,TranslateTimeline:xu,TranslateXTimeline:bu,TranslateYTimeline:wu,VertexAttachment:Za}),W2=Object.defineProperty,U2=(f,t,e)=>t in f?W2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,tf=(f,t,e)=>U2(f,typeof t!="symbol"?t+"":t,e);let Qp=class{constructor(t){if(tf(this,"skeletonData"),tf(this,"animationToMixTime",{}),tf(this,"defaultMix",0),!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(!n)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixWith(t,e,s){if(!t)throw new Error("from cannot be null.");if(!e)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}};var q2=Object.defineProperty,z2=(f,t,e)=>t in f?q2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,no=(f,t,e)=>z2(f,typeof t!="symbol"?t+"":t,e);let G2=class{constructor(){no(this,"minX",0),no(this,"minY",0),no(this,"maxX",0),no(this,"maxY",0),no(this,"boundingBoxes",new Array),no(this,"polygons",new Array),no(this,"polygonPool",new gg(()=>mt.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,l=t.slots,h=l.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=l[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===$e.BoundingBox){const d=o;s.push(d);let u=r.obtain();u.length!=d.worldVerticesLength&&(u=mt.newFloatArray(d.worldVerticesLength)),n.push(u),d.computeWorldVertices(a,0,d.worldVerticesLength,u,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let l=0,h=r.length;l<h;l++){const i=r[l],a=i;for(let o=0,d=i.length;o<d;o+=2){const u=a[o],m=a[o+1];t=Math.min(t,u),e=Math.min(e,m),s=Math.max(s,u),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,l=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=l&&n<=l||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>l&&o<i||(o=a*(h-t)+e,o>l&&o<i))return!0;let d=(l-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let l=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[l+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[l]-d)<e&&(h=!h)}l=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let l=0,h=r.length;l<h;l++)if(this.intersectsSegmentPolygon(r[l],t,e,s,n))return this.boundingBoxes[l];return null}intersectsSegmentPolygon(t,e,s,n,r){const l=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=l[h-2],u=l[h-1];for(let m=0;m<h;m+=2){const c=l[m],g=l[m+1],p=d*g-u*c,y=d-c,w=u-g,x=i*w-a*y,b=(o*y-i*p)/x;if((b>=d&&b<=c||b>=c&&b<=d)&&(b>=e&&b<=n||b>=n&&b<=e)){const S=(o*w-a*p)/x;if((S>=u&&S<=g||S>=g&&S<=u)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=c,u=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}};var jp=Object.freeze({__proto__:null,AlphaTimeline:_c,Animation:uh,AnimationState:Mg,AnimationStateAdapter:sS,AnimationStateData:Qp,AtlasAttachmentLoader:jc,Attachment:Ac,AttachmentTimeline:Da,Bone:ed,BoneData:id,BoundingBoxAttachment:Fg,ClippingAttachment:Bg,ConstraintData:xh,CurveTimeline:nr,CurveTimeline1:rr,CurveTimeline2:fh,DeformTimeline:Oc,DrawOrderTimeline:wo,Event:sd,EventData:hd,EventQueue:Eg,EventTimeline:mh,EventType:Ig,IkConstraint:Vg,IkConstraintData:ad,IkConstraintTimeline:Wc,MeshAttachment:ph,PathAttachment:bl,PathConstraint:$g,PathConstraintData:td,PathConstraintMixTimeline:Gc,PathConstraintPositionTimeline:qc,PathConstraintSpacingTimeline:zc,PointAttachment:Xg,RGB2Timeline:Lc,RGBA2Timeline:Dc,RGBATimeline:Nc,RGBTimeline:Vc,RegionAttachment:Mc,RotateTimeline:gl,ScaleTimeline:Rc,ScaleXTimeline:Yc,ScaleYTimeline:Fc,Sequence:Tc,SequenceMode:Dr,SequenceModeValues:Ec,SequenceTimeline:Hc,ShearTimeline:Bc,ShearXTimeline:Xc,ShearYTimeline:$c,Skeleton:Lg,SkeletonBinary:cd,SkeletonBounds:class extends G2{},SkeletonData:nd,SkeletonJson:Wg,Skin:wh,SkinEntry:ld,Slot:Ng,SlotData:rd,SpacingMode:fs,Spine:class extends yg{createSkeleton(t){this.skeleton=new Lg(t),this.skeleton.updateWorldTransform(),this.stateData=new Qp(t),this.state=new Mg(this.stateData)}},Timeline:Pe,TrackEntry:Tg,TransformConstraint:_g,TransformConstraintData:od,TransformConstraintTimeline:Uc,TranslateTimeline:Ic,TranslateXTimeline:kc,TranslateYTimeline:Pc,VertexAttachment:_r});let H2=class extends zf{createSkeleton(t){const e=Uo(t.version||t.spine.version);let s=null;if(e===Js.VER37&&(s=Xv),e===Js.VER38&&(s=wp),e===Js.VER40&&(s=Jp),e===Js.VER41&&(s=jp),e===Js.VER42&&(s=pp),!s){const n=`Cant detect version of spine model ${t.version}`;console.error(n)}console.log("version ",e,t,s),this.skeleton=new s.Skeleton(t),this.skeleton.updateWorldTransform(e===Js.VER42&&Uh.update),this.stateData=new s.AnimationStateData(t),this.state=new s.AnimationState(this.stateData),this.skeleton.setToSetupPose()}};new TC().installLoader();var Xn=(f=>(f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping",f))(Xn||{});let K2=class{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<7,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<14,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<21,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}};var t0=(f=>(f[f.setup=0]="setup",f[f.first=1]="first",f[f.replace=2]="replace",f[f.add=3]="add",f))(t0||{}),e0=(f=>(f[f.mixIn=0]="mixIn",f[f.mixOut=1]="mixOut",f))(e0||{}),s0=(f=>(f[f.Fixed=0]="Fixed",f[f.Percent=1]="Percent",f))(s0||{}),n0=(f=>(f[f.Tangent=0]="Tangent",f[f.Chain=1]="Chain",f[f.ChainScale=2]="ChainScale",f))(n0||{}),r0=(f=>(f[f.Normal=0]="Normal",f[f.OnlyTranslation=1]="OnlyTranslation",f[f.NoRotationOrReflection=2]="NoRotationOrReflection",f[f.NoScale=3]="NoScale",f[f.NoScaleOrReflection=4]="NoScaleOrReflection",f))(r0||{}),ef=(f=>(f[f.none=0]="none",f[f.reset=1]="reset",f[f.update=2]="update",f[f.pose=3]="pose",f))(ef||{}),Z2=Object.defineProperty,J2=(f,t,e)=>t in f?Z2(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ce=(f,t,e)=>J2(f,typeof t!="symbol"?t+"":t,e);class Q2{constructor(){ce(this,"array",new Array)}add(t){const e=this.contains(t);return this.array[t|0]=t|0,!e}contains(t){return this.array[t|0]!=null}remove(t){this.array[t|0]=void 0}clear(){this.array.length=0}}let j2=class{constructor(){ce(this,"entries",{}),ce(this,"size",0)}add(t){const e=this.entries[t];return this.entries[t]=!0,e?!1:(this.size++,!0)}addAll(t){const e=this.size;for(let s=0,n=t.length;s<n;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}};const wr=class ab{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new ab().setFromString(t)}};ce(wr,"WHITE",new wr(1,1,1,1)),ce(wr,"RED",new wr(1,0,0,1)),ce(wr,"GREEN",new wr(0,1,0,1)),ce(wr,"BLUE",new wr(0,0,1,1)),ce(wr,"MAGENTA",new wr(1,0,1,1));let tM=wr;const vn=class Ql{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*Ql.degRad)}static sinDeg(t){return Math.sin(t*Ql.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*Ql.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return Ql.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};ce(vn,"PI",3.1415927),ce(vn,"PI2",vn.PI*2),ce(vn,"invPI2",1/vn.PI2),ce(vn,"radiansToDegrees",180/vn.PI),ce(vn,"radDeg",vn.radiansToDegrees),ce(vn,"degreesToRadians",vn.PI/180),ce(vn,"degRad",vn.degreesToRadians);let i0=vn;class a0{apply(t,e,s){return t+(e-t)*this.applyInternal(s)}}class o0 extends a0{constructor(t){super(),ce(this,"power",2),this.power=t}applyInternal(t){return t<=.5?Math.pow(t*2,this.power)/2:Math.pow((t-1)*2,this.power)/(this.power%2==0?-2:2)+1}}class eM extends o0{applyInternal(t){return Math.pow(t-1,this.power)*(this.power%2==0?-1:1)+1}}const l0=class Lo{static arrayCopy(t,e,s,n,r){for(let l=e,h=n;l<e+r;l++,h++)s[h]=t[l]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Lo.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Lo.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Lo.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Lo.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Lo.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};ce(l0,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let sf=l0;class sM{static logBones(t){for(let e=0;e<t.bones.length;e++){const s=t.bones[e],n=s.matrix;console.log(`${s.data.name}, ${n.a}, ${n.b}, ${n.c}, ${n.d}, ${n.tx}, ${n.ty}`)}}}let h0=class{constructor(t){ce(this,"items",new Array),ce(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}},nM=class{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}};class rM{constructor(){ce(this,"maxDelta",.064),ce(this,"framesPerSecond",0),ce(this,"delta",0),ce(this,"totalTime",0),ce(this,"lastTime",Date.now()/1e3),ce(this,"frameCount",0),ce(this,"frameTime",0)}update(){const t=Date.now()/1e3;this.delta=t-this.lastTime,this.frameTime+=this.delta,this.totalTime+=this.delta,this.delta>this.maxDelta&&(this.delta=this.maxDelta),this.lastTime=t,this.frameCount++,this.frameTime>1&&(this.framesPerSecond=this.frameCount/this.frameTime,this.frameTime=0,this.frameCount=0)}}class iM{constructor(t=32){ce(this,"values"),ce(this,"addedValues",0),ce(this,"lastValue",0),ce(this,"mean",0),ce(this,"dirty",!0),this.values=new Array(t)}hasEnoughData(){return this.addedValues>=this.values.length}addValue(t){this.addedValues<this.values.length&&this.addedValues++,this.values[this.lastValue++]=t,this.lastValue>this.values.length-1&&(this.lastValue=0),this.dirty=!0}getMean(){if(this.hasEnoughData()){if(this.dirty){let t=0;for(let e=0;e<this.values.length;e++)t+=this.values[e];this.mean=t/this.values.length,this.dirty=!1}return this.mean}return 0}}var aM=Object.defineProperty,oM=(f,t,e)=>t in f?aM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ro=(f,t,e)=>oM(f,typeof t!="symbol"?t+"":t,e);let c0=class{constructor(){ro(this,"minX",0),ro(this,"minY",0),ro(this,"maxX",0),ro(this,"maxY",0),ro(this,"boundingBoxes",new Array),ro(this,"polygons",new Array),ro(this,"polygonPool",new h0(()=>sf.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,l=t.slots,h=l.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=l[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===Xn.BoundingBox){const d=o;s.push(d);let u=r.obtain();u.length!=d.worldVerticesLength&&(u=sf.newFloatArray(d.worldVerticesLength)),n.push(u),d.computeWorldVertices(a,0,d.worldVerticesLength,u,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let l=0,h=r.length;l<h;l++){const i=r[l],a=i;for(let o=0,d=i.length;o<d;o+=2){const u=a[o],m=a[o+1];t=Math.min(t,u),e=Math.min(e,m),s=Math.max(s,u),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,l=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=l&&n<=l||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>l&&o<i||(o=a*(h-t)+e,o>l&&o<i))return!0;let d=(l-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let l=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[l+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[l]-d)<e&&(h=!h)}l=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let l=0,h=r.length;l<h;l++)if(this.intersectsSegmentPolygon(r[l],t,e,s,n))return this.boundingBoxes[l];return null}intersectsSegmentPolygon(t,e,s,n,r){const l=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=l[h-2],u=l[h-1];for(let m=0;m<h;m+=2){const c=l[m],g=l[m+1],p=d*g-u*c,y=d-c,w=u-g,x=i*w-a*y,b=(o*y-i*p)/x;if((b>=d&&b<=c||b>=c&&b<=d)&&(b>=e&&b<=n||b>=n&&b<=e)){const S=(o*w-a*p)/x;if((S>=u&&S<=g||S>=g&&S<=u)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=c,u=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}};var lM=Object.defineProperty,hM=(f,t,e)=>t in f?lM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Xl=(f,t,e)=>hM(f,typeof t!="symbol"?t+"":t,e);function nf(f){switch(f.toLowerCase()){case"nearest":return 9728;case"linear":return 9729;case"mipmap":return 9987;case"mipmapnearestnearest":return 9984;case"mipmaplinearnearest":return 9985;case"mipmapnearestlinear":return 9986;case"mipmaplinearlinear":return 9987;default:throw new Error(`Unknown texture filter ${f}`)}}function cM(f){switch(f.toLowerCase()){case"mirroredtepeat":return 33648;case"clamptoedge":return 33071;case"repeat":return 10497;default:throw new Error(`Unknown texture wrap ${f}`)}}var na=(f=>(f[f.Nearest=9728]="Nearest",f[f.Linear=9729]="Linear",f[f.MipMap=9987]="MipMap",f[f.MipMapNearestNearest=9984]="MipMapNearestNearest",f[f.MipMapLinearNearest=9985]="MipMapLinearNearest",f[f.MipMapNearestLinear=9986]="MipMapNearestLinear",f[f.MipMapLinearLinear=9987]="MipMapLinearLinear",f))(na||{}),ra=(f=>(f[f.MirroredRepeat=33648]="MirroredRepeat",f[f.ClampToEdge=33071]="ClampToEdge",f[f.Repeat=10497]="Repeat",f))(ra||{});let Xh=class{constructor(){Xl(this,"texture"),Xl(this,"size",null),Xl(this,"names",null),Xl(this,"values",null),Xl(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}};var dM=Object.defineProperty,uM=(f,t,e)=>t in f?dM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,xe=(f,t,e)=>uM(f,typeof t!="symbol"?t+"":t,e);class fM{constructor(){xe(this,"x",0),xe(this,"y",0),xe(this,"width",0),xe(this,"height",0),xe(this,"offsetX",0),xe(this,"offsetY",0),xe(this,"originalWidth",0),xe(this,"originalHeight",0),xe(this,"rotate",0),xe(this,"index",0)}}class mM{constructor(t,e,s){xe(this,"pages",new Array),xe(this,"regions",new Array),t&&this.addSpineAtlas(t,e,s)}addTexture(t,e){const s=this.pages;let n=null;for(let l=0;l<s.length;l++)if(s[l].baseTexture===e.baseTexture){n=s[l];break}if(n===null){n=new rf,n.name="texturePage";const l=e.baseTexture;n.width=l.realWidth,n.height=l.realHeight,n.baseTexture=l,n.minFilter=n.magFilter=na.Nearest,n.uWrap=ra.ClampToEdge,n.vWrap=ra.ClampToEdge,s.push(n)}const r=new af;return r.name=t,r.page=n,r.texture=e,r.index=-1,this.regions.push(r),r}addTextureHash(t,e){for(const s in t)t.hasOwnProperty(s)&&this.addTexture(e&&s.indexOf(".")!==-1?s.substr(0,s.lastIndexOf(".")):s,t[s])}addSpineAtlas(t,e,s){return this.load(t,e,s)}load(t,e,s){if(e==null)throw new Error("textureLoader cannot be null.");const n=new gM(t),r=new Array(4);let l=null;const h={};let i=null;h.size=()=>{l.width=parseInt(r[1]),l.height=parseInt(r[2])},h.format=()=>{},h.filter=()=>{l.minFilter=nf(r[1]),l.magFilter=nf(r[2])},h.repeat=()=>{r[1].indexOf("x")!=-1&&(l.uWrap=ra.Repeat),r[1].indexOf("y")!=-1&&(l.vWrap=ra.Repeat)},h.pma=()=>{l.pma=r[1]=="true"};const a={};a.xy=()=>{i.x=parseInt(r[1]),i.y=parseInt(r[2])},a.size=()=>{i.width=parseInt(r[1]),i.height=parseInt(r[2])},a.bounds=()=>{i.x=parseInt(r[1]),i.y=parseInt(r[2]),i.width=parseInt(r[3]),i.height=parseInt(r[4])},a.offset=()=>{i.offsetX=parseInt(r[1]),i.offsetY=parseInt(r[2])},a.orig=()=>{i.originalWidth=parseInt(r[1]),i.originalHeight=parseInt(r[2])},a.offsets=()=>{i.offsetX=parseInt(r[1]),i.offsetY=parseInt(r[2]),i.originalWidth=parseInt(r[3]),i.originalHeight=parseInt(r[4])},a.rotate=()=>{const u=r[1];let m=0;u.toLocaleLowerCase()=="true"?m=6:u.toLocaleLowerCase()=="false"?m=0:m=(720-parseFloat(u))%360/45,i.rotate=m},a.index=()=>{i.index=parseInt(r[1])};let o=n.readLine();for(;o!=null&&o.trim().length==0;)o=n.readLine();for(;!(o==null||o.trim().length==0||n.readEntry(r,o)==0);)o=n.readLine();const d=()=>{for(;;){if(o==null)return s&&s(this);if(o.trim().length==0)l=null,o=n.readLine();else if(l===null){for(l=new rf,l.name=o.trim();n.readEntry(r,o=n.readLine())!=0;){const u=h[r[0]];u&&u()}this.pages.push(l),e(l.name,u=>{if(u===null)return this.pages.splice(this.pages.indexOf(l),1),s&&s(null);l.baseTexture=u,l.pma&&(u.alphaMode=V.ALPHA_MODES.PMA),u.valid||u.setSize(l.width,l.height),l.setFilters(),(!l.width||!l.height)&&(l.width=u.realWidth,l.height=u.realHeight,(!l.width||!l.height)&&console.log(`ERROR spine atlas page ${l.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`)),d()});break}else{i=new fM;const u=new af;u.name=o,u.page=l;let m=null,c=null;for(;;){const b=n.readEntry(r,o=n.readLine());if(b==0)break;const S=a[r[0]];if(S)S();else{m==null&&(m=[],c=[]),m.push(r[0]);const C=[];for(let v=0;v<b;v++)C.push(parseInt(r[v+1]));c.push(C)}}i.originalWidth==0&&i.originalHeight==0&&(i.originalWidth=i.width,i.originalHeight=i.height);const g=l.baseTexture.resolution;i.x/=g,i.y/=g,i.width/=g,i.height/=g,i.originalWidth/=g,i.originalHeight/=g,i.offsetX/=g,i.offsetY/=g;const p=i.rotate%4!==0,y=new V.Rectangle(i.x,i.y,p?i.height:i.width,p?i.width:i.height),w=new V.Rectangle(0,0,i.originalWidth,i.originalHeight),x=new V.Rectangle(i.offsetX,i.originalHeight-i.height-i.offsetY,i.width,i.height);u.texture=new V.Texture(u.page.baseTexture,y,w,x,i.rotate),u.index=i.index,u.texture.updateUvs(),this.regions.push(u)}}};d()}findRegion(t){for(let e=0;e<this.regions.length;e++)if(this.regions[e].name==t)return this.regions[e];return null}dispose(){for(let t=0;t<this.pages.length;t++)this.pages[t].baseTexture.dispose()}}class gM{constructor(t){xe(this,"lines"),xe(this,"index",0),this.lines=t.split(/\r\n|\r|\n/)}readLine(){return this.index>=this.lines.length?null:this.lines[this.index++]}readEntry(t,e){if(e==null||(e=e.trim(),e.length==0))return 0;const s=e.indexOf(":");if(s==-1)return 0;t[0]=e.substr(0,s).trim();for(let n=1,r=s+1;;n++){const l=e.indexOf(",",r);if(l==-1)return t[n]=e.substr(r).trim(),n;if(t[n]=e.substr(r,l-r).trim(),r=l+1,n==4)return 4}}}class rf{constructor(){xe(this,"name"),xe(this,"minFilter",na.Nearest),xe(this,"magFilter",na.Nearest),xe(this,"uWrap",ra.ClampToEdge),xe(this,"vWrap",ra.ClampToEdge),xe(this,"baseTexture"),xe(this,"width"),xe(this,"height"),xe(this,"pma")}setFilters(){const t=this.baseTexture,e=this.minFilter;e==na.Linear?t.scaleMode=V.SCALE_MODES.LINEAR:this.minFilter==na.Nearest?t.scaleMode=V.SCALE_MODES.NEAREST:(t.mipmap=V.MIPMAP_MODES.POW2,e==na.MipMapNearestNearest?t.scaleMode=V.SCALE_MODES.NEAREST:t.scaleMode=V.SCALE_MODES.LINEAR)}}class af extends Xh{constructor(){super(...arguments),xe(this,"page"),xe(this,"name"),xe(this,"index")}}var of=(f=>(f[f.UNKNOWN=0]="UNKNOWN",f[f.VER37=37]="VER37",f[f.VER38=38]="VER38",f[f.VER40=40]="VER40",f[f.VER41=41]="VER41",f[f.VER42=42]="VER42",f))(of||{});function d0(f){const t=f.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const lf={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var pM=Object.defineProperty,xM=(f,t,e)=>t in f?pM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,$s=(f,t,e)=>xM(f,typeof t!="symbol"?t+"":t,e);const ia=[0,0,0];let u0=class extends $i.Sprite{constructor(){super(...arguments),$s(this,"region",null),$s(this,"attachment",null)}},f0=class extends Xi.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),$s(this,"region",null),$s(this,"attachment",null)}};const m0=class ob extends Et.Container{constructor(t){if(super(),$s(this,"tintRgb"),$s(this,"spineData"),$s(this,"skeleton"),$s(this,"stateData"),$s(this,"state"),$s(this,"slotContainers"),$s(this,"tempClipContainers"),$s(this,"localDelayLimit"),$s(this,"_autoUpdate"),$s(this,"_visible"),$s(this,"_debug"),$s(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),l=this.newContainer();if(this.slotContainers.push(l),this.addChild(l),this.tempClipContainers.push(null),!!r)if(r.type===Xn.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,l.addChild(i)}else if(r.type===Xn.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,l.addChild(h)}else r.type===Xn.Clipping&&(this.createGraphics(n,r),l.addChild(n.clippingContainer),l.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?ob.prototype.autoUpdateTransform:Et.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=V.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:lf.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=d0(this.spineData.version||this.spineData.spine.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===of.VER42&&ef.update);const n=this.skeleton.slots,r=this.color;let l=null,h=null;r?(l=r.light,h=r.dark):l=this.tintRgb;for(let u=0,m=n.length;u<m;u++){const c=n[u],g=c.getAttachment(),p=this.slotContainers[u];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(c,g);let w=g.region;const x=g.color;switch(g!=null&&g.type){case Xn.Region:if(p.transform.setFromMatrix(c.bone.matrix),w=g.region,c.currentMesh&&(c.currentMesh.visible=!1,c.currentMesh=null,c.currentMeshId=void 0,c.currentMeshName=void 0),!w){c.currentSprite&&(c.currentSprite.renderable=!1);break}if(!c.currentSpriteName||c.currentSpriteName!==g.name){const C=g.name;if(c.currentSprite&&(c.currentSprite.visible=!1),c.sprites=c.sprites||{},c.sprites[C]!==void 0)c.sprites[C].visible=!0;else{const v=this.createSprite(c,g,C);p.addChild(v)}c.currentSprite=c.sprites[C],c.currentSpriteName=C}c.currentSprite.renderable=!0,c.hackRegion||this.setSpriteRegion(g,c.currentSprite,w),c.currentSprite.color?y=c.currentSprite.color:(ia[0]=l[0]*c.color.r*x.r,ia[1]=l[1]*c.color.g*x.g,ia[2]=l[2]*c.color.b*x.b,c.currentSprite.tint=V.utils.rgb2hex(ia)),c.currentSprite.blendMode=c.blendMode;break;case Xn.Mesh:if(c.currentSprite){c.currentSprite.visible=!1,c.currentSprite=null,c.currentSpriteName=void 0;const C=new V.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){c.currentMesh&&(c.currentMesh.renderable=!1);break}const S=g.id;if(c.currentMeshId===void 0||c.currentMeshId!==S){const C=S;if(c.currentMesh&&(c.currentMesh.visible=!1),c.meshes=c.meshes||{},c.meshes[C]!==void 0)c.meshes[C].visible=!0;else{const v=this.createMesh(c,g);p.addChild(v)}c.currentMesh=c.meshes[C],c.currentMeshName=g.name,c.currentMeshId=C}c.currentMesh.renderable=!0,g.computeWorldVerticesOld(c,c.currentMesh.vertices),c.currentMesh.color?y=c.currentMesh.color:(ia[0]=l[0]*c.color.r*x.r,ia[1]=l[1]*c.color.g*x.g,ia[2]=l[2]*c.color.b*x.b,c.currentMesh.tint=V.utils.rgb2hex(ia)),c.currentMesh.blendMode=c.blendMode,c.hackRegion||this.setMeshRegion(g,c.currentMesh,w);break;case Xn.Clipping:c.currentGraphics||(this.createGraphics(c,g),p.addChild(c.clippingContainer),p.addChild(c.currentGraphics)),this.updateGraphics(c,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let b=c.color.r*x.r,S=c.color.g*x.g,C=c.color.b*x.b;y.setLight(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C)),c.darkColor?(b=c.darkColor.r,S=c.darkColor.g,C=c.darkColor.b):(b=0,S=0,C=0),y.setDark(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C))}p.alpha=c.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let u=0,m=i.length;u<m;u++){const c=n[i[u].data.index],g=this.slotContainers[i[u].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),c.currentGraphics&&c.getAttachment())o=c.clippingContainer,a=c.getAttachment(),o.children.length=0,this.children[u]=g,a.endSlot===c.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[u];p||(p=this.tempClipContainers[u]=this.newContainer(),p.visible=!1),this.children[u]=p,g.parent=null,o.addChild(g),a.endSlot==c.data&&(o.renderable=!0,o=null,a=null)}else this.children[u]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*i0.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){if(lf.GLOBAL_AUTO_UPDATE){this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}else this.lastTime=0;Et.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,l=this.newSprite(r);return l.anchor.set(.5),n&&this.setSpriteRegion(e,l,e.region),t.sprites=t.sprites||{},t.sprites[s]=l,l}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),V.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new V.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let l=r.region;return e?(l=new Xh,l.texture=e,l.size=s,n.hackRegion=l,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,l):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,l),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),l=this.skeleton.getAttachmentByName(t,e);l.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=l.region;return s?(a=new Xh,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Et.Container}newSprite(t){return new u0(t)}newGraphics(){return new le.Graphics}newMesh(t,e,s,n,r){return new f0(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let l=0,h=this.skeleton.slots.length;l<h;l++){const i=this.skeleton.slots[l],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};$s(m0,"clippingPolygon",[]);let g0=m0;Object.defineProperty(g0.prototype,"visible",{get(){return this._visible},set(f){f!==this._visible&&(this._visible=f,f&&(this.lastTime=0))}});var bM=Object.defineProperty,wM=(f,t,e)=>t in f?bM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,De=(f,t,e)=>wM(f,typeof t!="symbol"?t+"":t,e);class yM{constructor(){De(this,"registeredSpines",new Map),De(this,"drawDebug",!0),De(this,"drawMeshHull",!0),De(this,"drawMeshTriangles",!0),De(this,"drawBones",!0),De(this,"drawPaths",!0),De(this,"drawBoundingBoxes",!0),De(this,"drawClipping",!0),De(this,"drawRegionAttachments",!0),De(this,"lineWidth",1),De(this,"regionAttachmentsColor",30975),De(this,"meshHullColor",30975),De(this,"meshTrianglesColor",16763904),De(this,"clippingPolygonColor",16711935),De(this,"boundingBoxesRectColor",65280),De(this,"boundingBoxesPolygonColor",65280),De(this,"boundingBoxesCircleColor",65280),De(this,"pathsCurveColor",16711680),De(this,"pathsLineColor",16711935),De(this,"skeletonXYColor",16711680),De(this,"bonesColor",61132)}registerSpine(t){this.registeredSpines.has(t)&&console.warn("SpineDebugRenderer.registerSpine() - this spine is already registered!",t);const e={parentDebugContainer:new Et.Container,bones:new Et.Container,skeletonXY:new le.Graphics,regionAttachmentsShape:new le.Graphics,meshTrianglesLine:new le.Graphics,meshHullLine:new le.Graphics,clippingPolygon:new le.Graphics,boundingBoxesRect:new le.Graphics,boundingBoxesCircle:new le.Graphics,boundingBoxesPolygon:new le.Graphics,pathsCurve:new le.Graphics,pathsLine:new le.Graphics};e.parentDebugContainer.addChild(e.bones),e.parentDebugContainer.addChild(e.skeletonXY),e.parentDebugContainer.addChild(e.regionAttachmentsShape),e.parentDebugContainer.addChild(e.meshTrianglesLine),e.parentDebugContainer.addChild(e.meshHullLine),e.parentDebugContainer.addChild(e.clippingPolygon),e.parentDebugContainer.addChild(e.boundingBoxesRect),e.parentDebugContainer.addChild(e.boundingBoxesCircle),e.parentDebugContainer.addChild(e.boundingBoxesPolygon),e.parentDebugContainer.addChild(e.pathsCurve),e.parentDebugContainer.addChild(e.pathsLine),t.addChild(e.parentDebugContainer),this.registeredSpines.set(t,e)}renderDebug(t){this.registeredSpines.has(t)||this.registerSpine(t);const e=this.registeredSpines.get(t);e.skeletonXY.clear(),e.regionAttachmentsShape.clear(),e.meshTrianglesLine.clear(),e.meshHullLine.clear(),e.clippingPolygon.clear(),e.boundingBoxesRect.clear(),e.boundingBoxesCircle.clear(),e.boundingBoxesPolygon.clear(),e.pathsCurve.clear(),e.pathsLine.clear();for(let r=e.bones.children.length;r>0;r--)e.bones.children[r-1].destroy({children:!0,texture:!0,baseTexture:!0});const s=t.scale.x||t.scale.y||1,n=this.lineWidth/s;this.drawBones&&this.drawBonesFunc(t,e,n,s),this.drawPaths&&this.drawPathsFunc(t,e,n),this.drawBoundingBoxes&&this.drawBoundingBoxesFunc(t,e,n),this.drawClipping&&this.drawClippingFunc(t,e,n),(this.drawMeshHull||this.drawMeshTriangles)&&this.drawMeshHullAndMeshTriangles(t,e,n),this.drawRegionAttachments&&this.drawRegionAttachmentsFunc(t,e,n)}drawBonesFunc(t,e,s,n){const r=t.skeleton,l=r.x,h=r.y,i=r.bones;e.skeletonXY.lineStyle(s,this.skeletonXYColor,1);for(let o=0,d=i.length;o<d;o++){const u=i[o],m=u.data.length,c=l+u.matrix.tx,g=h+u.matrix.ty,p=l+m*u.matrix.a+u.matrix.tx,y=h+m*u.matrix.b+u.matrix.ty;if(u.data.name==="root"||u.data.parent===null)continue;const w=Math.abs(c-p),x=Math.abs(g-y),b=Math.pow(w,2),S=x,C=Math.pow(x,2),v=Math.sqrt(b+C),A=Math.pow(v,2),M=Math.PI/180,I=Math.acos((A+C-b)/(2*S*v))||0;if(v===0)continue;const E=new le.Graphics;e.bones.addChild(E);const P=v/50/n;E.beginFill(this.bonesColor,1),E.drawPolygon(0,0,0-P,v-P*3,0,v-P,0+P,v-P*3),E.endFill(),E.x=c,E.y=g,E.pivot.y=v;let R=0;c<p&&g<y?R=-I+180*M:c>p&&g<y?R=180*M+I:c>p&&g>y?R=-I:c<p&&g>y?R=I:g===y&&c<p?R=90*M:g===y&&c>p?R=-90*M:c===p&&g<y?R=180*M:c===p&&g>y&&(R=0),E.rotation=R,E.lineStyle(s+P/2.4,this.bonesColor,1),E.beginFill(0,.6),E.drawCircle(0,v,P*1.2),E.endFill()}const a=s*3;e.skeletonXY.moveTo(l-a,h-a),e.skeletonXY.lineTo(l+a,h+a),e.skeletonXY.moveTo(l+a,h-a),e.skeletonXY.lineTo(l-a,h+a)}drawRegionAttachmentsFunc(t,e,s){const r=t.skeleton.slots;e.regionAttachmentsShape.lineStyle(s,this.regionAttachmentsColor,1);for(let l=0,h=r.length;l<h;l++){const i=r[l],a=i.getAttachment();if(a==null||a.type!==Xn.Region)continue;const o=a,d=new Float32Array(8);o.updateOffset&&o.updateOffset(),o.computeWorldVertices(i,d,0,2),e.regionAttachmentsShape.drawPolygon(Array.from(d.slice(0,8)))}}drawMeshHullAndMeshTriangles(t,e,s){const r=t.skeleton.slots;e.meshHullLine.lineStyle(s,this.meshHullColor,1),e.meshTrianglesLine.lineStyle(s,this.meshTrianglesColor,1);for(let l=0,h=r.length;l<h;l++){const i=r[l];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||a.type!==Xn.Mesh)continue;const o=a,d=new Float32Array(o.worldVerticesLength),u=o.triangles;let m=o.hullLength;if(o.computeWorldVertices(i,0,o.worldVerticesLength,d,0,2),this.drawMeshTriangles)for(let c=0,g=u.length;c<g;c+=3){const p=u[c]*2,y=u[c+1]*2,w=u[c+2]*2;e.meshTrianglesLine.moveTo(d[p],d[p+1]),e.meshTrianglesLine.lineTo(d[y],d[y+1]),e.meshTrianglesLine.lineTo(d[w],d[w+1])}if(this.drawMeshHull&&m>0){m=(m>>1)*2;let c=d[m-2],g=d[m-1];for(let p=0,y=m;p<y;p+=2){const w=d[p],x=d[p+1];e.meshHullLine.moveTo(w,x),e.meshHullLine.lineTo(c,g),c=w,g=x}}}}drawClippingFunc(t,e,s){const r=t.skeleton.slots;e.clippingPolygon.lineStyle(s,this.clippingPolygonColor,1);for(let l=0,h=r.length;l<h;l++){const i=r[l];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||a.type!==Xn.Clipping)continue;const o=a,d=o.worldVerticesLength,u=new Float32Array(d);o.computeWorldVertices(i,0,d,u,0,2),e.clippingPolygon.drawPolygon(Array.from(u))}}drawBoundingBoxesFunc(t,e,s){e.boundingBoxesRect.lineStyle(s,this.boundingBoxesRectColor,5);const n=new c0;n.update(t.skeleton,!0),e.boundingBoxesRect.drawRect(n.minX,n.minY,n.getWidth(),n.getHeight());const r=n.polygons,l=(h,i,a)=>{if(e.boundingBoxesPolygon.lineStyle(s,this.boundingBoxesPolygonColor,1),e.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor,.1),a<3)throw new Error("Polygon must contain at least 3 vertices");const o=[],d=s*2;for(let u=0,m=h.length;u<m;u+=2){const c=h[u],g=h[u+1];e.boundingBoxesCircle.lineStyle(0),e.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor),e.boundingBoxesCircle.drawCircle(c,g,d),e.boundingBoxesCircle.endFill(),o.push(c,g)}e.boundingBoxesPolygon.drawPolygon(o),e.boundingBoxesPolygon.endFill()};for(let h=0,i=r.length;h<i;h++){const a=r[h];l(a,0,a.length)}}drawPathsFunc(t,e,s){const r=t.skeleton.slots;e.pathsCurve.lineStyle(s,this.pathsCurveColor,1),e.pathsLine.lineStyle(s,this.pathsLineColor,1);for(let l=0,h=r.length;l<h;l++){const i=r[l];if(!i.bone.active)continue;const a=i.getAttachment();if(a==null||a.type!==Xn.Path)continue;const o=a;let d=o.worldVerticesLength;const u=new Float32Array(d);o.computeWorldVertices(i,0,d,u,0,2);let m=u[2],c=u[3],g=0,p=0;if(o.closed){const y=u[0],w=u[1],x=u[d-2],b=u[d-1];g=u[d-4],p=u[d-3],e.pathsCurve.moveTo(m,c),e.pathsCurve.bezierCurveTo(y,w,x,b,g,p),e.pathsLine.moveTo(m,c),e.pathsLine.lineTo(y,w),e.pathsLine.moveTo(g,p),e.pathsLine.lineTo(x,b)}d-=4;for(let y=4;y<d;y+=6){const w=u[y],x=u[y+1],b=u[y+2],S=u[y+3];g=u[y+4],p=u[y+5],e.pathsCurve.moveTo(m,c),e.pathsCurve.bezierCurveTo(w,x,b,S,g,p),e.pathsLine.moveTo(m,c),e.pathsLine.lineTo(w,x),e.pathsLine.moveTo(g,p),e.pathsLine.lineTo(b,S),m=g,c=p}}}unregisterSpine(t){this.registeredSpines.has(t)||console.warn("SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!",t),this.registeredSpines.get(t).parentDebugContainer.destroy({baseTexture:!0,children:!0,texture:!0}),this.registeredSpines.delete(t)}}var SM=Object.defineProperty,CM=(f,t,e)=>t in f?SM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Ns=(f,t,e)=>CM(f,typeof t!="symbol"?t+"":t,e);class p0{constructor(){Ns(this,"entries",{}),Ns(this,"size",0)}add(t){const e=this.entries[t];return this.entries[t]=!0,e?!1:(this.size++,!0)}addAll(t){const e=this.size;for(let s=0,n=t.length;s<n;s++)this.add(t[s]);return e!=this.size}contains(t){return this.entries[t]}clear(){this.entries={},this.size=0}}const yr=class lb{constructor(t=0,e=0,s=0,n=0){this.r=t,this.g=e,this.b=s,this.a=n}set(t,e,s,n){return this.r=t,this.g=e,this.b=s,this.a=n,this.clamp()}setFromColor(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}setFromString(t){return t=t.charAt(0)=="#"?t.substr(1):t,this.r=parseInt(t.substr(0,2),16)/255,this.g=parseInt(t.substr(2,2),16)/255,this.b=parseInt(t.substr(4,2),16)/255,this.a=t.length!=8?1:parseInt(t.substr(6,2),16)/255,this}add(t,e,s,n){return this.r+=t,this.g+=e,this.b+=s,this.a+=n,this.clamp()}clamp(){return this.r<0?this.r=0:this.r>1&&(this.r=1),this.g<0?this.g=0:this.g>1&&(this.g=1),this.b<0?this.b=0:this.b>1&&(this.b=1),this.a<0?this.a=0:this.a>1&&(this.a=1),this}static rgba8888ToColor(t,e){t.r=((e&4278190080)>>>24)/255,t.g=((e&16711680)>>>16)/255,t.b=((e&65280)>>>8)/255,t.a=(e&255)/255}static rgb888ToColor(t,e){t.r=((e&16711680)>>>16)/255,t.g=((e&65280)>>>8)/255,t.b=(e&255)/255}static fromString(t){return new lb().setFromString(t)}};Ns(yr,"WHITE",new yr(1,1,1,1)),Ns(yr,"RED",new yr(1,0,0,1)),Ns(yr,"GREEN",new yr(0,1,0,1)),Ns(yr,"BLUE",new yr(0,0,1,1)),Ns(yr,"MAGENTA",new yr(1,0,1,1));let Ot=yr;const An=class jl{static clamp(t,e,s){return t<e?e:t>s?s:t}static cosDeg(t){return Math.cos(t*jl.degRad)}static sinDeg(t){return Math.sin(t*jl.degRad)}static atan2Deg(t,e){return Math.atan2(t,e)*jl.degRad}static signum(t){return Math.sign(t)}static toInt(t){return t>0?Math.floor(t):Math.ceil(t)}static cbrt(t){const e=Math.pow(Math.abs(t),.3333333333333333);return t<0?-e:e}static randomTriangular(t,e){return jl.randomTriangularWith(t,e,(t+e)*.5)}static randomTriangularWith(t,e,s){const n=Math.random(),r=e-t;return n<=(s-t)/r?t+Math.sqrt(n*r*(s-t)):e-Math.sqrt((1-n)*r*(e-s))}static isPowerOfTwo(t){return t&&(t&t-1)===0}};Ns(An,"PI",3.1415927),Ns(An,"PI2",An.PI*2),Ns(An,"invPI2",1/An.PI2),Ns(An,"radiansToDegrees",180/An.PI),Ns(An,"radDeg",An.radiansToDegrees),Ns(An,"degreesToRadians",An.PI/180),Ns(An,"degRad",An.degreesToRadians);let st=An;const x0=class Oo{static arrayCopy(t,e,s,n,r){for(let l=e,h=n;l<e+r;l++,h++)s[h]=t[l]}static arrayFill(t,e,s,n){for(let r=e;r<s;r++)t[r]=n}static setArraySize(t,e,s=0){const n=t.length;if(n==e)return t;if(t.length=e,n<e)for(let r=n;r<e;r++)t[r]=s;return t}static ensureArrayCapacity(t,e,s=0){return t.length>=e?t:Oo.setArraySize(t,e,s)}static newArray(t,e){const s=new Array(t);for(let n=0;n<t;n++)s[n]=e;return s}static newFloatArray(t){if(Oo.SUPPORTS_TYPED_ARRAYS)return new Float32Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static newShortArray(t){if(Oo.SUPPORTS_TYPED_ARRAYS)return new Int16Array(t);const e=new Array(t);for(let s=0;s<e.length;s++)e[s]=0;return e}static toFloatArray(t){return Oo.SUPPORTS_TYPED_ARRAYS?new Float32Array(t):t}static toSinglePrecision(t){return Oo.SUPPORTS_TYPED_ARRAYS?Math.fround(t):t}static webkit602BugfixHelper(t,e){}static contains(t,e,s=!0){for(let n=0;n<t.length;n++)if(t[n]==e)return!0;return!1}static enumValue(t,e){return t[e[0].toUpperCase()+e.slice(1)]}};Ns(x0,"SUPPORTS_TYPED_ARRAYS",typeof Float32Array!="undefined");let pt=x0;class b0{constructor(t){Ns(this,"items",new Array),Ns(this,"instantiator"),this.instantiator=t}obtain(){return this.items.length>0?this.items.pop():this.instantiator()}free(t){t.reset&&t.reset(),this.items.push(t)}freeAll(t){for(let e=0;e<t.length;e++)this.free(t[e])}clear(){this.items.length=0}}class hf{constructor(t=0,e=0){this.x=t,this.y=e}set(t,e){return this.x=t,this.y=e,this}length(){const t=this.x,e=this.y;return Math.sqrt(t*t+e*e)}normalize(){const t=this.length();return t!=0&&(this.x/=t,this.y/=t),this}}var Le=(f=>(f[f.Region=0]="Region",f[f.BoundingBox=1]="BoundingBox",f[f.Mesh=2]="Mesh",f[f.LinkedMesh=3]="LinkedMesh",f[f.Path=4]="Path",f[f.Point=5]="Point",f[f.Clipping=6]="Clipping",f))(Le||{}),$n=(f=>(f[f.Normal=0]="Normal",f[f.OnlyTranslation=1]="OnlyTranslation",f[f.NoRotationOrReflection=2]="NoRotationOrReflection",f[f.NoScale=3]="NoScale",f[f.NoScaleOrReflection=4]="NoScaleOrReflection",f))($n||{}),w0=(f=>(f[f.none=0]="none",f[f.reset=1]="reset",f[f.update=2]="update",f[f.pose=3]="pose",f))(w0||{}),vM=Object.defineProperty,AM=(f,t,e)=>t in f?vM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,$l=(f,t,e)=>AM(f,typeof t!="symbol"?t+"":t,e);class y0{constructor(){$l(this,"texture"),$l(this,"size",null),$l(this,"names",null),$l(this,"values",null),$l(this,"renderObject",null)}get width(){const t=this.texture;return t.trim?t.trim.width:t.orig.width}get height(){const t=this.texture;return t.trim?t.trim.height:t.orig.height}get u(){return this.texture._uvs.x0}get v(){return this.texture._uvs.y0}get u2(){return this.texture._uvs.x2}get v2(){return this.texture._uvs.y2}get offsetX(){const t=this.texture;return t.trim?t.trim.x:0}get offsetY(){return this.spineOffsetY}get pixiOffsetY(){const t=this.texture;return t.trim?t.trim.y:0}get spineOffsetY(){const t=this.texture;return this.originalHeight-this.height-(t.trim?t.trim.y:0)}get originalWidth(){return this.texture.orig.width}get originalHeight(){return this.texture.orig.height}get x(){return this.texture.frame.x}get y(){return this.texture.frame.y}get rotate(){return this.texture.rotate!==0}get degrees(){return(360-this.texture.rotate*45)%360}}var S0=(f=>(f[f.UNKNOWN=0]="UNKNOWN",f[f.VER37=37]="VER37",f[f.VER38=38]="VER38",f[f.VER40=40]="VER40",f[f.VER41=41]="VER41",f[f.VER42=42]="VER42",f))(S0||{});function MM(f){const t=f.substr(0,3),e=Math.floor(Number(t)*10+.001);return t==="3.7"?37:t==="3.8"?38:t==="4.0"?40:t==="4.1"?41:t==="4.2"?42:e<37?37:0}const TM={yDown:!0,FAIL_ON_NON_EXISTING_SKIN:!1,GLOBAL_AUTO_UPDATE:!0,GLOBAL_DELAY_LIMIT:0};var EM=Object.defineProperty,IM=(f,t,e)=>t in f?EM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Vs=(f,t,e)=>IM(f,typeof t!="symbol"?t+"":t,e);const aa=[0,0,0];class kM extends $i.Sprite{constructor(){super(...arguments),Vs(this,"region",null),Vs(this,"attachment",null)}}class PM extends Xi.SimpleMesh{constructor(t,e,s,n,r){super(t,e,s,n,r),Vs(this,"region",null),Vs(this,"attachment",null)}}const C0=class hb extends Et.Container{constructor(t){if(super(),Vs(this,"tintRgb"),Vs(this,"spineData"),Vs(this,"skeleton"),Vs(this,"stateData"),Vs(this,"state"),Vs(this,"slotContainers"),Vs(this,"tempClipContainers"),Vs(this,"localDelayLimit"),Vs(this,"_autoUpdate"),Vs(this,"_visible"),Vs(this,"_debug"),Vs(this,"lastTime"),!t)throw new Error("The spineData param is required.");if(typeof t=="string")throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas("YOUR_RESOURCE_NAME") from now on.');this.spineData=t,this.createSkeleton(t),this.slotContainers=[],this.tempClipContainers=[];for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e],r=n.getAttachment(),l=this.newContainer();if(this.slotContainers.push(l),this.addChild(l),this.tempClipContainers.push(null),!!r)if(r.type===Le.Region){const h=r.name,i=this.createSprite(n,r,h);n.currentSprite=i,n.currentSpriteName=h,l.addChild(i)}else if(r.type===Le.Mesh){const h=this.createMesh(n,r);n.currentMesh=h,n.currentMeshId=r.id,n.currentMeshName=r.name,l.addChild(h)}else r.type===Le.Clipping&&(this.createGraphics(n,r),l.addChild(n.clippingContainer),l.addChild(n.currentGraphics))}this.tintRgb=new Float32Array([1,1,1]),this.autoUpdate=!0,this.visible=!0}get debug(){return this._debug}set debug(t){var e;t!=this._debug&&((e=this._debug)==null||e.unregisterSpine(this),t==null||t.registerSpine(this),this._debug=t)}get autoUpdate(){return this._autoUpdate}set autoUpdate(t){t!==this._autoUpdate&&(this._autoUpdate=t,this.updateTransform=t?hb.prototype.autoUpdateTransform:Et.Container.prototype.updateTransform)}get tint(){return V.utils.rgb2hex(this.tintRgb)}set tint(t){this.tintRgb=V.utils.hex2rgb(t,this.tintRgb)}get delayLimit(){return(typeof this.localDelayLimit!="undefined"?this.localDelayLimit:TM.GLOBAL_DELAY_LIMIT)||Number.MAX_VALUE}update(t){var d;const e=this.delayLimit,s=MM(this.spineData.version||this.spineData.spine.version);if(t>e&&(t=e),this.state.update(t),this.state.apply(this.skeleton),!this.skeleton)return;this.skeleton.updateWorldTransform(s===S0.VER42&&w0.update);const n=this.skeleton.slots,r=this.color;let l=null,h=null;r?(l=r.light,h=r.dark):l=this.tintRgb;for(let u=0,m=n.length;u<m;u++){const c=n[u],g=c.getAttachment(),p=this.slotContainers[u];if(!g){p.visible=!1;continue}let y=null;g.sequence&&g.sequence.apply(c,g);let w=g.region;const x=g.color;switch(g!=null&&g.type){case Le.Region:if(p.transform.setFromMatrix(c.bone.matrix),w=g.region,c.currentMesh&&(c.currentMesh.visible=!1,c.currentMesh=null,c.currentMeshId=void 0,c.currentMeshName=void 0),!w){c.currentSprite&&(c.currentSprite.renderable=!1);break}if(!c.currentSpriteName||c.currentSpriteName!==g.name){const C=g.name;if(c.currentSprite&&(c.currentSprite.visible=!1),c.sprites=c.sprites||{},c.sprites[C]!==void 0)c.sprites[C].visible=!0;else{const v=this.createSprite(c,g,C);p.addChild(v)}c.currentSprite=c.sprites[C],c.currentSpriteName=C}c.currentSprite.renderable=!0,c.hackRegion||this.setSpriteRegion(g,c.currentSprite,w),c.currentSprite.color?y=c.currentSprite.color:(aa[0]=l[0]*c.color.r*x.r,aa[1]=l[1]*c.color.g*x.g,aa[2]=l[2]*c.color.b*x.b,c.currentSprite.tint=V.utils.rgb2hex(aa)),c.currentSprite.blendMode=c.blendMode;break;case Le.Mesh:if(c.currentSprite){c.currentSprite.visible=!1,c.currentSprite=null,c.currentSpriteName=void 0;const C=new V.Transform;C._parentID=-1,C._worldID=p.transform._worldID,p.transform=C}if(!w){c.currentMesh&&(c.currentMesh.renderable=!1);break}const S=g.id;if(c.currentMeshId===void 0||c.currentMeshId!==S){const C=S;if(c.currentMesh&&(c.currentMesh.visible=!1),c.meshes=c.meshes||{},c.meshes[C]!==void 0)c.meshes[C].visible=!0;else{const v=this.createMesh(c,g);p.addChild(v)}c.currentMesh=c.meshes[C],c.currentMeshName=g.name,c.currentMeshId=C}c.currentMesh.renderable=!0,g.computeWorldVerticesOld(c,c.currentMesh.vertices),c.currentMesh.color?y=c.currentMesh.color:(aa[0]=l[0]*c.color.r*x.r,aa[1]=l[1]*c.color.g*x.g,aa[2]=l[2]*c.color.b*x.b,c.currentMesh.tint=V.utils.rgb2hex(aa)),c.currentMesh.blendMode=c.blendMode,c.hackRegion||this.setMeshRegion(g,c.currentMesh,w);break;case Le.Clipping:c.currentGraphics||(this.createGraphics(c,g),p.addChild(c.clippingContainer),p.addChild(c.currentGraphics)),this.updateGraphics(c,g),p.alpha=1,p.visible=!0;continue;default:p.visible=!1;continue}if(p.visible=!0,y){let b=c.color.r*x.r,S=c.color.g*x.g,C=c.color.b*x.b;y.setLight(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C)),c.darkColor?(b=c.darkColor.r,S=c.darkColor.g,C=c.darkColor.b):(b=0,S=0,C=0),y.setDark(l[0]*b+h[0]*(1-b),l[1]*S+h[1]*(1-S),l[2]*C+h[2]*(1-C))}p.alpha=c.color.a}const i=this.skeleton.drawOrder;let a=null,o=null;for(let u=0,m=i.length;u<m;u++){const c=n[i[u].data.index],g=this.slotContainers[i[u].data.index];if(o||g.parent!==null&&g.parent!==this&&(g.parent.removeChild(g),g.parent=this),c.currentGraphics&&c.getAttachment())o=c.clippingContainer,a=c.getAttachment(),o.children.length=0,this.children[u]=g,a.endSlot===c.data&&(a.endSlot=null);else if(o){let p=this.tempClipContainers[u];p||(p=this.tempClipContainers[u]=this.newContainer(),p.visible=!1),this.children[u]=p,g.parent=null,o.addChild(g),a.endSlot==c.data&&(o.renderable=!0,o=null,a=null)}else this.children[u]=g}(d=this._debug)==null||d.renderDebug(this)}setSpriteRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,e.rotation=t.rotation*st.degRad,e.position.x=t.x,e.position.y=t.y,e.alpha=t.color.a,s.size?(e.scale.x=s.size.width/s.originalWidth,e.scale.y=-s.size.height/s.originalHeight):(e.scale.x=t.scaleX*t.width/s.originalWidth,e.scale.y=-t.scaleY*t.height/s.originalHeight))}setMeshRegion(t,e,s){e.attachment===t&&e.region===s||(e.region=s,e.attachment=t,e.texture=s.texture,s.texture.updateUvs(),e.uvBuffer.update(t.regionUVs))}autoUpdateTransform(){{this.lastTime=this.lastTime||Date.now();const t=(Date.now()-this.lastTime)*.001;this.lastTime=Date.now(),this.update(t)}Et.Container.prototype.updateTransform.call(this)}createSprite(t,e,s){let n=e.region;t.hackAttachment===e&&(n=t.hackRegion);const r=n?n.texture:null,l=this.newSprite(r);return l.anchor.set(.5),n&&this.setSpriteRegion(e,l,e.region),t.sprites=t.sprites||{},t.sprites[s]=l,l}createMesh(t,e){let s=e.region;t.hackAttachment===e&&(s=t.hackRegion,t.hackAttachment=null,t.hackRegion=null);const n=this.newMesh(s?s.texture:null,new Float32Array(e.regionUVs.length),e.regionUVs,new Uint16Array(e.triangles),V.DRAW_MODES.TRIANGLES);return typeof n._canvasPadding!="undefined"&&(n._canvasPadding=1.5),n.alpha=e.color.a,n.region=e.region,s&&this.setMeshRegion(e,n,s),t.meshes=t.meshes||{},t.meshes[e.id]=n,n}createGraphics(t,e){const s=this.newGraphics(),n=new V.Polygon([]);return s.clear(),s.beginFill(16777215,1),s.drawPolygon(n),s.renderable=!1,t.currentGraphics=s,t.clippingContainer=this.newContainer(),t.clippingContainer.mask=t.currentGraphics,s}updateGraphics(t,e){const s=t.currentGraphics.geometry,n=s.graphicsData[0].shape.points,r=e.worldVerticesLength;n.length=r,e.computeWorldVertices(t,0,r,n,0,2),s.invalidate()}hackTextureBySlotIndex(t,e=null,s=null){const n=this.skeleton.slots[t];if(!n)return!1;const r=n.getAttachment();let l=r.region;return e?(l=new y0,l.texture=e,l.size=s,n.hackRegion=l,n.hackAttachment=r):(n.hackRegion=null,n.hackAttachment=null),n.currentSprite?this.setSpriteRegion(r,n.currentSprite,l):n.currentMesh&&this.setMeshRegion(r,n.currentMesh,l),!0}hackTextureBySlotName(t,e=null,s=null){const n=this.skeleton.findSlotIndex(t);return n==-1?!1:this.hackTextureBySlotIndex(n,e,s)}hackTextureAttachment(t,e,s,n=null){const r=this.skeleton.findSlotIndex(t),l=this.skeleton.getAttachmentByName(t,e);l.region.texture=s;const h=this.skeleton.slots[r];if(!h)return!1;const i=h.getAttachment();if(e===i.name){let a=l.region;return s?(a=new y0,a.texture=s,a.size=n,h.hackRegion=a,h.hackAttachment=i):(h.hackRegion=null,h.hackAttachment=null),h.currentSprite&&h.currentSprite.region!=a?(this.setSpriteRegion(i,h.currentSprite,a),h.currentSprite.region=a):h.currentMesh&&h.currentMesh.region!=a&&this.setMeshRegion(i,h.currentMesh,a),!0}return!1}newContainer(){return new Et.Container}newSprite(t){return new kM(t)}newGraphics(){return new le.Graphics}newMesh(t,e,s,n,r){return new PM(t,e,s,n,r)}transformHack(){return 1}hackAttachmentGroups(t,e,s){if(!t)return;const n=[],r=[];for(let l=0,h=this.skeleton.slots.length;l<h;l++){const i=this.skeleton.slots[l],a=i.currentSpriteName||i.currentMeshName||"",o=i.currentSprite||i.currentMesh;a.endsWith(t)?(o.parentGroup=e,r.push(o)):s&&o&&(o.parentGroup=s,n.push(o))}return[n,r]}destroy(t){this.debug=null;for(let e=0,s=this.skeleton.slots.length;e<s;e++){const n=this.skeleton.slots[e];for(const r in n.meshes)n.meshes[r].destroy(t);n.meshes=null;for(const r in n.sprites)n.sprites[r].destroy(t);n.sprites=null}for(let e=0,s=this.slotContainers.length;e<s;e++)this.slotContainers[e].destroy(t);this.spineData=null,this.skeleton=null,this.slotContainers=null,this.stateData=null,this.state=null,this.tempClipContainers=null,super.destroy(t)}};Vs(C0,"clippingPolygon",[]);let v0=C0;Object.defineProperty(v0.prototype,"visible",{get(){return this._visible},set(f){f!==this._visible&&(this._visible=f,f&&(this.lastTime=0))}});var RM=Object.defineProperty,YM=(f,t,e)=>t in f?RM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,oa=(f,t,e)=>YM(f,typeof t!="symbol"?t+"":t,e);class A0{constructor(t){if(oa(this,"name"),oa(this,"type"),!t)throw new Error("name cannot be null.");this.name=t}}const M0=class cb extends A0{constructor(t){super(t),oa(this,"id",cb.nextID++),oa(this,"bones",null),oa(this,"vertices",[]),oa(this,"worldVerticesLength",0),oa(this,"timelineAttachment",this)}computeWorldVerticesOld(t,e){this.computeWorldVertices(t,0,this.worldVerticesLength,e,0,2)}computeWorldVertices(t,e,s,n,r,l){s=r+(s>>1)*l;const h=t.bone.skeleton,i=t.deform;let a=this.vertices;const o=this.bones;if(!o){i.length>0&&(a=i);const c=t.bone.matrix,g=c.tx,p=c.ty,y=c.a,w=c.c,x=c.b,b=c.d;for(let S=e,C=r;C<s;S+=2,C+=l){const v=a[S],A=a[S+1];n[C]=v*y+A*w+g,n[C+1]=v*x+A*b+p}return}let d=0,u=0;for(let c=0;c<e;c+=2){const g=o[d];d+=g+1,u+=g}const m=h.bones;if(i.length==0)for(let c=r,g=u*3;c<s;c+=l){let p=0,y=0,w=o[d++];for(w+=d;d<w;d++,g+=3){const x=m[o[d]].matrix,b=a[g],S=a[g+1],C=a[g+2];p+=(b*x.a+S*x.c+x.tx)*C,y+=(b*x.b+S*x.d+x.ty)*C}n[c]=p,n[c+1]=y}else{const c=i;for(let g=r,p=u*3,y=u<<1;g<s;g+=l){let w=0,x=0,b=o[d++];for(b+=d;d<b;d++,p+=3,y+=2){const S=m[o[d]].matrix,C=a[p]+c[y],v=a[p+1]+c[y+1],A=a[p+2];w+=(C*S.a+v*S.c+S.tx)*A,x+=(C*S.b+v*S.d+S.ty)*A}n[g]=w,n[g+1]=x}}}copyTo(t){this.bones?(t.bones=new Array(this.bones.length),pt.arrayCopy(this.bones,0,t.bones,0,this.bones.length)):t.bones=null,this.vertices&&(t.vertices=pt.newFloatArray(this.vertices.length),pt.arrayCopy(this.vertices,0,t.vertices,0,this.vertices.length)),t.worldVerticesLength=this.worldVerticesLength,t.timelineAttachment=this.timelineAttachment}};oa(M0,"nextID",0);let gi=M0;var FM=Object.defineProperty,BM=(f,t,e)=>t in f?FM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,T0=(f,t,e)=>BM(f,typeof t!="symbol"?t+"":t,e);class cf extends gi{constructor(t){super(t),T0(this,"type",Le.BoundingBox),T0(this,"color",new Ot(1,1,1,1))}copy(){const t=new cf(this.name);return this.copyTo(t),t.color.setFromColor(this.color),t}}var XM=Object.defineProperty,$M=(f,t,e)=>t in f?XM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,df=(f,t,e)=>$M(f,typeof t!="symbol"?t+"":t,e);class uf extends gi{constructor(t){super(t),df(this,"type",Le.Clipping),df(this,"endSlot",null),df(this,"color",new Ot(.2275,.2275,.8078,1))}copy(){const t=new uf(this.name);return this.copyTo(t),t.endSlot=this.endSlot,t.color.setFromColor(this.color),t}}var NM=Object.defineProperty,VM=(f,t,e)=>t in f?NM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Nn=(f,t,e)=>VM(f,typeof t!="symbol"?t+"":t,e);class Io extends gi{constructor(t,e){super(t),Nn(this,"type",Le.Mesh),Nn(this,"region",null),Nn(this,"path"),Nn(this,"regionUVs"),Nn(this,"triangles",[]),Nn(this,"color",new Ot(1,1,1,1)),Nn(this,"width",0),Nn(this,"height",0),Nn(this,"hullLength",0),Nn(this,"edges",[]),Nn(this,"parentMesh",null),Nn(this,"sequence",null),Nn(this,"tempColor",new Ot(0,0,0,0)),this.path=e}getParentMesh(){return this.parentMesh}setParentMesh(t){this.parentMesh=t,t&&(this.bones=t.bones,this.vertices=t.vertices,this.worldVerticesLength=t.worldVerticesLength,this.regionUVs=t.regionUVs,this.triangles=t.triangles,this.hullLength=t.hullLength,this.worldVerticesLength=t.worldVerticesLength)}copy(){if(this.parentMesh)return this.newLinkedMesh();const t=new Io(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),this.copyTo(t),t.regionUVs=new Float32Array(this.regionUVs.length),pt.arrayCopy(this.regionUVs,0,t.regionUVs,0,this.regionUVs.length),t.triangles=new Array(this.triangles.length),pt.arrayCopy(this.triangles,0,t.triangles,0,this.triangles.length),t.hullLength=this.hullLength,t.sequence=this.sequence!=null?this.sequence.copy():null,this.edges&&(t.edges=new Array(this.edges.length),pt.arrayCopy(this.edges,0,t.edges,0,this.edges.length)),t.width=this.width,t.height=this.height,t}computeWorldVertices(t,e,s,n,r,l){this.sequence!=null&&this.sequence.apply(t,this),super.computeWorldVertices(t,e,s,n,r,l)}newLinkedMesh(){const t=new Io(this.name,this.path);return t.region=this.region,t.color.setFromColor(this.color),t.timelineAttachment=this.timelineAttachment,t.setParentMesh(this.parentMesh?this.parentMesh:this),t}}var _M=Object.defineProperty,DM=(f,t,e)=>t in f?_M(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Nl=(f,t,e)=>DM(f,typeof t!="symbol"?t+"":t,e);class ko extends gi{constructor(t){super(t),Nl(this,"type",Le.Path),Nl(this,"lengths",[]),Nl(this,"closed",!1),Nl(this,"constantSpeed",!1),Nl(this,"color",new Ot(1,1,1,1))}copy(){const t=new ko(this.name);return this.copyTo(t),t.lengths=new Array(this.lengths.length),pt.arrayCopy(this.lengths,0,t.lengths,0,this.lengths.length),t.closed=closed,t.constantSpeed=this.constantSpeed,t.color.setFromColor(this.color),t}}var LM=Object.defineProperty,OM=(f,t,e)=>t in f?LM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Vl=(f,t,e)=>OM(f,typeof t!="symbol"?t+"":t,e);class ff extends gi{constructor(t){super(t),Vl(this,"type",Le.Point),Vl(this,"x",0),Vl(this,"y",0),Vl(this,"rotation",0),Vl(this,"color",new Ot(.38,.94,0,1))}computeWorldPosition(t,e){const s=t.matrix;return e.x=this.x*s.a+this.y*s.c+t.worldX,e.y=this.x*s.b+this.y*s.d+t.worldY,e}computeWorldRotation(t){const e=t.matrix,s=st.cosDeg(this.rotation),n=st.sinDeg(this.rotation),r=s*e.a+n*e.c,l=s*e.b+n*e.d;return Math.atan2(l,r)*st.radDeg}copy(){const t=new ff(this.name);return t.x=this.x,t.y=this.y,t.rotation=this.rotation,t.color.setFromColor(this.color),t}}var WM=Object.defineProperty,UM=(f,t,e)=>t in f?WM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Pt=(f,t,e)=>UM(f,typeof t!="symbol"?t+"":t,e);const ie=class db extends A0{constructor(t,e){super(t),Pt(this,"type",Le.Region),Pt(this,"x",0),Pt(this,"y",0),Pt(this,"scaleX",1),Pt(this,"scaleY",1),Pt(this,"rotation",0),Pt(this,"width",0),Pt(this,"height",0),Pt(this,"color",new Ot(1,1,1,1)),Pt(this,"path"),Pt(this,"rendererObject",null),Pt(this,"region",null),Pt(this,"sequence",null),Pt(this,"offset",pt.newFloatArray(8)),Pt(this,"uvs",pt.newFloatArray(8)),Pt(this,"tempColor",new Ot(1,1,1,1)),this.path=e}updateRegion(){if(!this.region)throw new Error("Region not set.");const t=this.region,e=this.width/this.region.originalWidth*this.scaleX,s=this.height/this.region.originalHeight*this.scaleY,n=-this.width/2*this.scaleX+this.region.offsetX*e,r=-this.height/2*this.scaleY+this.region.offsetY*s,l=n+this.region.width*e,h=r+this.region.height*s,i=this.rotation*Math.PI/180,a=Math.cos(i),o=Math.sin(i),d=this.x,u=this.y,m=n*a+d,c=n*o,g=r*a+u,p=r*o,y=l*a+d,w=l*o,x=h*a+u,b=h*o,S=this.offset;S[0]=m-p,S[1]=g+c,S[2]=m-b,S[3]=x+c,S[4]=y-b,S[5]=x+w,S[6]=y-p,S[7]=g+w;const C=this.uvs;t.degrees==90?(C[2]=t.u,C[3]=t.v2,C[4]=t.u,C[5]=t.v,C[6]=t.u2,C[7]=t.v,C[0]=t.u2,C[1]=t.v2):(C[0]=t.u,C[1]=t.v2,C[2]=t.u,C[3]=t.v,C[4]=t.u2,C[5]=t.v,C[6]=t.u2,C[7]=t.v2)}computeWorldVertices(t,e,s,n){this.sequence!=null&&this.sequence.apply(t,this);const r=t.bone,l=this.offset,h=r.matrix,i=h.tx,a=h.ty,o=h.a,d=h.c,u=h.b,m=h.d;let c=0,g=0;c=l[0],g=l[1],e[s]=c*o+g*d+i,e[s+1]=c*u+g*m+a,s+=n,c=l[2],g=l[3],e[s]=c*o+g*d+i,e[s+1]=c*u+g*m+a,s+=n,c=l[4],g=l[5],e[s]=c*o+g*d+i,e[s+1]=c*u+g*m+a,s+=n,c=l[6],g=l[7],e[s]=c*o+g*d+i,e[s+1]=c*u+g*m+a}copy(){const t=new db(this.name,this.path);return t.region=this.region,t.rendererObject=this.rendererObject,t.x=this.x,t.y=this.y,t.scaleX=this.scaleX,t.scaleY=this.scaleY,t.rotation=this.rotation,t.width=this.width,t.height=this.height,pt.arrayCopy(this.uvs,0,t.uvs,0,8),pt.arrayCopy(this.offset,0,t.offset,0,8),t.color.setFromColor(this.color),t.sequence=this.sequence!=null?this.sequence.copy():null,t}};Pt(ie,"X1",0),Pt(ie,"Y1",1),Pt(ie,"C1R",2),Pt(ie,"C1G",3),Pt(ie,"C1B",4),Pt(ie,"C1A",5),Pt(ie,"U1",6),Pt(ie,"V1",7),Pt(ie,"X2",8),Pt(ie,"Y2",9),Pt(ie,"C2R",10),Pt(ie,"C2G",11),Pt(ie,"C2B",12),Pt(ie,"C2A",13),Pt(ie,"U2",14),Pt(ie,"V2",15),Pt(ie,"X3",16),Pt(ie,"Y3",17),Pt(ie,"C3R",18),Pt(ie,"C3G",19),Pt(ie,"C3B",20),Pt(ie,"C3A",21),Pt(ie,"U3",22),Pt(ie,"V3",23),Pt(ie,"X4",24),Pt(ie,"Y4",25),Pt(ie,"C4R",26),Pt(ie,"C4G",27),Pt(ie,"C4B",28),Pt(ie,"C4A",29),Pt(ie,"U4",30),Pt(ie,"V4",31);let E0=ie;var qM=Object.defineProperty,zM=(f,t,e)=>t in f?qM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Po=(f,t,e)=>zM(f,typeof t!="symbol"?t+"":t,e);const I0=class Lh{constructor(t){Po(this,"id",Lh.nextID()),Po(this,"regions"),Po(this,"start",0),Po(this,"digits",0),Po(this,"setupIndex",0),this.regions=new Array(t)}copy(){const t=new Lh(this.regions.length);return pt.arrayCopy(this.regions,0,t.regions,0,this.regions.length),t.start=this.start,t.digits=this.digits,t.setupIndex=this.setupIndex,t}apply(t,e){let s=t.sequenceIndex;s==-1&&(s=this.setupIndex),s>=this.regions.length&&(s=this.regions.length-1);const n=this.regions[s];e.region!=n&&(e.region=n)}getPath(t,e){let s=t;const n=(this.start+e).toString();for(let r=this.digits-n.length;r>0;r--)s+="0";return s+=n,s}static nextID(){return Lh._nextID++}};Po(I0,"_nextID",0);let k0=I0;var pi=(f=>(f[f.hold=0]="hold",f[f.once=1]="once",f[f.loop=2]="loop",f[f.pingpong=3]="pingpong",f[f.onceReverse=4]="onceReverse",f[f.loopReverse=5]="loopReverse",f[f.pingpongReverse=6]="pingpongReverse",f))(pi||{});const P0=[0,1,2,3,4,5,6];var H=(f=>(f[f.setup=0]="setup",f[f.first=1]="first",f[f.replace=2]="replace",f[f.add=3]="add",f))(H||{}),Mn=(f=>(f[f.mixIn=0]="mixIn",f[f.mixOut=1]="mixOut",f))(Mn||{}),GM=Object.defineProperty,HM=(f,t,e)=>t in f?GM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Vt=(f,t,e)=>HM(f,typeof t!="symbol"?t+"":t,e);class mf{constructor(t,e,s){if(Vt(this,"name"),Vt(this,"timelines",[]),Vt(this,"timelineIds",new p0),Vt(this,"duration"),!t)throw new Error("name cannot be null.");this.name=t,this.setTimelines(e),this.duration=s}setTimelines(t){if(!t)throw new Error("timelines cannot be null.");this.timelines=t,this.timelineIds.clear();for(let e=0;e<t.length;e++)this.timelineIds.addAll(t[e].getPropertyIds())}hasTimeline(t){for(let e=0;e<t.length;e++)if(this.timelineIds.contains(t[e]))return!0;return!1}apply(t,e,s,n,r,l,h,i){if(!t)throw new Error("skeleton cannot be null.");n&&this.duration!=0&&(s%=this.duration,e>0&&(e%=this.duration));const a=this.timelines;for(let o=0,d=a.length;o<d;o++)a[o].apply(t,e,s,r,l,h,i)}}const oe={rotate:0,x:1,y:2,scaleX:3,scaleY:4,shearX:5,shearY:6,rgb:7,alpha:8,rgb2:9,attachment:10,deform:11,event:12,drawOrder:13,ikConstraint:14,transformConstraint:15,pathConstraintPosition:16,pathConstraintSpacing:17,pathConstraintMix:18,sequence:19};class Oe{constructor(t,e){Vt(this,"propertyIds"),Vt(this,"frames"),this.propertyIds=e,this.frames=pt.newFloatArray(t*this.getFrameEntries())}getPropertyIds(){return this.propertyIds}getFrameEntries(){return 1}getFrameCount(){return this.frames.length/this.getFrameEntries()}getDuration(){return this.frames[this.frames.length-this.getFrameEntries()]}static search1(t,e){const s=t.length;for(let n=1;n<s;n++)if(t[n]>e)return n-1;return s-1}static search(t,e,s){const n=t.length;for(let r=s;r<n;r+=s)if(t[r]>e)return r-s;return n-s}}class Hr extends Oe{constructor(t,e,s){super(t,s),Vt(this,"curves"),this.curves=pt.newFloatArray(t+e*18),this.curves[t-1]=1}setLinear(t){this.curves[t]=0}setStepped(t){this.curves[t]=1}shrink(t){const e=this.getFrameCount()+t*18;if(this.curves.length>e){const s=pt.newFloatArray(e);pt.arrayCopy(this.curves,0,s,0,e),this.curves=s}}setBezier(t,e,s,n,r,l,h,i,a,o,d){const u=this.curves;let m=this.getFrameCount()+t*18;s==0&&(u[e]=2+m);const c=(n-l*2+i)*.03,g=(r-h*2+a)*.03,p=((l-i)*3-n+o)*.006,y=((h-a)*3-r+d)*.006;let w=c*2+p,x=g*2+y,b=(l-n)*.3+c+p*.16666667,S=(h-r)*.3+g+y*.16666667,C=n+b,v=r+S;for(let A=m+18;m<A;m+=2)u[m]=C,u[m+1]=v,b+=w,S+=x,w+=p,x+=y,C+=b,v+=S}getBezierValue(t,e,s,n){const r=this.curves;if(r[n]>t){const a=this.frames[e],o=this.frames[e+s];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}const l=n+18;for(n+=2;n<l;n+=2)if(r[n]>=t){const a=r[n-2],o=r[n-1];return o+(t-a)/(r[n]-a)*(r[n+1]-o)}e+=this.getFrameEntries();const h=r[l-2],i=r[l-1];return i+(t-h)/(this.frames[e]-h)*(this.frames[e+s]-i)}}class Kr extends Hr{constructor(t,e,s){super(t,e,[s])}getFrameEntries(){return 2}setFrame(t,e,s){t<<=1,this.frames[t]=e,this.frames[t+1]=s}getCurveValue(t){const e=this.frames;let s=e.length-2;for(let r=2;r<=s;r+=2)if(e[r]>t){s=r-2;break}const n=this.curves[s>>1];switch(n){case 0:const r=e[s],l=e[s+1];return l+(t-r)/(e[s+2]-r)*(e[s+2+1]-l);case 1:return e[s+1]}return this.getBezierValue(t,s,1,n-2)}}class gf extends Hr{constructor(t,e,s,n){super(t,e,[s,n])}getFrameEntries(){return 3}setFrame(t,e,s,n){t*=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n}}class $h extends Kr{constructor(t,e,s){super(t,e,`${oe.rotate}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.rotation=i.data.rotation;return;case H.first:i.rotation+=(i.data.rotation-i.rotation)*r}return}let o=this.getCurveValue(s);switch(l){case H.setup:i.rotation=i.data.rotation+o*r;break;case H.first:case H.replace:o+=i.data.rotation-i.rotation;case H.add:i.rotation+=o*r}}}class R0 extends gf{constructor(t,e,s){super(t,e,`${oe.x}|${s}`,`${oe.y}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.x=i.data.x,i.y=i.data.y;return;case H.first:i.x+=(i.data.x-i.x)*r,i.y+=(i.data.y-i.y)*r}return}let o=0,d=0;const u=Oe.search(a,s,3),m=this.curves[u/3];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+3]-c);o+=(a[u+3+1]-o)*g,d+=(a[u+3+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}switch(l){case H.setup:i.x=i.data.x+o*r,i.y=i.data.y+d*r;break;case H.first:case H.replace:i.x+=(i.data.x+o-i.x)*r,i.y+=(i.data.y+d-i.y)*r;break;case H.add:i.x+=o*r,i.y+=d*r}}}class Y0 extends Kr{constructor(t,e,s){super(t,e,`${oe.x}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.x=i.data.x;return;case H.first:i.x+=(i.data.x-i.x)*r}return}const o=this.getCurveValue(s);switch(l){case H.setup:i.x=i.data.x+o*r;break;case H.first:case H.replace:i.x+=(i.data.x+o-i.x)*r;break;case H.add:i.x+=o*r}}}class F0 extends Kr{constructor(t,e,s){super(t,e,`${oe.y}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.y=i.data.y;return;case H.first:i.y+=(i.data.y-i.y)*r}return}const o=this.getCurveValue(s);switch(l){case H.setup:i.y=i.data.y+o*r;break;case H.first:case H.replace:i.y+=(i.data.y+o-i.y)*r;break;case H.add:i.y+=o*r}}}class B0 extends gf{constructor(t,e,s){super(t,e,`${oe.scaleX}|${s}`,`${oe.scaleY}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.scaleX=i.data.scaleX,i.scaleY=i.data.scaleY;return;case H.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r,i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}let o,d;const u=Oe.search(a,s,3),m=this.curves[u/3];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+3]-c);o+=(a[u+3+1]-o)*g,d+=(a[u+3+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}if(o*=i.data.scaleX,d*=i.data.scaleY,r==1)l==H.add?(i.scaleX+=o-i.data.scaleX,i.scaleY+=d-i.data.scaleY):(i.scaleX=o,i.scaleY=d);else{let c=0,g=0;if(h==Mn.mixOut)switch(l){case H.setup:c=i.data.scaleX,g=i.data.scaleY,i.scaleX=c+(Math.abs(o)*st.signum(c)-c)*r,i.scaleY=g+(Math.abs(d)*st.signum(g)-g)*r;break;case H.first:case H.replace:c=i.scaleX,g=i.scaleY,i.scaleX=c+(Math.abs(o)*st.signum(c)-c)*r,i.scaleY=g+(Math.abs(d)*st.signum(g)-g)*r;break;case H.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}else switch(l){case H.setup:c=Math.abs(i.data.scaleX)*st.signum(o),g=Math.abs(i.data.scaleY)*st.signum(d),i.scaleX=c+(o-c)*r,i.scaleY=g+(d-g)*r;break;case H.first:case H.replace:c=Math.abs(i.scaleX)*st.signum(o),g=Math.abs(i.scaleY)*st.signum(d),i.scaleX=c+(o-c)*r,i.scaleY=g+(d-g)*r;break;case H.add:i.scaleX+=(o-i.data.scaleX)*r,i.scaleY+=(d-i.data.scaleY)*r}}}}class X0 extends Kr{constructor(t,e,s){super(t,e,`${oe.scaleX}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.scaleX=i.data.scaleX;return;case H.first:i.scaleX+=(i.data.scaleX-i.scaleX)*r}return}const o=this.getCurveValue(s)*i.data.scaleX;if(r==1)l==H.add?i.scaleX+=o-i.data.scaleX:i.scaleX=o;else{let d=0;if(h==Mn.mixOut)switch(l){case H.setup:d=i.data.scaleX,i.scaleX=d+(Math.abs(o)*st.signum(d)-d)*r;break;case H.first:case H.replace:d=i.scaleX,i.scaleX=d+(Math.abs(o)*st.signum(d)-d)*r;break;case H.add:i.scaleX+=(o-i.data.scaleX)*r}else switch(l){case H.setup:d=Math.abs(i.data.scaleX)*st.signum(o),i.scaleX=d+(o-d)*r;break;case H.first:case H.replace:d=Math.abs(i.scaleX)*st.signum(o),i.scaleX=d+(o-d)*r;break;case H.add:i.scaleX+=(o-i.data.scaleX)*r}}}}class $0 extends Kr{constructor(t,e,s){super(t,e,`${oe.scaleY}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.scaleY=i.data.scaleY;return;case H.first:i.scaleY+=(i.data.scaleY-i.scaleY)*r}return}const o=this.getCurveValue(s)*i.data.scaleY;if(r==1)l==H.add?i.scaleY+=o-i.data.scaleY:i.scaleY=o;else{let d=0;if(h==Mn.mixOut)switch(l){case H.setup:d=i.data.scaleY,i.scaleY=d+(Math.abs(o)*st.signum(d)-d)*r;break;case H.first:case H.replace:d=i.scaleY,i.scaleY=d+(Math.abs(o)*st.signum(d)-d)*r;break;case H.add:i.scaleY+=(o-i.data.scaleY)*r}else switch(l){case H.setup:d=Math.abs(i.data.scaleY)*st.signum(o),i.scaleY=d+(o-d)*r;break;case H.first:case H.replace:d=Math.abs(i.scaleY)*st.signum(o),i.scaleY=d+(o-d)*r;break;case H.add:i.scaleY+=(o-i.data.scaleY)*r}}}}class N0 extends gf{constructor(t,e,s){super(t,e,`${oe.shearX}|${s}`,`${oe.shearY}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.shearX=i.data.shearX,i.shearY=i.data.shearY;return;case H.first:i.shearX+=(i.data.shearX-i.shearX)*r,i.shearY+=(i.data.shearY-i.shearY)*r}return}let o=0,d=0;const u=Oe.search(a,s,3),m=this.curves[u/3];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+3]-c);o+=(a[u+3+1]-o)*g,d+=(a[u+3+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}switch(l){case H.setup:i.shearX=i.data.shearX+o*r,i.shearY=i.data.shearY+d*r;break;case H.first:case H.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r,i.shearY+=(i.data.shearY+d-i.shearY)*r;break;case H.add:i.shearX+=o*r,i.shearY+=d*r}}}class V0 extends Kr{constructor(t,e,s){super(t,e,`${oe.shearX}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.shearX=i.data.shearX;return;case H.first:i.shearX+=(i.data.shearX-i.shearX)*r}return}const o=this.getCurveValue(s);switch(l){case H.setup:i.shearX=i.data.shearX+o*r;break;case H.first:case H.replace:i.shearX+=(i.data.shearX+o-i.shearX)*r;break;case H.add:i.shearX+=o*r}}}class _0 extends Kr{constructor(t,e,s){super(t,e,`${oe.shearY}|${s}`),Vt(this,"boneIndex",0),this.boneIndex=s}apply(t,e,s,n,r,l,h){const i=t.bones[this.boneIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.shearY=i.data.shearY;return;case H.first:i.shearY+=(i.data.shearY-i.shearY)*r}return}const o=this.getCurveValue(s);switch(l){case H.setup:i.shearY=i.data.shearY+o*r;break;case H.first:case H.replace:i.shearY+=(i.data.shearY+o-i.shearY)*r;break;case H.add:i.shearY+=o*r}}}class D0 extends Hr{constructor(t,e,s){super(t,e,[`${oe.rgb}|${s}`,`${oe.alpha}|${s}`]),Vt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 5}setFrame(t,e,s,n,r,l){t*=5,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const y=i.data.color;switch(l){case H.setup:o.setFromColor(y);return;case H.first:o.add((y.r-o.r)*r,(y.g-o.g)*r,(y.b-o.b)*r,(y.a-o.a)*r)}return}let d=0,u=0,m=0,c=0;const g=Oe.search(a,s,5),p=this.curves[g/5];switch(p){case 0:const y=a[g];d=a[g+1],u=a[g+2],m=a[g+3],c=a[g+4];const w=(s-y)/(a[g+5]-y);d+=(a[g+5+1]-d)*w,u+=(a[g+5+2]-u)*w,m+=(a[g+5+3]-m)*w,c+=(a[g+5+4]-c)*w;break;case 1:d=a[g+1],u=a[g+2],m=a[g+3],c=a[g+4];break;default:d=this.getBezierValue(s,g,1,p-2),u=this.getBezierValue(s,g,2,p+18-2),m=this.getBezierValue(s,g,3,p+18*2-2),c=this.getBezierValue(s,g,4,p+18*3-2)}r==1?o.set(d,u,m,c):(l==H.setup&&o.setFromColor(i.data.color),o.add((d-o.r)*r,(u-o.g)*r,(m-o.b)*r,(c-o.a)*r))}}class L0 extends Hr{constructor(t,e,s){super(t,e,[`${oe.rgb}|${s}`]),Vt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){t<<=2,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color;if(s<a[0]){const p=i.data.color;switch(l){case H.setup:o.r=p.r,o.g=p.g,o.b=p.b;return;case H.first:o.r+=(p.r-o.r)*r,o.g+=(p.g-o.g)*r,o.b+=(p.b-o.b)*r}return}let d=0,u=0,m=0;const c=Oe.search(a,s,4),g=this.curves[c>>2];switch(g){case 0:const p=a[c];d=a[c+1],u=a[c+2],m=a[c+3];const y=(s-p)/(a[c+4]-p);d+=(a[c+4+1]-d)*y,u+=(a[c+4+2]-u)*y,m+=(a[c+4+3]-m)*y;break;case 1:d=a[c+1],u=a[c+2],m=a[c+3];break;default:d=this.getBezierValue(s,c,1,g-2),u=this.getBezierValue(s,c,2,g+18-2),m=this.getBezierValue(s,c,3,g+18*2-2)}if(r==1)o.r=d,o.g=u,o.b=m;else{if(l==H.setup){const p=i.data.color;o.r=p.r,o.g=p.g,o.b=p.b}o.r+=(d-o.r)*r,o.g+=(u-o.g)*r,o.b+=(m-o.b)*r}}}class O0 extends Kr{constructor(t,e,s){super(t,e,`${oe.alpha}|${s}`),Vt(this,"slotIndex",0),this.slotIndex=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.color;if(s<this.frames[0]){const d=i.data.color;switch(l){case H.setup:a.a=d.a;return;case H.first:a.a+=(d.a-a.a)*r}return}const o=this.getCurveValue(s);r==1?a.a=o:(l==H.setup&&(a.a=i.data.color.a),a.a+=(o-a.a)*r)}}class W0 extends Hr{constructor(t,e,s){super(t,e,[`${oe.rgb}|${s}`,`${oe.alpha}|${s}`,`${oe.rgb2}|${s}`]),Vt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 8}setFrame(t,e,s,n,r,l,h,i,a){t<<=3,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l,this.frames[t+5]=h,this.frames[t+6]=i,this.frames[t+7]=a}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const S=i.data.color,C=i.data.darkColor;switch(l){case H.setup:o.setFromColor(S),d.r=C.r,d.g=C.g,d.b=C.b;return;case H.first:o.add((S.r-o.r)*r,(S.g-o.g)*r,(S.b-o.b)*r,(S.a-o.a)*r),d.r+=(C.r-d.r)*r,d.g+=(C.g-d.g)*r,d.b+=(C.b-d.b)*r}return}let u=0,m=0,c=0,g=0,p=0,y=0,w=0;const x=Oe.search(a,s,8),b=this.curves[x>>3];switch(b){case 0:const S=a[x];u=a[x+1],m=a[x+2],c=a[x+3],g=a[x+4],p=a[x+5],y=a[x+6],w=a[x+7];const C=(s-S)/(a[x+8]-S);u+=(a[x+8+1]-u)*C,m+=(a[x+8+2]-m)*C,c+=(a[x+8+3]-c)*C,g+=(a[x+8+4]-g)*C,p+=(a[x+8+5]-p)*C,y+=(a[x+8+6]-y)*C,w+=(a[x+8+7]-w)*C;break;case 1:u=a[x+1],m=a[x+2],c=a[x+3],g=a[x+4],p=a[x+5],y=a[x+6],w=a[x+7];break;default:u=this.getBezierValue(s,x,1,b-2),m=this.getBezierValue(s,x,2,b+18-2),c=this.getBezierValue(s,x,3,b+18*2-2),g=this.getBezierValue(s,x,4,b+18*3-2),p=this.getBezierValue(s,x,5,b+18*4-2),y=this.getBezierValue(s,x,6,b+18*5-2),w=this.getBezierValue(s,x,7,b+18*6-2)}if(r==1)o.set(u,m,c,g),d.r=p,d.g=y,d.b=w;else{if(l==H.setup){o.setFromColor(i.data.color);const S=i.data.darkColor;d.r=S.r,d.g=S.g,d.b=S.b}o.add((u-o.r)*r,(m-o.g)*r,(c-o.b)*r,(g-o.a)*r),d.r+=(p-d.r)*r,d.g+=(y-d.g)*r,d.b+=(w-d.b)*r}}}class U0 extends Hr{constructor(t,e,s){super(t,e,[`${oe.rgb}|${s}`,`${oe.rgb2}|${s}`]),Vt(this,"slotIndex",0),this.slotIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,l,h,i){t*=7,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l,this.frames[t+5]=h,this.frames[t+6]=i}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=this.frames,o=i.color,d=i.darkColor;if(s<a[0]){const b=i.data.color,S=i.data.darkColor;switch(l){case H.setup:o.r=b.r,o.g=b.g,o.b=b.b,d.r=S.r,d.g=S.g,d.b=S.b;return;case H.first:o.r+=(b.r-o.r)*r,o.g+=(b.g-o.g)*r,o.b+=(b.b-o.b)*r,d.r+=(S.r-d.r)*r,d.g+=(S.g-d.g)*r,d.b+=(S.b-d.b)*r}return}let u=0,m=0,c=0,g=0,p=0,y=0;const w=Oe.search(a,s,7),x=this.curves[w/7];switch(x){case 0:const b=a[w];u=a[w+1],m=a[w+2],c=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];const S=(s-b)/(a[w+7]-b);u+=(a[w+7+1]-u)*S,m+=(a[w+7+2]-m)*S,c+=(a[w+7+3]-c)*S,g+=(a[w+7+4]-g)*S,p+=(a[w+7+5]-p)*S,y+=(a[w+7+6]-y)*S;break;case 1:u=a[w+1],m=a[w+2],c=a[w+3],g=a[w+4],p=a[w+5],y=a[w+6];break;default:u=this.getBezierValue(s,w,1,x-2),m=this.getBezierValue(s,w,2,x+18-2),c=this.getBezierValue(s,w,3,x+18*2-2),g=this.getBezierValue(s,w,4,x+18*3-2),p=this.getBezierValue(s,w,5,x+18*4-2),y=this.getBezierValue(s,w,6,x+18*5-2)}if(r==1)o.r=u,o.g=m,o.b=c,d.r=g,d.g=p,d.b=y;else{if(l==H.setup){const b=i.data.color,S=i.data.darkColor;o.r=b.r,o.g=b.g,o.b=b.b,d.r=S.r,d.g=S.g,d.b=S.b}o.r+=(u-o.r)*r,o.g+=(m-o.g)*r,o.b+=(c-o.b)*r,d.r+=(g-d.r)*r,d.g+=(p-d.g)*r,d.b+=(y-d.b)*r}}}class Ro extends Oe{constructor(t,e){super(t,[`${oe.attachment}|${e}`]),Vt(this,"slotIndex",0),Vt(this,"attachmentNames"),this.slotIndex=e,this.attachmentNames=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.attachmentNames[t]=s}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(i.bone.active){if(h==Mn.mixOut){l==H.setup&&this.setAttachment(t,i,i.data.attachmentName);return}if(s<this.frames[0]){(l==H.setup||l==H.first)&&this.setAttachment(t,i,i.data.attachmentName);return}this.setAttachment(t,i,this.attachmentNames[Oe.search1(this.frames,s)])}}setAttachment(t,e,s){e.setAttachment(s?t.getAttachment(this.slotIndex,s):null)}}class q0 extends Hr{constructor(t,e,s,n){super(t,e,[`${oe.deform}|${s}|${n.id}`]),Vt(this,"slotIndex",0),Vt(this,"attachment"),Vt(this,"vertices"),this.slotIndex=s,this.attachment=n,this.vertices=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.vertices[t]=s}setBezier(t,e,s,n,r,l,h,i,a,o,d){const u=this.curves;let m=this.getFrameCount()+t*18;s==0&&(u[e]=2+m);const c=(n-l*2+i)*.03,g=a*.03-h*.06,p=((l-i)*3-n+o)*.006,y=(h-a+.33333333)*.018;let w=c*2+p,x=g*2+y,b=(l-n)*.3+c+p*.16666667,S=h*.3+g+y*.16666667,C=n+b,v=S;for(let A=m+18;m<A;m+=2)u[m]=C,u[m+1]=v,b+=w,S+=x,w+=p,x+=y,C+=b,v+=S}getCurvePercent(t,e){const s=this.curves;let n=s[e];switch(n){case 0:const i=this.frames[e];return(t-i)/(this.frames[e+this.getFrameEntries()]-i);case 1:return 0}if(n-=2,s[n]>t){const i=this.frames[e];return s[n+1]*(t-i)/(s[n]-i)}const r=n+18;for(n+=2;n<r;n+=2)if(s[n]>=t){const i=s[n-2],a=s[n-1];return a+(t-i)/(s[n]-i)*(s[n+1]-a)}const l=s[r-2],h=s[r-1];return h+(1-h)*(t-l)/(this.frames[e+this.getFrameEntries()]-l)}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.getAttachment();if(!a||!(a instanceof gi)||a.timelineAttachment!=this.attachment)return;const o=i.deform;o.length==0&&(l=H.setup);const d=this.vertices,u=d[0].length,m=this.frames;if(s<m[0]){switch(l){case H.setup:o.length=0;return;case H.first:if(r==1){o.length=0;return}o.length=u;const w=a;if(w.bones){r=1-r;for(let x=0;x<u;x++)o[x]*=r}else{const x=w.vertices;for(let b=0;b<u;b++)o[b]+=(x[b]-o[b])*r}}return}if(o.length=u,s>=m[m.length-1]){const w=d[m.length-1];if(r==1)if(l==H.add){const x=a;if(x.bones)for(let b=0;b<u;b++)o[b]+=w[b];else{const b=x.vertices;for(let S=0;S<u;S++)o[S]+=w[S]-b[S]}}else pt.arrayCopy(w,0,o,0,u);else switch(l){case H.setup:{const b=a;if(b.bones)for(let S=0;S<u;S++)o[S]=w[S]*r;else{const S=b.vertices;for(let C=0;C<u;C++){const v=S[C];o[C]=v+(w[C]-v)*r}}break}case H.first:case H.replace:for(let b=0;b<u;b++)o[b]+=(w[b]-o[b])*r;break;case H.add:const x=a;if(x.bones)for(let b=0;b<u;b++)o[b]+=w[b]*r;else{const b=x.vertices;for(let S=0;S<u;S++)o[S]+=(w[S]-b[S])*r}}return}const c=Oe.search1(m,s),g=this.getCurvePercent(s,c),p=d[c],y=d[c+1];if(r==1)if(l==H.add){const w=a;if(w.bones)for(let x=0;x<u;x++){const b=p[x];o[x]+=b+(y[x]-b)*g}else{const x=w.vertices;for(let b=0;b<u;b++){const S=p[b];o[b]+=S+(y[b]-S)*g-x[b]}}}else for(let w=0;w<u;w++){const x=p[w];o[w]=x+(y[w]-x)*g}else switch(l){case H.setup:{const x=a;if(x.bones)for(let b=0;b<u;b++){const S=p[b];o[b]=(S+(y[b]-S)*g)*r}else{const b=x.vertices;for(let S=0;S<u;S++){const C=p[S],v=b[S];o[S]=v+(C+(y[S]-C)*g-v)*r}}break}case H.first:case H.replace:for(let x=0;x<u;x++){const b=p[x];o[x]+=(b+(y[x]-b)*g-o[x])*r}break;case H.add:const w=a;if(w.bones)for(let x=0;x<u;x++){const b=p[x];o[x]+=(b+(y[x]-b)*g)*r}else{const x=w.vertices;for(let b=0;b<u;b++){const S=p[b];o[b]+=(S+(y[b]-S)*g-x[b])*r}}}}}const z0=class ub extends Oe{constructor(t){super(t,ub.propertyIds),Vt(this,"events"),this.events=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e){this.frames[t]=e.time,this.events[t]=e}apply(t,e,s,n,r,l,h){if(!n)return;const i=this.frames,a=this.frames.length;if(e>s)this.apply(t,e,Number.MAX_VALUE,n,r,l,h),e=-1;else if(e>=i[a-1])return;if(s<i[0])return;let o=0;if(e<i[0])o=0;else{o=Oe.search1(i,e)+1;const d=i[o];for(;o>0&&i[o-1]==d;)o--}for(;o<a&&s>=i[o];o++)n.push(this.events[o])}};Vt(z0,"propertyIds",[`${oe.event}`]);let pf=z0;const G0=class fb extends Oe{constructor(t){super(t,fb.propertyIds),Vt(this,"drawOrders"),this.drawOrders=new Array(t)}getFrameCount(){return this.frames.length}setFrame(t,e,s){this.frames[t]=e,this.drawOrders[t]=s}apply(t,e,s,n,r,l,h){if(h==Mn.mixOut){l==H.setup&&pt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}if(s<this.frames[0]){(l==H.setup||l==H.first)&&pt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);return}const i=Oe.search1(this.frames,s),a=this.drawOrders[i];if(!a)pt.arrayCopy(t.slots,0,t.drawOrder,0,t.slots.length);else{const o=t.drawOrder,d=t.slots;for(let u=0,m=a.length;u<m;u++)o[u]=d[a[u]]}}};Vt(G0,"propertyIds",[`${oe.drawOrder}`]);let _l=G0;class H0 extends Hr{constructor(t,e,s){super(t,e,[`${oe.ikConstraint}|${s}`]),Vt(this,"ikConstraintIndex",0),this.ikConstraintIndex=s}getFrameEntries(){return 6}setFrame(t,e,s,n,r,l,h){t*=6,this.frames[t]=e,this.frames[t+1]=s,this.frames[t+2]=n,this.frames[t+3]=r,this.frames[t+4]=l?1:0,this.frames[t+5]=h?1:0}apply(t,e,s,n,r,l,h){const i=t.ikConstraints[this.ikConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.mix=i.data.mix,i.softness=i.data.softness,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch;return;case H.first:i.mix+=(i.data.mix-i.mix)*r,i.softness+=(i.data.softness-i.softness)*r,i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch}return}let o=0,d=0;const u=Oe.search(a,s,6),m=this.curves[u/6];switch(m){case 0:const c=a[u];o=a[u+1],d=a[u+2];const g=(s-c)/(a[u+6]-c);o+=(a[u+6+1]-o)*g,d+=(a[u+6+2]-d)*g;break;case 1:o=a[u+1],d=a[u+2];break;default:o=this.getBezierValue(s,u,1,m-2),d=this.getBezierValue(s,u,2,m+18-2)}l==H.setup?(i.mix=i.data.mix+(o-i.data.mix)*r,i.softness=i.data.softness+(d-i.data.softness)*r,h==Mn.mixOut?(i.bendDirection=i.data.bendDirection,i.compress=i.data.compress,i.stretch=i.data.stretch):(i.bendDirection=a[u+3],i.compress=a[u+4]!=0,i.stretch=a[u+5]!=0)):(i.mix+=(o-i.mix)*r,i.softness+=(d-i.softness)*r,h==Mn.mixIn&&(i.bendDirection=a[u+3],i.compress=a[u+4]!=0,i.stretch=a[u+5]!=0))}}class K0 extends Hr{constructor(t,e,s){super(t,e,[`${oe.transformConstraint}|${s}`]),Vt(this,"transformConstraintIndex",0),this.transformConstraintIndex=s}getFrameEntries(){return 7}setFrame(t,e,s,n,r,l,h,i){const a=this.frames;t*=7,a[t]=e,a[t+1]=s,a[t+2]=n,a[t+3]=r,a[t+4]=l,a[t+5]=h,a[t+6]=i}apply(t,e,s,n,r,l,h){const i=t.transformConstraints[this.transformConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){const w=i.data;switch(l){case H.setup:i.mixRotate=w.mixRotate,i.mixX=w.mixX,i.mixY=w.mixY,i.mixScaleX=w.mixScaleX,i.mixScaleY=w.mixScaleY,i.mixShearY=w.mixShearY;return;case H.first:i.mixRotate+=(w.mixRotate-i.mixRotate)*r,i.mixX+=(w.mixX-i.mixX)*r,i.mixY+=(w.mixY-i.mixY)*r,i.mixScaleX+=(w.mixScaleX-i.mixScaleX)*r,i.mixScaleY+=(w.mixScaleY-i.mixScaleY)*r,i.mixShearY+=(w.mixShearY-i.mixShearY)*r}return}let o,d,u,m,c,g;const p=Oe.search(a,s,7),y=this.curves[p/7];switch(y){case 0:const w=a[p];o=a[p+1],d=a[p+2],u=a[p+3],m=a[p+4],c=a[p+5],g=a[p+6];const x=(s-w)/(a[p+7]-w);o+=(a[p+7+1]-o)*x,d+=(a[p+7+2]-d)*x,u+=(a[p+7+3]-u)*x,m+=(a[p+7+4]-m)*x,c+=(a[p+7+5]-c)*x,g+=(a[p+7+6]-g)*x;break;case 1:o=a[p+1],d=a[p+2],u=a[p+3],m=a[p+4],c=a[p+5],g=a[p+6];break;default:o=this.getBezierValue(s,p,1,y-2),d=this.getBezierValue(s,p,2,y+18-2),u=this.getBezierValue(s,p,3,y+18*2-2),m=this.getBezierValue(s,p,4,y+18*3-2),c=this.getBezierValue(s,p,5,y+18*4-2),g=this.getBezierValue(s,p,6,y+18*5-2)}if(l==H.setup){const w=i.data;i.mixRotate=w.mixRotate+(o-w.mixRotate)*r,i.mixX=w.mixX+(d-w.mixX)*r,i.mixY=w.mixY+(u-w.mixY)*r,i.mixScaleX=w.mixScaleX+(m-w.mixScaleX)*r,i.mixScaleY=w.mixScaleY+(c-w.mixScaleY)*r,i.mixShearY=w.mixShearY+(g-w.mixShearY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(u-i.mixY)*r,i.mixScaleX+=(m-i.mixScaleX)*r,i.mixScaleY+=(c-i.mixScaleY)*r,i.mixShearY+=(g-i.mixShearY)*r}}class Z0 extends Kr{constructor(t,e,s){super(t,e,`${oe.pathConstraintPosition}|${s}`),Vt(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,l,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.position=i.data.position;return;case H.first:i.position+=(i.data.position-i.position)*r}return}const o=this.getCurveValue(s);l==H.setup?i.position=i.data.position+(o-i.data.position)*r:i.position+=(o-i.position)*r}}class J0 extends Kr{constructor(t,e,s){super(t,e,`${oe.pathConstraintSpacing}|${s}`),Vt(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}apply(t,e,s,n,r,l,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.spacing=i.data.spacing;return;case H.first:i.spacing+=(i.data.spacing-i.spacing)*r}return}const o=this.getCurveValue(s);l==H.setup?i.spacing=i.data.spacing+(o-i.data.spacing)*r:i.spacing+=(o-i.spacing)*r}}class Q0 extends Hr{constructor(t,e,s){super(t,e,[`${oe.pathConstraintMix}|${s}`]),Vt(this,"pathConstraintIndex",0),this.pathConstraintIndex=s}getFrameEntries(){return 4}setFrame(t,e,s,n,r){const l=this.frames;t<<=2,l[t]=e,l[t+1]=s,l[t+2]=n,l[t+3]=r}apply(t,e,s,n,r,l,h){const i=t.pathConstraints[this.pathConstraintIndex];if(!i.active)return;const a=this.frames;if(s<a[0]){switch(l){case H.setup:i.mixRotate=i.data.mixRotate,i.mixX=i.data.mixX,i.mixY=i.data.mixY;return;case H.first:i.mixRotate+=(i.data.mixRotate-i.mixRotate)*r,i.mixX+=(i.data.mixX-i.mixX)*r,i.mixY+=(i.data.mixY-i.mixY)*r}return}let o,d,u;const m=Oe.search(a,s,4),c=this.curves[m>>2];switch(c){case 0:const g=a[m];o=a[m+1],d=a[m+2],u=a[m+3];const p=(s-g)/(a[m+4]-g);o+=(a[m+4+1]-o)*p,d+=(a[m+4+2]-d)*p,u+=(a[m+4+3]-u)*p;break;case 1:o=a[m+1],d=a[m+2],u=a[m+3];break;default:o=this.getBezierValue(s,m,1,c-2),d=this.getBezierValue(s,m,2,c+18-2),u=this.getBezierValue(s,m,3,c+18*2-2)}if(l==H.setup){const g=i.data;i.mixRotate=g.mixRotate+(o-g.mixRotate)*r,i.mixX=g.mixX+(d-g.mixX)*r,i.mixY=g.mixY+(u-g.mixY)*r}else i.mixRotate+=(o-i.mixRotate)*r,i.mixX+=(d-i.mixX)*r,i.mixY+=(u-i.mixY)*r}}const Nh=class ga extends Oe{constructor(t,e,s){super(t,[`${oe.sequence}|${e}|${s.sequence.id}`]),Vt(this,"slotIndex"),Vt(this,"attachment"),this.slotIndex=e,this.attachment=s}getFrameEntries(){return ga.ENTRIES}getSlotIndex(){return this.slotIndex}getAttachment(){return this.attachment}setFrame(t,e,s,n,r){const l=this.frames;t*=ga.ENTRIES,l[t]=e,l[t+ga.MODE]=s|n<<4,l[t+ga.DELAY]=r}apply(t,e,s,n,r,l,h){const i=t.slots[this.slotIndex];if(!i.bone.active)return;const a=i.attachment,o=this.attachment;if(a!=o&&(!(a instanceof gi)||a.timelineAttachment!=o))return;const d=this.frames;if(s<d[0]){(l==H.setup||l==H.first)&&(i.sequenceIndex=-1);return}const u=Oe.search(d,s,ga.ENTRIES),m=d[u],c=d[u+ga.MODE],g=d[u+ga.DELAY];if(!this.attachment.sequence)return;let p=c>>4;const y=this.attachment.sequence.regions.length,w=P0[c&15];if(w!=pi.hold)switch(p+=(s-m)/g+1e-5|0,w){case pi.once:p=Math.min(y-1,p);break;case pi.loop:p%=y;break;case pi.pingpong:{const x=(y<<1)-2;p=x==0?0:p%x,p>=y&&(p=x-p);break}case pi.onceReverse:p=Math.max(y-1-p,0);break;case pi.loopReverse:p=y-1-p%y;break;case pi.pingpongReverse:{const x=(y<<1)-2;p=x==0?0:(p+y-1)%x,p>=y&&(p=x-p)}}i.sequenceIndex=p}};Vt(Nh,"ENTRIES",3),Vt(Nh,"MODE",1),Vt(Nh,"DELAY",2);let j0=Nh;var KM=Object.defineProperty,ZM=(f,t,e)=>t in f?KM(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,xt=(f,t,e)=>ZM(f,typeof t!="symbol"?t+"":t,e);const Dl=class jr{constructor(t){xt(this,"data"),xt(this,"tracks",new Array),xt(this,"timeScale",1),xt(this,"unkeyedState",0),xt(this,"events",new Array),xt(this,"listeners",new Array),xt(this,"queue",new jM(this)),xt(this,"propertyIDs",new p0),xt(this,"animationsChanged",!1),xt(this,"trackEntryPool",new b0(()=>new QM)),xt(this,"onComplete"),xt(this,"onEvent"),xt(this,"onStart"),xt(this,"onEnd"),this.data=t}static emptyAnimation(){return jr._emptyAnimation}update(t){t*=this.timeScale;const e=this.tracks;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(!r)continue;r.animationLast=r.nextAnimationLast,r.trackLast=r.nextTrackLast;let l=t*r.timeScale;if(r.delay>0){if(r.delay-=l,r.delay>0)continue;l=-r.delay,r.delay=0}let h=r.next;if(h){const i=r.trackLast-h.delay;if(i>=0){for(h.delay=0,h.trackTime+=r.timeScale==0?0:(i/r.timeScale+t)*h.timeScale,r.trackTime+=l,this.setCurrent(s,h,!0);h.mixingFrom;)h.mixTime+=t,h=h.mixingFrom;continue}}else if(r.trackLast>=r.trackEnd&&!r.mixingFrom){e[s]=null,this.queue.end(r),this.clearNext(r);continue}if(r.mixingFrom&&this.updateMixingFrom(r,t)){let i=r.mixingFrom;for(r.mixingFrom=null,i&&(i.mixingTo=null);i;)this.queue.end(i),i=i.mixingFrom}r.trackTime+=l}this.queue.drain()}updateMixingFrom(t,e){const s=t.mixingFrom;if(!s)return!0;const n=this.updateMixingFrom(s,e);return s.animationLast=s.nextAnimationLast,s.trackLast=s.nextTrackLast,t.mixTime>0&&t.mixTime>=t.mixDuration?((s.totalAlpha==0||t.mixDuration==0)&&(t.mixingFrom=s.mixingFrom,s.mixingFrom&&(s.mixingFrom.mixingTo=t),t.interruptAlpha=s.interruptAlpha,this.queue.end(s)),n):(s.trackTime+=e*s.timeScale,t.mixTime+=e,!1)}apply(t){if(!t)throw new Error("skeleton cannot be null.");this.animationsChanged&&this._animationsChanged();const e=this.events,s=this.tracks;let n=!1;for(let h=0,i=s.length;h<i;h++){const a=s[h];if(!a||a.delay>0)continue;n=!0;const o=h==0?H.first:a.mixBlend;let d=a.alpha;a.mixingFrom?d*=this.applyMixingFrom(a,t,o):a.trackTime>=a.trackEnd&&!a.next&&(d=0);const u=a.animationLast,m=a.getAnimationTime();let c=m,g=e;a.reverse&&(c=a.animation.duration-c,g=null);const p=a.animation.timelines,y=p.length;if(h==0&&d==1||o==H.add)for(let w=0;w<y;w++){pt.webkit602BugfixHelper(d,o);const x=p[w];x instanceof Ro?this.applyAttachmentTimeline(x,t,c,o,!0):x.apply(t,u,c,g,d,o,Mn.mixIn)}else{const w=a.timelineMode,x=a.shortestRotation,b=!x&&a.timelinesRotation.length!=y<<1;b&&(a.timelinesRotation.length=y<<1);for(let S=0;S<y;S++){const C=p[S],v=w[S]==bf?o:H.setup;!x&&C instanceof $h?this.applyRotateTimeline(C,t,c,d,v,a.timelinesRotation,S<<1,b):C instanceof Ro?this.applyAttachmentTimeline(C,t,c,o,!0):(pt.webkit602BugfixHelper(d,o),C.apply(t,u,c,g,d,v,Mn.mixIn))}}this.queueEvents(a,m),e.length=0,a.nextAnimationLast=m,a.nextTrackLast=a.trackTime}const r=this.unkeyedState+sx,l=t.slots;for(let h=0,i=t.slots.length;h<i;h++){const a=l[h];if(a.attachmentState==r){const o=a.data.attachmentName;a.setAttachment(o?t.getAttachment(a.data.index,o):null)}}return this.unkeyedState+=2,this.queue.drain(),n}applyMixingFrom(t,e,s){const n=t.mixingFrom;n.mixingFrom&&this.applyMixingFrom(n,e,s);let r=0;t.mixDuration==0?(r=1,s==H.first&&(s=H.setup)):(r=t.mixTime/t.mixDuration,r>1&&(r=1),s!=H.first&&(s=n.mixBlend));const l=r<n.attachmentThreshold,h=r<n.drawOrderThreshold,i=n.animation.timelines,a=i.length,o=n.alpha*t.interruptAlpha,d=o*(1-r),u=n.animationLast,m=n.getAnimationTime();let c=m,g=null;if(n.reverse?c=n.animation.duration-c:r<n.eventThreshold&&(g=this.events),s==H.add)for(let p=0;p<a;p++)i[p].apply(e,u,c,g,d,s,Mn.mixOut);else{const p=n.timelineMode,y=n.timelineHoldMix,w=n.shortestRotation,x=!w&&n.timelinesRotation.length!=a<<1;x&&(n.timelinesRotation.length=a<<1),n.totalAlpha=0;for(let b=0;b<a;b++){const S=i[b];let C=Mn.mixOut,v,A=0;switch(p[b]){case bf:if(!h&&S instanceof _l)continue;v=s,A=d;break;case tx:v=H.setup,A=d;break;case ex:v=s,A=o;break;case wf:v=H.setup,A=o;break;default:v=H.setup;const M=y[b];A=o*Math.max(0,1-M.mixTime/M.mixDuration);break}n.totalAlpha+=A,!w&&S instanceof $h?this.applyRotateTimeline(S,e,c,A,v,n.timelinesRotation,b<<1,x):S instanceof Ro?this.applyAttachmentTimeline(S,e,c,v,l):(pt.webkit602BugfixHelper(A,s),h&&S instanceof _l&&v==H.setup&&(C=Mn.mixIn),S.apply(e,u,c,g,A,v,C))}}return t.mixDuration>0&&this.queueEvents(n,m),this.events.length=0,n.nextAnimationLast=m,n.nextTrackLast=n.trackTime,r}applyAttachmentTimeline(t,e,s,n,r){const l=e.slots[t.slotIndex];l.bone.active&&(s<t.frames[0]?(n==H.setup||n==H.first)&&this.setAttachment(e,l,l.data.attachmentName,r):this.setAttachment(e,l,t.attachmentNames[Oe.search1(t.frames,s)],r),l.attachmentState<=this.unkeyedState&&(l.attachmentState=this.unkeyedState+sx))}setAttachment(t,e,s,n){e.setAttachment(s?t.getAttachment(e.data.index,s):null),n&&(e.attachmentState=this.unkeyedState+sT)}applyRotateTimeline(t,e,s,n,r,l,h,i){if(i&&(l[h]=0),n==1){t.apply(e,0,s,null,1,r,Mn.mixIn);return}const a=e.bones[t.boneIndex];if(!a.active)return;const o=t.frames;let d=0,u=0;if(s<o[0])switch(r){case H.setup:a.rotation=a.data.rotation;default:return;case H.first:d=a.rotation,u=a.data.rotation}else d=r==H.setup?a.data.rotation:a.rotation,u=a.data.rotation+t.getCurveValue(s);let m=0,c=u-d;if(c-=(16384-(16384.499999999996-c/360|0))*360,c==0)m=l[h];else{let g=0,p=0;i?(g=0,p=c):(g=l[h],p=l[h+1]);const y=c>0;let w=g>=0;st.signum(p)!=st.signum(c)&&Math.abs(p)<=90&&(Math.abs(g)>180&&(g+=360*st.signum(g)),w=y),m=c+g-g%360,w!=y&&(m+=360*st.signum(g)),l[h]=m}l[h+1]=c,a.rotation=d+m*n}queueEvents(t,e){const s=t.animationStart,n=t.animationEnd,r=n-s,l=t.trackLast%r,h=this.events;let i=0;const a=h.length;for(;i<a;i++){const d=h[i];if(d.time<l)break;d.time>n||this.queue.event(t,d)}let o=!1;for(t.loop?o=r==0||l>t.trackTime%r:o=e>=n&&t.animationLast<n,o&&this.queue.complete(t);i<a;i++){const d=h[i];d.time<s||this.queue.event(t,d)}}clearTracks(){const t=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let e=0,s=this.tracks.length;e<s;e++)this.clearTrack(e);this.tracks.length=0,this.queue.drainDisabled=t,this.queue.drain()}clearTrack(t){if(t>=this.tracks.length)return;const e=this.tracks[t];if(!e)return;this.queue.end(e),this.clearNext(e);let s=e;for(;;){const n=s.mixingFrom;if(!n)break;this.queue.end(n),s.mixingFrom=null,s.mixingTo=null,s=n}this.tracks[e.trackIndex]=null,this.queue.drain()}setCurrent(t,e,s){const n=this.expandToIndex(t);this.tracks[t]=e,e.previous=null,n&&(s&&this.queue.interrupt(n),e.mixingFrom=n,n.mixingTo=e,e.mixTime=0,n.mixingFrom&&n.mixDuration>0&&(e.interruptAlpha*=Math.min(1,n.mixTime/n.mixDuration)),n.timelinesRotation.length=0),this.queue.start(e)}setAnimation(t,e,s=!1){const n=this.data.skeletonData.findAnimation(e);if(!n)throw new Error(`Animation not found: ${e}`);return this.setAnimationWith(t,n,s)}setAnimationWith(t,e,s=!1){if(!e)throw new Error("animation cannot be null.");let n=!0,r=this.expandToIndex(t);r&&(r.nextTrackLast==-1?(this.tracks[t]=r.mixingFrom,this.queue.interrupt(r),this.queue.end(r),this.clearNext(r),r=r.mixingFrom,n=!1):this.clearNext(r));const l=this.trackEntry(t,e,s,r);return this.setCurrent(t,l,n),this.queue.drain(),l}addAnimation(t,e,s=!1,n=0){const r=this.data.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);return this.addAnimationWith(t,r,s,n)}addAnimationWith(t,e,s=!1,n=0){if(!e)throw new Error("animation cannot be null.");let r=this.expandToIndex(t);if(r)for(;r.next;)r=r.next;const l=this.trackEntry(t,e,s,r);return r?(r.next=l,l.previous=r,n<=0&&(n+=r.getTrackComplete()-l.mixDuration)):(this.setCurrent(t,l,!0),this.queue.drain()),l.delay=n,l}setEmptyAnimation(t,e=0){const s=this.setAnimationWith(t,jr.emptyAnimation(),!1);return s.mixDuration=e,s.trackEnd=e,s}addEmptyAnimation(t,e=0,s=0){const n=this.addAnimationWith(t,jr.emptyAnimation(),!1,s);return s<=0&&(n.delay+=n.mixDuration-e),n.mixDuration=e,n.trackEnd=e,n}setEmptyAnimations(t=0){const e=this.queue.drainDisabled;this.queue.drainDisabled=!0;for(let s=0,n=this.tracks.length;s<n;s++){const r=this.tracks[s];r&&this.setEmptyAnimation(r.trackIndex,t)}this.queue.drainDisabled=e,this.queue.drain()}expandToIndex(t){return t<this.tracks.length?this.tracks[t]:(pt.ensureArrayCapacity(this.tracks,t+1,null),this.tracks.length=t+1,null)}trackEntry(t,e,s,n){const r=this.trackEntryPool.obtain();return r.reset(),r.trackIndex=t,r.animation=e,r.loop=s,r.holdPrevious=!1,r.reverse=!1,r.shortestRotation=!1,r.eventThreshold=0,r.attachmentThreshold=0,r.drawOrderThreshold=0,r.animationStart=0,r.animationEnd=e.duration,r.animationLast=-1,r.nextAnimationLast=-1,r.delay=0,r.trackTime=0,r.trackLast=-1,r.nextTrackLast=-1,r.trackEnd=Number.MAX_VALUE,r.timeScale=1,r.alpha=1,r.mixTime=0,r.mixDuration=n?this.data.getMix(n.animation,e):0,r.interruptAlpha=1,r.totalAlpha=0,r.mixBlend=H.replace,r}clearNext(t){let e=t.next;for(;e;)this.queue.dispose(e),e=e.next;t.next=null}_animationsChanged(){this.animationsChanged=!1,this.propertyIDs.clear();const t=this.tracks;for(let e=0,s=t.length;e<s;e++){let n=t[e];if(n){for(;n.mixingFrom;)n=n.mixingFrom;do(!n.mixingTo||n.mixBlend!=H.add)&&this.computeHold(n),n=n.mixingTo;while(n)}}}computeHold(t){const e=t.mixingTo,s=t.animation.timelines,n=t.animation.timelines.length,r=t.timelineMode;r.length=n;const l=t.timelineHoldMix;l.length=0;const h=this.propertyIDs;if(e&&e.holdPrevious){for(let i=0;i<n;i++)r[i]=h.addAll(s[i].getPropertyIds())?wf:ex;return}t:for(let i=0;i<n;i++){const a=s[i],o=a.getPropertyIds();if(!h.addAll(o))r[i]=bf;else if(!e||a instanceof Ro||a instanceof _l||a instanceof pf||!e.animation.hasTimeline(o))r[i]=tx;else{for(let d=e.mixingTo;d;d=d.mixingTo)if(!d.animation.hasTimeline(o)){if(t.mixDuration>0){r[i]=eT,l[i]=d;continue t}break}r[i]=wf}}}getCurrent(t){return t>=this.tracks.length?null:this.tracks[t]}addListener(t){if(!t)throw new Error("listener cannot be null.");this.listeners.push(t)}removeListener(t){const e=this.listeners.indexOf(t);e>=0&&this.listeners.splice(e,1)}clearListeners(){this.listeners.length=0}clearListenerNotifications(){this.queue.clear()}setAnimationByName(t,e,s){jr.deprecatedWarning1||(jr.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.")),this.setAnimation(t,e,s)}addAnimationByName(t,e,s,n){jr.deprecatedWarning2||(jr.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.")),this.addAnimation(t,e,s,n)}hasAnimation(t){return this.data.skeletonData.findAnimation(t)!==null}hasAnimationByName(t){return jr.deprecatedWarning3||(jr.deprecatedWarning3=!0,console.warn("Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.")),this.hasAnimation(t)}};xt(Dl,"_emptyAnimation",new mf("<empty>",[],0)),xt(Dl,"deprecatedWarning1",!1),xt(Dl,"deprecatedWarning2",!1),xt(Dl,"deprecatedWarning3",!1);let JM=Dl;const xf=class Fi{constructor(){xt(this,"animation",null),xt(this,"previous",null),xt(this,"next",null),xt(this,"mixingFrom",null),xt(this,"mixingTo",null),xt(this,"listener",null),xt(this,"trackIndex",0),xt(this,"loop",!1),xt(this,"holdPrevious",!1),xt(this,"reverse",!1),xt(this,"shortestRotation",!1),xt(this,"eventThreshold",0),xt(this,"attachmentThreshold",0),xt(this,"drawOrderThreshold",0),xt(this,"animationStart",0),xt(this,"animationEnd",0),xt(this,"animationLast",0),xt(this,"nextAnimationLast",0),xt(this,"delay",0),xt(this,"trackTime",0),xt(this,"trackLast",0),xt(this,"nextTrackLast",0),xt(this,"trackEnd",0),xt(this,"timeScale",0),xt(this,"alpha",0),xt(this,"mixTime",0),xt(this,"mixDuration",0),xt(this,"interruptAlpha",0),xt(this,"totalAlpha",0),xt(this,"mixBlend",H.replace),xt(this,"timelineMode",new Array),xt(this,"timelineHoldMix",new Array),xt(this,"timelinesRotation",new Array),xt(this,"onComplete"),xt(this,"onEvent"),xt(this,"onStart"),xt(this,"onEnd")}reset(){this.next=null,this.previous=null,this.mixingFrom=null,this.mixingTo=null,this.animation=null,this.listener=null,this.timelineMode.length=0,this.timelineHoldMix.length=0,this.timelinesRotation.length=0}getAnimationTime(){if(this.loop){const t=this.animationEnd-this.animationStart;return t==0?this.animationStart:this.trackTime%t+this.animationStart}return Math.min(this.trackTime+this.animationStart,this.animationEnd)}setAnimationLast(t){this.animationLast=t,this.nextAnimationLast=t}isComplete(){return this.trackTime>=this.animationEnd-this.animationStart}resetRotationDirections(){this.timelinesRotation.length=0}getTrackComplete(){const t=this.animationEnd-this.animationStart;if(t!=0){if(this.loop)return t*(1+(this.trackTime/t|0));if(this.trackTime<t)return t}return this.trackTime}get time(){return Fi.deprecatedWarning1||(Fi.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime}set time(t){Fi.deprecatedWarning1||(Fi.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.")),this.trackTime=t}get endTime(){return Fi.deprecatedWarning2||(Fi.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime}set endTime(t){Fi.deprecatedWarning2||(Fi.deprecatedWarning2=!0,console.warn("Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.")),this.trackTime=t}loopsCount(){return Math.floor(this.trackTime/this.trackEnd)}};xt(xf,"deprecatedWarning1",!1),xt(xf,"deprecatedWarning2",!1);let QM=xf;class jM{constructor(t){xt(this,"objects",[]),xt(this,"drainDisabled",!1),xt(this,"animState"),this.animState=t}start(t){this.objects.push(0),this.objects.push(t),this.animState.animationsChanged=!0}interrupt(t){this.objects.push(1),this.objects.push(t)}end(t){this.objects.push(2),this.objects.push(t),this.animState.animationsChanged=!0}dispose(t){this.objects.push(3),this.objects.push(t)}complete(t){this.objects.push(4),this.objects.push(t)}event(t,e){this.objects.push(5),this.objects.push(t),this.objects.push(e)}drain(){if(this.drainDisabled)return;this.drainDisabled=!0;const t=this.objects,e=this.animState.listeners;for(let s=0;s<t.length;s+=2){const n=t[s],r=t[s+1];switch(n){case 0:r.listener&&r.listener.start&&r.listener.start(r);for(let h=0;h<e.length;h++){const i=e[h];i.start&&i.start(r)}break;case 1:r.listener&&r.listener.interrupt&&r.listener.interrupt(r);for(let h=0;h<e.length;h++){const i=e[h];i.interrupt&&i.interrupt(r)}break;case 2:r.listener&&r.listener.end&&r.listener.end(r);for(let h=0;h<e.length;h++){const i=e[h];i.end&&i.end(r)}case 3:r.listener&&r.listener.dispose&&r.listener.dispose(r);for(let h=0;h<e.length;h++){const i=e[h];i.dispose&&i.dispose(r)}this.animState.trackEntryPool.free(r);break;case 4:r.listener&&r.listener.complete&&r.listener.complete(r);for(let h=0;h<e.length;h++){const i=e[h];i.complete&&i.complete(r)}break;case 5:const l=t[s+++2];r.listener&&r.listener.event&&r.listener.event(r,l);for(let h=0;h<e.length;h++){const i=e[h];i.event&&i.event(r,l)}break}}this.clear(),this.drainDisabled=!1}clear(){this.objects.length=0}}var tT=(f=>(f[f.start=0]="start",f[f.interrupt=1]="interrupt",f[f.end=2]="end",f[f.dispose=3]="dispose",f[f.complete=4]="complete",f[f.event=5]="event",f))(tT||{});class _E{start(t){}interrupt(t){}end(t){}dispose(t){}complete(t){}event(t,e){}}const bf=0,tx=1,ex=2,wf=3,eT=4,sx=1,sT=2;var nT=Object.defineProperty,rT=(f,t,e)=>t in f?nT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,yf=(f,t,e)=>rT(f,typeof t!="symbol"?t+"":t,e);class iT{constructor(t){if(yf(this,"skeletonData"),yf(this,"animationToMixTime",{}),yf(this,"defaultMix",0),!t)throw new Error("skeletonData cannot be null.");this.skeletonData=t}setMix(t,e,s){const n=this.skeletonData.findAnimation(t);if(!n)throw new Error(`Animation not found: ${t}`);const r=this.skeletonData.findAnimation(e);if(!r)throw new Error(`Animation not found: ${e}`);this.setMixWith(n,r,s)}setMixWith(t,e,s){if(!t)throw new Error("from cannot be null.");if(!e)throw new Error("to cannot be null.");const n=`${t.name}.${e.name}`;this.animationToMixTime[n]=s}getMix(t,e){const s=`${t.name}.${e.name}`,n=this.animationToMixTime[s];return n===void 0?this.defaultMix:n}}var aT=Object.defineProperty,oT=(f,t,e)=>t in f?aT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,lT=(f,t,e)=>oT(f,typeof t!="symbol"?t+"":t,e);class DE{constructor(t){lT(this,"atlas"),this.atlas=t}loadSequence(t,e,s){const n=s.regions;for(let r=0,l=n.length;r<l;r++){const h=s.getPath(e,r),i=this.atlas.findRegion(h);if(i==null)throw new Error(`Region not found in atlas: ${h} (sequence: ${t})`);n[r]=i,n[r].renderObject=n[r]}}newRegionAttachment(t,e,s,n){const r=new E0(e,s);if(n!=null)this.loadSequence(e,s,n);else{const l=this.atlas.findRegion(s);if(!l)throw new Error(`Region not found in atlas: ${s} (region attachment: ${e})`);l.renderObject=l,r.region=l}return r}newMeshAttachment(t,e,s,n){const r=new Io(e,s);if(n!=null)this.loadSequence(e,s,n);else{const l=this.atlas.findRegion(s);if(!l)throw new Error(`Region not found in atlas: ${s} (mesh attachment: ${e})`);l.renderObject=l,r.region=l}return r}newBoundingBoxAttachment(t,e){return new cf(e)}newPathAttachment(t,e){return new ko(e)}newPointAttachment(t,e){return new ff(e)}newClippingAttachment(t,e){return new uf(e)}}var hT=Object.defineProperty,cT=(f,t,e)=>t in f?hT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,We=(f,t,e)=>cT(f,typeof t!="symbol"?t+"":t,e);class nx{constructor(t,e,s){if(We(this,"matrix",new V.Matrix),We(this,"data"),We(this,"skeleton"),We(this,"parent",null),We(this,"children",new Array),We(this,"x",0),We(this,"y",0),We(this,"rotation",0),We(this,"scaleX",0),We(this,"scaleY",0),We(this,"shearX",0),We(this,"shearY",0),We(this,"ax",0),We(this,"ay",0),We(this,"arotation",0),We(this,"ascaleX",0),We(this,"ascaleY",0),We(this,"ashearX",0),We(this,"ashearY",0),We(this,"sorted",!1),We(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.skeleton=e,this.parent=s,this.setToSetupPose()}get worldX(){return this.matrix.tx}get worldY(){return this.matrix.ty}isActive(){return this.active}update(){this.updateWorldTransformWith(this.ax,this.ay,this.arotation,this.ascaleX,this.ascaleY,this.ashearX,this.ashearY)}updateWorldTransform(){this.updateWorldTransformWith(this.x,this.y,this.rotation,this.scaleX,this.scaleY,this.shearX,this.shearY)}updateWorldTransformWith(t,e,s,n,r,l,h){this.ax=t,this.ay=e,this.arotation=s,this.ascaleX=n,this.ascaleY=r,this.ashearX=l,this.ashearY=h;const i=this.parent,a=this.matrix,o=this.skeleton.scaleX,d=-this.skeleton.scaleY;if(!i){const p=this.skeleton,y=s+90+h;a.a=st.cosDeg(s+l)*n*o,a.c=st.cosDeg(y)*r*o,a.b=st.sinDeg(s+l)*n*d,a.d=st.sinDeg(y)*r*d,a.tx=t*o+p.x,a.ty=e*d+p.y;return}let u=i.matrix.a,m=i.matrix.c,c=i.matrix.b,g=i.matrix.d;switch(a.tx=u*t+m*e+i.matrix.tx,a.ty=c*t+g*e+i.matrix.ty,this.data.transformMode){case $n.Normal:{const p=s+90+h,y=st.cosDeg(s+l)*n,w=st.cosDeg(p)*r,x=st.sinDeg(s+l)*n,b=st.sinDeg(p)*r;a.a=u*y+m*x,a.c=u*w+m*b,a.b=c*y+g*x,a.d=c*w+g*b;return}case $n.OnlyTranslation:{const p=s+90+h;a.a=st.cosDeg(s+l)*n,a.c=st.cosDeg(p)*r,a.b=st.sinDeg(s+l)*n,a.d=st.sinDeg(p)*r;break}case $n.NoRotationOrReflection:{let p=u*u+c*c,y=0;p>1e-4?(p=Math.abs(u*g-m*c)/p,u/=o,c/=d,m=c*p,g=u*p,y=Math.atan2(c,u)*st.radDeg):(u=0,c=0,y=90-Math.atan2(g,m)*st.radDeg);const w=s+l-y,x=s+h-y+90,b=st.cosDeg(w)*n,S=st.cosDeg(x)*r,C=st.sinDeg(w)*n,v=st.sinDeg(x)*r;a.a=u*b-m*C,a.c=u*S-m*v,a.b=c*b+g*C,a.d=c*S+g*v;break}case $n.NoScale:case $n.NoScaleOrReflection:{const p=st.cosDeg(s),y=st.sinDeg(s);let w=(u*p+m*y)/o,x=(c*p+g*y)/d,b=Math.sqrt(w*w+x*x);b>1e-5&&(b=1/b),w*=b,x*=b,b=Math.sqrt(w*w+x*x),this.data.transformMode==$n.NoScale&&u*g-m*c<0!=(o<0!=d<0)&&(b=-b);const S=Math.PI/2+Math.atan2(x,w),C=Math.cos(S)*b,v=Math.sin(S)*b,A=st.cosDeg(l)*n,M=st.cosDeg(90+h)*r,I=st.sinDeg(l)*n,E=st.sinDeg(90+h)*r;a.a=w*A+C*I,a.c=w*M+C*E,a.b=x*A+v*I,a.d=x*M+v*E;break}}a.a*=o,a.c*=o,a.b*=d,a.d*=d}setToSetupPose(){const t=this.data;this.x=t.x,this.y=t.y,this.rotation=t.rotation,this.scaleX=t.scaleX,this.scaleY=t.scaleY,this.shearX=t.shearX,this.shearY=t.shearY}getWorldRotationX(){return Math.atan2(this.matrix.b,this.matrix.a)*st.radDeg}getWorldRotationY(){return Math.atan2(this.matrix.d,this.matrix.c)*st.radDeg}getWorldScaleX(){const t=this.matrix;return Math.sqrt(t.a*t.a+t.b*t.b)}getWorldScaleY(){const t=this.matrix;return Math.sqrt(t.c*t.c+t.d*t.d)}updateAppliedTransform(){const t=this.parent,e=this.matrix;if(!t){this.ax=e.tx-this.skeleton.x,this.ay=e.ty-this.skeleton.y,this.arotation=Math.atan2(e.b,e.a)*st.radDeg,this.ascaleX=Math.sqrt(e.a*e.a+e.b*e.b),this.ascaleY=Math.sqrt(e.c*e.c+e.d*e.d),this.ashearX=0,this.ashearY=Math.atan2(e.a*e.c+e.b*e.d,e.a*e.d-e.b*e.c)*st.radDeg;return}const s=t.matrix,n=1/(s.a*s.d-s.b*s.c),r=e.tx-s.tx,l=e.ty-s.ty;this.ax=r*s.d*n-l*s.c*n,this.ay=l*s.a*n-r*s.b*n;const h=n*s.d,i=n*s.a,a=n*s.c,o=n*s.b,d=h*e.a-a*e.b,u=h*e.c-a*e.d,m=i*e.b-o*e.a,c=i*e.d-o*e.c;if(this.ashearX=0,this.ascaleX=Math.sqrt(d*d+m*m),this.ascaleX>1e-4){const g=d*c-u*m;this.ascaleY=g/this.ascaleX,this.ashearY=Math.atan2(d*u+m*c,g)*st.radDeg,this.arotation=Math.atan2(m,d)*st.radDeg}else this.ascaleX=0,this.ascaleY=Math.sqrt(u*u+c*c),this.ashearY=0,this.arotation=90-Math.atan2(c,u)*st.radDeg}worldToLocal(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=1/(s*l-n*r),i=t.x-e.tx,a=t.y-e.ty;return t.x=i*l*h-a*n*h,t.y=a*s*h-i*r*h,t}localToWorld(t){const e=this.matrix,s=t.x,n=t.y;return t.x=s*e.a+n*e.c+e.tx,t.y=s*e.b+n*e.d+e.ty,t}worldToLocalRotation(t){const e=st.sinDeg(t),s=st.cosDeg(t),n=this.matrix;return Math.atan2(n.a*e-n.b*s,n.d*s-n.c*e)*st.radDeg}localToWorldRotation(t){t-=this.rotation-this.shearX;const e=st.sinDeg(t),s=st.cosDeg(t),n=this.matrix;return Math.atan2(s*n.b+e*n.d,s*n.a+e*n.c)*st.radDeg}rotateWorld(t){const e=this.matrix,s=e.a,n=e.c,r=e.b,l=e.d,h=st.cosDeg(t),i=st.sinDeg(t);e.a=h*s-i*r,e.c=h*n-i*l,e.b=i*s+h*r,e.d=i*n+h*l}}var dT=Object.defineProperty,uT=(f,t,e)=>t in f?dT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Tn=(f,t,e)=>uT(f,typeof t!="symbol"?t+"":t,e);class rx{constructor(t,e,s){if(Tn(this,"index",0),Tn(this,"name"),Tn(this,"parent",null),Tn(this,"length",0),Tn(this,"x",0),Tn(this,"y",0),Tn(this,"rotation",0),Tn(this,"scaleX",1),Tn(this,"scaleY",1),Tn(this,"shearX",0),Tn(this,"shearY",0),Tn(this,"transformMode",$n.Normal),Tn(this,"skinRequired",!1),Tn(this,"color",new Ot),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");this.index=t,this.name=e,this.parent=s}}class Sf{constructor(t,e,s){this.name=t,this.order=e,this.skinRequired=s}}var fT=Object.defineProperty,mT=(f,t,e)=>t in f?fT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,io=(f,t,e)=>mT(f,typeof t!="symbol"?t+"":t,e);class ix{constructor(t,e){if(io(this,"data"),io(this,"intValue",0),io(this,"floatValue",0),io(this,"stringValue",null),io(this,"time",0),io(this,"volume",0),io(this,"balance",0),!e)throw new Error("data cannot be null.");this.time=t,this.data=e}}var gT=Object.defineProperty,pT=(f,t,e)=>t in f?gT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ao=(f,t,e)=>pT(f,typeof t!="symbol"?t+"":t,e);class ax{constructor(t){ao(this,"name"),ao(this,"intValue",0),ao(this,"floatValue",0),ao(this,"stringValue",null),ao(this,"audioPath",null),ao(this,"volume",0),ao(this,"balance",0),this.name=t}}var xT=Object.defineProperty,bT=(f,t,e)=>t in f?xT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,xi=(f,t,e)=>bT(f,typeof t!="symbol"?t+"":t,e);class wT{constructor(t,e){if(xi(this,"data"),xi(this,"bones"),xi(this,"target"),xi(this,"bendDirection",0),xi(this,"compress",!1),xi(this,"stretch",!1),xi(this,"mix",1),xi(this,"softness",0),xi(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mix=t.mix,this.softness=t.softness,this.bendDirection=t.bendDirection,this.compress=t.compress,this.stretch=t.stretch,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find bone ${t.target.name}`);this.target=s}isActive(){return this.active}update(){if(this.mix==0)return;const t=this.target,e=this.bones;switch(e.length){case 1:this.apply1(e[0],t.worldX,t.worldY,this.compress,this.stretch,this.data.uniform,this.mix);break;case 2:this.apply2(e[0],e[1],t.worldX,t.worldY,this.bendDirection,this.stretch,this.data.uniform,this.softness,this.mix);break}}apply1(t,e,s,n,r,l,h){const i=t.parent.matrix;if(!i)throw new Error("IK bone must have parent.");const a=i.a;let o=i.c;const d=i.b;let u=i.d,m=-t.ashearX-t.arotation,c=0,g=0;const p=t.skeleton.scaleX,y=-t.skeleton.scaleY;switch(t.data.transformMode){case $n.OnlyTranslation:c=e-t.worldX,g=s-t.worldY,g=-g;break;case $n.NoRotationOrReflection:const b=Math.abs(a*u-o*d)/(a*a+d*d),S=a/p,C=d/y;o=-C*b*p,u=S*b*y,m+=Math.atan2(C,S)*st.radDeg;default:const v=e-i.tx,A=s-i.ty,M=a*u-o*d;c=(v*u-A*o)/M-t.ax,g=(A*a-v*d)/M-t.ay}m+=Math.atan2(g,c)*st.radDeg,t.ascaleX<0&&(m+=180),m>180?m-=360:m<-180&&(m+=360);let w=t.ascaleX,x=t.ascaleY;if(n||r){switch(t.data.transformMode){case $n.NoScale:case $n.NoScaleOrReflection:c=e-t.worldX,g=s-t.worldY}const b=t.data.length*w,S=Math.sqrt(c*c+g*g);if(n&&S<b||r&&S>b&&b>1e-4){const C=(S/b-1)*h+1;w*=C,l&&(x*=C)}}t.updateWorldTransformWith(t.ax,t.ay,t.arotation+m*h,w,x,t.ashearX,t.ashearY)}apply2(t,e,s,n,r,l,h,i,a){const o=t.ax,d=t.ay;let u=t.ascaleX,m=t.ascaleY,c=u,g=m,p=e.ascaleX;const y=t.matrix;let w=0,x=0,b=0;u<0?(u=-u,w=180,b=-1):(w=0,b=1),m<0&&(m=-m,b=-b),p<0?(p=-p,x=180):x=0;const S=e.ax;let C=0,v=0,A=0,M=y.a,I=y.c,E=y.b,P=y.d;const R=Math.abs(u-m)<=1e-4;!R||l?(C=0,v=M*S+y.tx,A=E*S+y.ty):(C=e.ay,v=M*S+I*C+y.tx,A=E*S+P*C+y.ty);const k=t.parent.matrix;if(!k)throw new Error("IK parent must itself have a parent.");M=k.a,I=k.c,E=k.b,P=k.d;const Y=1/(M*P-I*E);let F=v-k.tx,X=A-k.ty;const W=(F*P-X*I)*Y-o,B=(X*M-F*E)*Y-d,N=Math.sqrt(W*W+B*B);let O=e.data.length*p,Z,$;if(N<1e-4){this.apply1(t,s,n,!1,l,!1,a),e.updateWorldTransformWith(S,C,0,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY);return}F=s-k.tx,X=n-k.ty;let D=(F*P-X*I)*Y-o,_=(X*M-F*E)*Y-d,lt=D*D+_*_;if(i!=0){i*=u*(p+1)*.5;const ct=Math.sqrt(lt),Mt=ct-N-O*u+i;if(Mt>0){let Rt=Math.min(1,Mt/(i*2))-1;Rt=(Mt-i*(1-Rt*Rt))/ct,D-=Rt*D,_-=Rt*_,lt=D*D+_*_}}t:if(R){O*=u;let ct=(lt-N*N-O*O)/(2*N*O);ct<-1?(ct=-1,$=Math.PI*r):ct>1?(ct=1,$=0,l&&(M=(Math.sqrt(lt)/(N+O)-1)*a+1,c*=M,h&&(g*=M))):$=Math.acos(ct)*r,M=N+O*ct,I=O*Math.sin($),Z=Math.atan2(_*M-D*I,D*M+_*I)}else{M=u*O,I=m*O;const ct=M*M,Mt=I*I,Rt=Math.atan2(_,D);E=Mt*N*N+ct*lt-ct*Mt;const de=-2*Mt*N,Ze=Mt-ct;if(P=de*de-4*Ze*E,P>=0){let Kt=Math.sqrt(P);de<0&&(Kt=-Kt),Kt=-(de+Kt)*.5;const ps=Kt/Ze,Vn=E/Kt,ts=Math.abs(ps)<Math.abs(Vn)?ps:Vn;if(ts*ts<=lt){X=Math.sqrt(lt-ts*ts)*r,Z=Rt-Math.atan2(X,ts),$=Math.atan2(X/m,(ts-N)/u);break t}}let Je=st.PI,we=N-M,Ye=we*we,Qe=0,je=0,ue=N+M,ye=ue*ue,Ue=0;E=-M*N/(ct-Mt),E>=-1&&E<=1&&(E=Math.acos(E),F=M*Math.cos(E)+N,X=I*Math.sin(E),P=F*F+X*X,P<Ye&&(Je=E,Ye=P,we=F,Qe=X),P>ye&&(je=E,ye=P,ue=F,Ue=X)),lt<=(Ye+ye)*.5?(Z=Rt-Math.atan2(Qe*r,we),$=Je*r):(Z=Rt-Math.atan2(Ue*r,ue),$=je*r)}const wt=Math.atan2(C,S)*b;let Tt=t.arotation;Z=(Z-wt)*st.radDeg+w-Tt,Z>180?Z-=360:Z<-180&&(Z+=360),t.updateWorldTransformWith(o,d,Tt+Z*a,c,g,0,0),Tt=e.arotation,$=(($+wt)*st.radDeg-e.ashearX)*b+x-Tt,$>180?$-=360:$<-180&&($+=360),e.updateWorldTransformWith(S,C,Tt+$*a,e.ascaleX,e.ascaleY,e.ashearX,e.ashearY)}}var yT=Object.defineProperty,ST=(f,t,e)=>t in f?yT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,la=(f,t,e)=>ST(f,typeof t!="symbol"?t+"":t,e);class ox extends Sf{constructor(t){super(t,0,!1),la(this,"bones",new Array),la(this,"_target",null),la(this,"bendDirection",1),la(this,"compress",!1),la(this,"stretch",!1),la(this,"uniform",!1),la(this,"mix",1),la(this,"softness",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}var bi=(f=>(f[f.Fixed=0]="Fixed",f[f.Percent=1]="Percent",f))(bi||{}),Yo=(f=>(f[f.Tangent=0]="Tangent",f[f.Chain=1]="Chain",f[f.ChainScale=2]="ChainScale",f))(Yo||{}),CT=Object.defineProperty,vT=(f,t,e)=>t in f?CT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Sr=(f,t,e)=>vT(f,typeof t!="symbol"?t+"":t,e);class lx extends Sf{constructor(t){super(t,0,!1),Sr(this,"bones",new Array),Sr(this,"_target",null),Sr(this,"positionMode",bi.Fixed),Sr(this,"spacingMode",1),Sr(this,"rotateMode",Yo.Chain),Sr(this,"offsetRotation",0),Sr(this,"position",0),Sr(this,"spacing",0),Sr(this,"mixRotate",0),Sr(this,"mixX",0),Sr(this,"mixY",0)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("SlotData not set.")}}var _s=(f=>(f[f.Length=0]="Length",f[f.Fixed=1]="Fixed",f[f.Percent=2]="Percent",f[f.Proportional=3]="Proportional",f))(_s||{}),AT=Object.defineProperty,MT=(f,t,e)=>t in f?AT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ls=(f,t,e)=>MT(f,typeof t!="symbol"?t+"":t,e);const Ll=class Bi{constructor(t,e){if(ls(this,"data"),ls(this,"bones"),ls(this,"target"),ls(this,"position",0),ls(this,"spacing",0),ls(this,"mixRotate",0),ls(this,"mixX",0),ls(this,"mixY",0),ls(this,"spaces",new Array),ls(this,"positions",new Array),ls(this,"world",new Array),ls(this,"curves",new Array),ls(this,"lengths",new Array),ls(this,"segments",new Array),ls(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.bones=new Array;for(let n=0,r=t.bones.length;n<r;n++){const l=e.findBone(t.bones[n].name);if(!l)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(l)}const s=e.findSlot(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}`);this.target=s,this.position=t.position,this.spacing=t.spacing,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY}isActive(){return this.active}update(){const t=this.target.getAttachment();if(!(t instanceof ko))return;const e=this.mixRotate,s=this.mixX,n=this.mixY;if(e==0&&s==0&&n==0)return;const r=this.data,l=r.rotateMode==Yo.Tangent,h=r.rotateMode==Yo.ChainScale,i=this.bones,a=i.length,o=l?a:a+1,d=pt.setArraySize(this.spaces,o),u=h?this.lengths=pt.setArraySize(this.lengths,a):[],m=this.spacing;switch(r.spacingMode){case _s.Percent:if(h)for(let S=0,C=o-1;S<C;S++){const v=i[S],A=v.data.length;if(A<Bi.epsilon)u[S]=0;else{const M=A*v.matrix.a,I=A*v.matrix.b;u[S]=Math.sqrt(M*M+I*I)}}pt.arrayFill(d,1,o,m);break;case _s.Proportional:let x=0;for(let S=0,C=o-1;S<C;){const v=i[S],A=v.data.length;if(A<Bi.epsilon)h&&(u[S]=0),d[++S]=m;else{const M=A*v.matrix.a,I=A*v.matrix.b,E=Math.sqrt(M*M+I*I);h&&(u[S]=E),d[++S]=E,x+=E}}if(x>0){x=o/x*m;for(let S=1;S<o;S++)d[S]*=x}break;default:const b=r.spacingMode==_s.Length;for(let S=0,C=o-1;S<C;){const v=i[S],A=v.data.length;if(A<Bi.epsilon)h&&(u[S]=0),d[++S]=m;else{const M=A*v.matrix.a,I=A*v.matrix.b,E=Math.sqrt(M*M+I*I);h&&(u[S]=E),d[++S]=(b?A+m:m)*E/A}}}const c=this.computeWorldPositions(t,o,l);let g=c[0],p=c[1],y=r.offsetRotation,w=!1;if(y==0)w=r.rotateMode==Yo.Chain;else{w=!1;const x=this.target.bone.matrix;y*=x.a*x.d-x.b*x.c>0?st.degRad:-st.degRad}for(let x=0,b=3;x<a;x++,b+=3){const S=i[x],C=S.matrix;C.tx+=(g-C.tx)*s,C.ty+=(p-C.ty)*n;const v=c[b],A=c[b+1],M=v-g,I=A-p;if(h){const E=u[x];if(E!=0){const P=(Math.sqrt(M*M+I*I)/E-1)*e+1;C.a*=P,C.b*=P}}if(g=v,p=A,e>0){const E=C.a,P=C.c,R=C.b,k=C.d;let Y=0,F=0,X=0;if(l?Y=c[b-1]:d[x+1]==0?Y=c[b+2]:Y=Math.atan2(I,M),Y-=Math.atan2(R,E),w){F=Math.cos(Y),X=Math.sin(Y);const W=S.data.length;g+=(W*(F*E-X*R)-M)*e,p+=(W*(X*E+F*R)-I)*e}else Y+=y;Y>st.PI?Y-=st.PI2:Y<-st.PI&&(Y+=st.PI2),Y*=e,F=Math.cos(Y),X=Math.sin(Y),C.a=F*E-X*R,C.c=F*P-X*k,C.b=X*E+F*R,C.d=X*P+F*k}S.updateAppliedTransform()}}computeWorldPositions(t,e,s){const n=this.target;let r=this.position;const l=this.spaces,h=pt.setArraySize(this.positions,e*3+2);let i=this.world;const a=t.closed;let o=t.worldVerticesLength,d=o/6,u=Bi.NONE;if(!t.constantSpeed){const W=t.lengths;d-=a?1:2;const B=W[d];this.data.positionMode==bi.Percent&&(r*=B);let N;switch(this.data.spacingMode){case _s.Percent:N=B;break;case _s.Proportional:N=B/e;break;default:N=1}i=pt.setArraySize(this.world,8);for(let O=0,Z=0,$=0;O<e;O++,Z+=3){const D=l[O]*N;r+=D;let _=r;if(a)_%=B,_<0&&(_+=B),$=0;else if(_<0){u!=Bi.BEFORE&&(u=Bi.BEFORE,t.computeWorldVertices(n,2,4,i,0,2)),this.addBeforePosition(_,i,0,h,Z);continue}else if(_>B){u!=Bi.AFTER&&(u=Bi.AFTER,t.computeWorldVertices(n,o-6,4,i,0,2)),this.addAfterPosition(_-B,i,0,h,Z);continue}for(;;$++){const lt=W[$];if(!(_>lt)){if($==0)_/=lt;else{const wt=W[$-1];_=(_-wt)/(lt-wt)}break}}$!=u&&(u=$,a&&$==d?(t.computeWorldVertices(n,o-4,4,i,0,2),t.computeWorldVertices(n,0,4,i,4,2)):t.computeWorldVertices(n,$*6+2,8,i,0,2)),this.addCurvePosition(_,i[0],i[1],i[2],i[3],i[4],i[5],i[6],i[7],h,Z,s||O>0&&D==0)}return h}a?(o+=2,i=pt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o-4,i,0,2),t.computeWorldVertices(n,0,2,i,o-4,2),i[o-2]=i[0],i[o-1]=i[1]):(d--,o-=4,i=pt.setArraySize(this.world,o),t.computeWorldVertices(n,2,o,i,0,2));const m=pt.setArraySize(this.curves,d);let c=0,g=i[0],p=i[1],y=0,w=0,x=0,b=0,S=0,C=0,v=0,A=0,M=0,I=0,E=0,P=0,R=0,k=0;for(let W=0,B=2;W<d;W++,B+=6)y=i[B],w=i[B+1],x=i[B+2],b=i[B+3],S=i[B+4],C=i[B+5],v=(g-y*2+x)*.1875,A=(p-w*2+b)*.1875,M=((y-x)*3-g+S)*.09375,I=((w-b)*3-p+C)*.09375,E=v*2+M,P=A*2+I,R=(y-g)*.75+v+M*.16666667,k=(w-p)*.75+A+I*.16666667,c+=Math.sqrt(R*R+k*k),R+=E,k+=P,E+=M,P+=I,c+=Math.sqrt(R*R+k*k),R+=E,k+=P,c+=Math.sqrt(R*R+k*k),R+=E+M,k+=P+I,c+=Math.sqrt(R*R+k*k),m[W]=c,g=S,p=C;this.data.positionMode==bi.Percent&&(r*=c);let Y;switch(this.data.spacingMode){case _s.Percent:Y=c;break;case _s.Proportional:Y=c/e;break;default:Y=1}const F=this.segments;let X=0;for(let W=0,B=0,N=0,O=0;W<e;W++,B+=3){const Z=l[W]*Y;r+=Z;let $=r;if(a)$%=c,$<0&&($+=c),N=0;else if($<0){this.addBeforePosition($,i,0,h,B);continue}else if($>c){this.addAfterPosition($-c,i,o-4,h,B);continue}for(;;N++){const D=m[N];if(!($>D)){if(N==0)$/=D;else{const _=m[N-1];$=($-_)/(D-_)}break}}if(N!=u){u=N;let D=N*6;for(g=i[D],p=i[D+1],y=i[D+2],w=i[D+3],x=i[D+4],b=i[D+5],S=i[D+6],C=i[D+7],v=(g-y*2+x)*.03,A=(p-w*2+b)*.03,M=((y-x)*3-g+S)*.006,I=((w-b)*3-p+C)*.006,E=v*2+M,P=A*2+I,R=(y-g)*.3+v+M*.16666667,k=(w-p)*.3+A+I*.16666667,X=Math.sqrt(R*R+k*k),F[0]=X,D=1;D<8;D++)R+=E,k+=P,E+=M,P+=I,X+=Math.sqrt(R*R+k*k),F[D]=X;R+=E,k+=P,X+=Math.sqrt(R*R+k*k),F[8]=X,R+=E+M,k+=P+I,X+=Math.sqrt(R*R+k*k),F[9]=X,O=0}for($*=X;;O++){const D=F[O];if(!($>D)){if(O==0)$/=D;else{const _=F[O-1];$=O+($-_)/(D-_)}break}}this.addCurvePosition($*.1,g,p,y,w,x,b,S,C,h,B,s||W>0&&Z==0)}return h}addBeforePosition(t,e,s,n,r){const l=e[s],h=e[s+1],i=e[s+2]-l,a=e[s+3]-h,o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addAfterPosition(t,e,s,n,r){const l=e[s+2],h=e[s+3],i=l-e[s],a=h-e[s+1],o=Math.atan2(a,i);n[r]=l+t*Math.cos(o),n[r+1]=h+t*Math.sin(o),n[r+2]=o}addCurvePosition(t,e,s,n,r,l,h,i,a,o,d,u){if(t==0||isNaN(t)){o[d]=e,o[d+1]=s,o[d+2]=Math.atan2(r-s,n-e);return}const m=t*t,c=m*t,g=1-t,p=g*g,y=p*g,w=g*t,x=w*3,b=g*x,S=x*t,C=e*y+n*b+l*S+i*c,v=s*y+r*b+h*S+a*c;o[d]=C,o[d+1]=v,u&&(t<.001?o[d+2]=Math.atan2(r-s,n-e):o[d+2]=Math.atan2(v-(s*p+r*w*2+h*m),C-(e*p+n*w*2+l*m)))}};ls(Ll,"NONE",-1),ls(Ll,"BEFORE",-2),ls(Ll,"AFTER",-3),ls(Ll,"epsilon",1e-5);let TT=Ll;var ET=Object.defineProperty,IT=(f,t,e)=>t in f?ET(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,wi=(f,t,e)=>IT(f,typeof t!="symbol"?t+"":t,e);class kT{constructor(t,e){if(wi(this,"blendMode"),wi(this,"data"),wi(this,"bone"),wi(this,"color"),wi(this,"darkColor",null),wi(this,"attachment",null),wi(this,"attachmentState",0),wi(this,"sequenceIndex",-1),wi(this,"deform",new Array),!t)throw new Error("data cannot be null.");if(!e)throw new Error("bone cannot be null.");this.data=t,this.bone=e,this.color=new Ot,this.darkColor=t.darkColor?new Ot:null,this.setToSetupPose(),this.blendMode=this.data.blendMode}getSkeleton(){return this.bone.skeleton}getAttachment(){return this.attachment}setAttachment(t){this.attachment!=t&&((!(t instanceof gi)||!(this.attachment instanceof gi)||t.timelineAttachment!=this.attachment.timelineAttachment)&&(this.deform.length=0),this.attachment=t,this.sequenceIndex=-1)}setToSetupPose(){this.color.setFromColor(this.data.color),this.darkColor&&this.darkColor.setFromColor(this.data.darkColor),this.data.attachmentName?(this.attachment=null,this.setAttachment(this.bone.skeleton.getAttachment(this.data.index,this.data.attachmentName))):this.attachment=null}}var PT=Object.defineProperty,RT=(f,t,e)=>t in f?PT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Cr=(f,t,e)=>RT(f,typeof t!="symbol"?t+"":t,e);class YT{constructor(t,e){if(Cr(this,"data"),Cr(this,"bones"),Cr(this,"target"),Cr(this,"mixRotate",0),Cr(this,"mixX",0),Cr(this,"mixY",0),Cr(this,"mixScaleX",0),Cr(this,"mixScaleY",0),Cr(this,"mixShearY",0),Cr(this,"temp",new hf),Cr(this,"active",!1),!t)throw new Error("data cannot be null.");if(!e)throw new Error("skeleton cannot be null.");this.data=t,this.mixRotate=t.mixRotate,this.mixX=t.mixX,this.mixY=t.mixY,this.mixScaleX=t.mixScaleX,this.mixScaleY=t.mixScaleY,this.mixShearY=t.mixShearY,this.bones=new Array;for(let n=0;n<t.bones.length;n++){const r=e.findBone(t.bones[n].name);if(!r)throw new Error(`Couldn't find bone ${t.bones[n].name}.`);this.bones.push(r)}const s=e.findBone(t.target.name);if(!s)throw new Error(`Couldn't find target bone ${t.target.name}.`);this.target=s}isActive(){return this.active}update(){this.mixRotate==0&&this.mixX==0&&this.mixY==0&&this.mixScaleX==0&&this.mixScaleX==0&&this.mixShearY==0||(this.data.local?this.data.relative?this.applyRelativeLocal():this.applyAbsoluteLocal():this.data.relative?this.applyRelativeWorld():this.applyAbsoluteWorld())}applyAbsoluteWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,u=a.b,m=a.d,c=o*m-d*u>0?st.degRad:-st.degRad,g=this.data.offsetRotation*c,p=this.data.offsetShearY*c,y=this.bones;for(let w=0,x=y.length;w<x;w++){const b=y[w],S=b.matrix;if(t!=0){const C=S.a,v=S.c,A=S.b,M=S.d;let I=Math.atan2(u,o)-Math.atan2(A,C)+g;I>st.PI?I-=st.PI2:I<-st.PI&&(I+=st.PI2),I*=t;const E=Math.cos(I),P=Math.sin(I);S.a=E*C-P*A,S.c=E*v-P*M,S.b=P*C+E*A,S.d=P*v+E*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=(C.x-S.tx)*e,S.ty+=(C.y-S.ty)*s}if(n!=0){let C=Math.sqrt(S.a*S.a+S.b*S.b);C!=0&&(C=(C+(Math.sqrt(o*o+u*u)-C+this.data.offsetScaleX)*n)/C),S.a*=C,S.b*=C}if(r!=0){let C=Math.sqrt(S.c*S.c+S.d*S.d);C!=0&&(C=(C+(Math.sqrt(d*d+m*m)-C+this.data.offsetScaleY)*r)/C),S.c*=C,S.d*=C}if(l>0){const C=S.c,v=S.d,A=Math.atan2(v,C);let M=Math.atan2(m,d)-Math.atan2(u,o)-(A-Math.atan2(S.b,S.a));M>st.PI?M-=st.PI2:M<-st.PI&&(M+=st.PI2),M=A+(M+p)*l;const I=Math.sqrt(C*C+v*v);S.c=Math.cos(M)*I,S.d=Math.sin(M)*I}b.updateAppliedTransform()}}applyRelativeWorld(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=e!=0||s!=0,i=this.target,a=i.matrix,o=a.a,d=a.c,u=a.b,m=a.d,c=o*m-d*u>0?st.degRad:-st.degRad,g=this.data.offsetRotation*c,p=this.data.offsetShearY*c,y=this.bones;for(let w=0,x=y.length;w<x;w++){const b=y[w],S=b.matrix;if(t!=0){const C=S.a,v=S.c,A=S.b,M=S.d;let I=Math.atan2(u,o)+g;I>st.PI?I-=st.PI2:I<-st.PI&&(I+=st.PI2),I*=t;const E=Math.cos(I),P=Math.sin(I);S.a=E*C-P*A,S.c=E*v-P*M,S.b=P*C+E*A,S.d=P*v+E*M}if(h){const C=this.temp;i.localToWorld(C.set(this.data.offsetX,this.data.offsetY)),S.tx+=C.x*e,S.ty+=C.y*s}if(n!=0){const C=(Math.sqrt(o*o+u*u)-1+this.data.offsetScaleX)*n+1;S.a*=C,S.b*=C}if(r!=0){const C=(Math.sqrt(d*d+m*m)-1+this.data.offsetScaleY)*r+1;S.c*=C,S.d*=C}if(l>0){let C=Math.atan2(m,d)-Math.atan2(u,o);C>st.PI?C-=st.PI2:C<-st.PI&&(C+=st.PI2);const v=S.c,A=S.d;C=Math.atan2(A,v)+(C-st.PI/2+p)*l;const M=Math.sqrt(v*v+A*A);S.c=Math.cos(C)*M,S.d=Math.sin(C)*M}b.updateAppliedTransform()}}applyAbsoluteLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a];let u=d.arotation;if(t!=0){let w=h.arotation-u+this.data.offsetRotation;w-=(16384-(16384.499999999996-w/360|0))*360,u+=w*t}let m=d.ax,c=d.ay;m+=(h.ax-m+this.data.offsetX)*e,c+=(h.ay-c+this.data.offsetY)*s;let g=d.ascaleX,p=d.ascaleY;n!=0&&g!=0&&(g=(g+(h.ascaleX-g+this.data.offsetScaleX)*n)/g),r!=0&&p!=0&&(p=(p+(h.ascaleY-p+this.data.offsetScaleY)*r)/p);let y=d.ashearY;if(l!=0){let w=h.ashearY-y+this.data.offsetShearY;w-=(16384-(16384.499999999996-w/360|0))*360,y+=w*l}d.updateWorldTransformWith(m,c,u,g,p,d.ashearX,y)}}applyRelativeLocal(){const t=this.mixRotate,e=this.mixX,s=this.mixY,n=this.mixScaleX,r=this.mixScaleY,l=this.mixShearY,h=this.target,i=this.bones;for(let a=0,o=i.length;a<o;a++){const d=i[a],u=d.arotation+(h.arotation+this.data.offsetRotation)*t,m=d.ax+(h.ax+this.data.offsetX)*e,c=d.ay+(h.ay+this.data.offsetY)*s,g=d.ascaleX*((h.ascaleX-1+this.data.offsetScaleX)*n+1),p=d.ascaleY*((h.ascaleY-1+this.data.offsetScaleY)*r+1),y=d.ashearY+(h.ashearY+this.data.offsetShearY)*l;d.updateWorldTransformWith(m,c,u,g,p,d.ashearX,y)}}}var FT=Object.defineProperty,BT=(f,t,e)=>t in f?FT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,sn=(f,t,e)=>BT(f,typeof t!="symbol"?t+"":t,e);const hx=class th{constructor(t){if(sn(this,"data"),sn(this,"bones"),sn(this,"slots"),sn(this,"drawOrder"),sn(this,"ikConstraints"),sn(this,"transformConstraints"),sn(this,"pathConstraints"),sn(this,"_updateCache",new Array),sn(this,"skin",null),sn(this,"color"),sn(this,"scaleX",1),sn(this,"scaleY",1),sn(this,"x",0),sn(this,"y",0),!t)throw new Error("data cannot be null.");this.data=t,this.bones=new Array;for(let e=0;e<t.bones.length;e++){const s=t.bones[e];let n;if(!s.parent)n=new nx(s,this,null);else{const r=this.bones[s.parent.index];n=new nx(s,this,r),r.children.push(n)}this.bones.push(n)}this.slots=new Array,this.drawOrder=new Array;for(let e=0;e<t.slots.length;e++){const s=t.slots[e],n=this.bones[s.boneData.index],r=new kT(s,n);this.slots.push(r),this.drawOrder.push(r)}this.ikConstraints=new Array;for(let e=0;e<t.ikConstraints.length;e++){const s=t.ikConstraints[e];this.ikConstraints.push(new wT(s,this))}this.transformConstraints=new Array;for(let e=0;e<t.transformConstraints.length;e++){const s=t.transformConstraints[e];this.transformConstraints.push(new YT(s,this))}this.pathConstraints=new Array;for(let e=0;e<t.pathConstraints.length;e++){const s=t.pathConstraints[e];this.pathConstraints.push(new TT(s,this))}this.color=new Ot(1,1,1,1),this.updateCache()}updateCache(){const t=this._updateCache;t.length=0;const e=this.bones;for(let o=0,d=e.length;o<d;o++){const u=e[o];u.sorted=u.data.skinRequired,u.active=!u.sorted}if(this.skin){const o=this.skin.bones;for(let d=0,u=this.skin.bones.length;d<u;d++){let m=this.bones[o[d].index];do m.sorted=!1,m.active=!0,m=m.parent;while(m)}}const s=this.ikConstraints,n=this.transformConstraints,r=this.pathConstraints,l=s.length,h=n.length,i=r.length,a=l+h+i;t:for(let o=0;o<a;o++){for(let d=0;d<l;d++){const u=s[d];if(u.data.order==o){this.sortIkConstraint(u);continue t}}for(let d=0;d<h;d++){const u=n[d];if(u.data.order==o){this.sortTransformConstraint(u);continue t}}for(let d=0;d<i;d++){const u=r[d];if(u.data.order==o){this.sortPathConstraint(u);continue t}}}for(let o=0,d=e.length;o<d;o++)this.sortBone(e[o])}sortIkConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&pt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target;this.sortBone(e);const s=t.bones,n=s[0];if(this.sortBone(n),s.length==1)this._updateCache.push(t),this.sortReset(n.children);else{const r=s[s.length-1];this.sortBone(r),this._updateCache.push(t),this.sortReset(n.children),r.sorted=!0}}sortPathConstraint(t){if(t.active=t.target.bone.isActive()&&(!t.data.skinRequired||this.skin&&pt.contains(this.skin.constraints,t.data,!0)),!t.active)return;const e=t.target,s=e.data.index,n=e.bone;this.skin&&this.sortPathConstraintAttachment(this.skin,s,n),this.data.defaultSkin&&this.data.defaultSkin!=this.skin&&this.sortPathConstraintAttachment(this.data.defaultSkin,s,n);for(let i=0,a=this.data.skins.length;i<a;i++)this.sortPathConstraintAttachment(this.data.skins[i],s,n);const r=e.getAttachment();r instanceof ko&&this.sortPathConstraintAttachmentWith(r,n);const l=t.bones,h=l.length;for(let i=0;i<h;i++)this.sortBone(l[i]);this._updateCache.push(t);for(let i=0;i<h;i++)this.sortReset(l[i].children);for(let i=0;i<h;i++)l[i].sorted=!0}sortTransformConstraint(t){if(t.active=t.target.isActive()&&(!t.data.skinRequired||this.skin&&pt.contains(this.skin.constraints,t.data,!0)),!t.active)return;this.sortBone(t.target);const e=t.bones,s=e.length;if(t.data.local)for(let n=0;n<s;n++){const r=e[n];this.sortBone(r.parent),this.sortBone(r)}else for(let n=0;n<s;n++)this.sortBone(e[n]);this._updateCache.push(t);for(let n=0;n<s;n++)this.sortReset(e[n].children);for(let n=0;n<s;n++)e[n].sorted=!0}sortPathConstraintAttachment(t,e,s){const n=t.attachments[e];if(n)for(const r in n)this.sortPathConstraintAttachmentWith(n[r],s)}sortPathConstraintAttachmentWith(t,e){if(!(t instanceof ko))return;const s=t.bones;if(!s)this.sortBone(e);else{const n=this.bones;for(let r=0,l=s.length;r<l;){let h=s[r++];for(h+=r;r<h;)this.sortBone(n[s[r++]])}}}sortBone(t){if(!t||t.sorted)return;const e=t.parent;e&&this.sortBone(e),t.sorted=!0,this._updateCache.push(t)}sortReset(t){for(let e=0,s=t.length;e<s;e++){const n=t[e];n.active&&(n.sorted&&this.sortReset(n.children),n.sorted=!1)}}updateWorldTransform(){const t=this.bones;for(let s=0,n=t.length;s<n;s++){const r=t[s];r.ax=r.x,r.ay=r.y,r.arotation=r.rotation,r.ascaleX=r.scaleX,r.ascaleY=r.scaleY,r.ashearX=r.shearX,r.ashearY=r.shearY}const e=this._updateCache;for(let s=0,n=e.length;s<n;s++)e[s].update()}updateWorldTransformWith(t){const e=this.getRootBone(),s=t.matrix.a,n=t.matrix.c,r=t.matrix.b,l=t.matrix.d;e.matrix.tx=s*this.x+n*this.y+t.worldX,e.matrix.ty=r*this.x+l*this.y+t.worldY;const h=e.rotation+90+e.shearY,i=st.cosDeg(e.rotation+e.shearX)*e.scaleX,a=st.cosDeg(h)*e.scaleY,o=st.sinDeg(e.rotation+e.shearX)*e.scaleX,d=st.sinDeg(h)*e.scaleY,u=this.scaleX,m=-this.scaleY;e.matrix.a=(s*i+n*o)*u,e.matrix.c=(s*a+n*d)*u,e.matrix.b=(r*i+l*o)*m,e.matrix.d=(r*a+l*d)*m;const c=this._updateCache;for(let g=0,p=c.length;g<p;g++){const y=c[g];y!=e&&y.update()}}setToSetupPose(){this.setBonesToSetupPose(),this.setSlotsToSetupPose()}setBonesToSetupPose(){const t=this.bones;for(let r=0,l=t.length;r<l;r++)t[r].setToSetupPose();const e=this.ikConstraints;for(let r=0,l=e.length;r<l;r++){const h=e[r];h.mix=h.data.mix,h.softness=h.data.softness,h.bendDirection=h.data.bendDirection,h.compress=h.data.compress,h.stretch=h.data.stretch}const s=this.transformConstraints;for(let r=0,l=s.length;r<l;r++){const h=s[r],i=h.data;h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY,h.mixScaleX=i.mixScaleX,h.mixScaleY=i.mixScaleY,h.mixShearY=i.mixShearY}const n=this.pathConstraints;for(let r=0,l=n.length;r<l;r++){const h=n[r],i=h.data;h.position=i.position,h.spacing=i.spacing,h.mixRotate=i.mixRotate,h.mixX=i.mixX,h.mixY=i.mixY}}setSlotsToSetupPose(){const t=this.slots;pt.arrayCopy(t,0,this.drawOrder,0,t.length);for(let e=0,s=t.length;e<s;e++)t[e].setToSetupPose()}getRootBone(){return this.bones.length==0?null:this.bones[0]}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].data.name==t)return s;return-1}setSkinByName(t){const e=this.data.findSkin(t);if(!e)throw new Error(`Skin not found: ${t}`);this.setSkin(e)}setSkin(t){if(t!=this.skin){if(t)if(this.skin)t.attachAll(this,this.skin);else{const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s],l=r.data.attachmentName;if(l){const h=t.getAttachment(s,l);h&&r.setAttachment(h)}}}this.skin=t,this.updateCache()}}getAttachmentByName(t,e){const s=this.data.findSlot(t);if(!s)throw new Error(`Can't find slot with name ${t}`);return this.getAttachment(s.index,e)}getAttachment(t,e){if(!e)throw new Error("attachmentName cannot be null.");if(this.skin){const s=this.skin.getAttachment(t,e);if(s)return s}return this.data.defaultSkin?this.data.defaultSkin.getAttachment(t,e):null}setAttachment(t,e){if(!t)throw new Error("slotName cannot be null.");const s=this.slots;for(let n=0,r=s.length;n<r;n++){const l=s[n];if(l.data.name==t){let h=null;if(e&&(h=this.getAttachment(n,e),!h))throw new Error(`Attachment not found: ${e}, for slot: ${t}`);l.setAttachment(h);return}}throw new Error(`Slot not found: ${t}`)}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.data.name==t)return r}return null}getBoundsRect(){const t=new hf,e=new hf;return this.getBounds(t,e),{x:t.x,y:t.y,width:e.x,height:e.y}}getBounds(t,e,s=new Array(2)){if(!t)throw new Error("offset cannot be null.");if(!e)throw new Error("size cannot be null.");const n=this.drawOrder;let r=Number.POSITIVE_INFINITY,l=Number.POSITIVE_INFINITY,h=Number.NEGATIVE_INFINITY,i=Number.NEGATIVE_INFINITY;for(let a=0,o=n.length;a<o;a++){const d=n[a];if(!d.bone.active)continue;let u=0,m=null;const c=d.getAttachment();if(c instanceof E0)u=8,m=pt.setArraySize(s,u,0),c.computeWorldVertices(d,m,0,2);else if(c instanceof Io){const g=c;u=g.worldVerticesLength,m=pt.setArraySize(s,u,0),g.computeWorldVertices(d,0,u,m,0,2)}if(m)for(let g=0,p=m.length;g<p;g+=2){const y=m[g],w=m[g+1];r=Math.min(r,y),l=Math.min(l,w),h=Math.max(h,y),i=Math.max(i,w)}}t.set(r,l),e.set(h-r,i-l)}get flipX(){return this.scaleX==-1}set flipX(t){th.deprecatedWarning1||(th.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleX=t?1:-1}get flipY(){return this.scaleY==-1}set flipY(t){th.deprecatedWarning1||(th.deprecatedWarning1=!0,console.warn("Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY")),this.scaleY=t?1:-1}};sn(hx,"deprecatedWarning1",!1);let XT=hx;var $T=Object.defineProperty,NT=(f,t,e)=>t in f?$T(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,hs=(f,t,e)=>NT(f,typeof t!="symbol"?t+"":t,e);class cx{constructor(){hs(this,"name",null),hs(this,"bones",new Array),hs(this,"slots",new Array),hs(this,"skins",new Array),hs(this,"defaultSkin",null),hs(this,"events",new Array),hs(this,"animations",new Array),hs(this,"ikConstraints",new Array),hs(this,"transformConstraints",new Array),hs(this,"pathConstraints",new Array),hs(this,"x",0),hs(this,"y",0),hs(this,"width",0),hs(this,"height",0),hs(this,"version",null),hs(this,"hash",null),hs(this,"fps",0),hs(this,"imagesPath",null),hs(this,"audioPath",null)}findBone(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findBoneIndex(t){if(!t)throw new Error("boneName cannot be null.");const e=this.bones;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSlot(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findSlotIndex(t){if(!t)throw new Error("slotName cannot be null.");const e=this.slots;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}findSkin(t){if(!t)throw new Error("skinName cannot be null.");const e=this.skins;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findEvent(t){if(!t)throw new Error("eventDataName cannot be null.");const e=this.events;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findAnimation(t){if(!t)throw new Error("animationName cannot be null.");const e=this.animations;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findIkConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.ikConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findTransformConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.transformConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraint(t){if(!t)throw new Error("constraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++){const r=e[s];if(r.name==t)return r}return null}findPathConstraintIndex(t){if(t==null)throw new Error("pathConstraintName cannot be null.");const e=this.pathConstraints;for(let s=0,n=e.length;s<n;s++)if(e[s].name==t)return s;return-1}}var VT=Object.defineProperty,_T=(f,t,e)=>t in f?VT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,oo=(f,t,e)=>_T(f,typeof t!="symbol"?t+"":t,e);class dx{constructor(t,e,s){if(oo(this,"index",0),oo(this,"name"),oo(this,"boneData"),oo(this,"color",new Ot(1,1,1,1)),oo(this,"darkColor",null),oo(this,"attachmentName",null),oo(this,"blendMode",V.BLEND_MODES.NORMAL),t<0)throw new Error("index must be >= 0.");if(!e)throw new Error("name cannot be null.");if(!s)throw new Error("boneData cannot be null.");this.index=t,this.name=e,this.boneData=s}}var DT=Object.defineProperty,LT=(f,t,e)=>t in f?DT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Hs=(f,t,e)=>LT(f,typeof t!="symbol"?t+"":t,e);class ux extends Sf{constructor(t){super(t,0,!1),Hs(this,"bones",new Array),Hs(this,"_target",null),Hs(this,"mixRotate",0),Hs(this,"mixX",0),Hs(this,"mixY",0),Hs(this,"mixScaleX",0),Hs(this,"mixScaleY",0),Hs(this,"mixShearY",0),Hs(this,"offsetRotation",0),Hs(this,"offsetX",0),Hs(this,"offsetY",0),Hs(this,"offsetScaleX",0),Hs(this,"offsetScaleY",0),Hs(this,"offsetShearY",0),Hs(this,"relative",!1),Hs(this,"local",!1)}set target(t){this._target=t}get target(){if(this._target)return this._target;throw new Error("BoneData not set.")}}var OT=Object.defineProperty,WT=(f,t,e)=>t in f?OT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Vh=(f,t,e)=>WT(f,typeof t!="symbol"?t+"":t,e);class fx{constructor(t,e,s){this.slotIndex=t,this.name=e,this.attachment=s}}class Cf{constructor(t){if(Vh(this,"name"),Vh(this,"attachments",new Array),Vh(this,"bones",Array()),Vh(this,"constraints",new Array),!t)throw new Error("name cannot be null.");this.name=t}setAttachment(t,e,s){if(!s)throw new Error("attachment cannot be null.");const n=this.attachments;t>=n.length&&(n.length=t+1),n[t]||(n[t]={}),n[t][e]=s}addSkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let l=0;l<this.bones.length;l++)if(this.bones[l]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let l=0;l<this.constraints.length;l++)if(this.constraints[l]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];this.setAttachment(n.slotIndex,n.name,n.attachment)}}copySkin(t){for(let s=0;s<t.bones.length;s++){const n=t.bones[s];let r=!1;for(let l=0;l<this.bones.length;l++)if(this.bones[l]==n){r=!0;break}r||this.bones.push(n)}for(let s=0;s<t.constraints.length;s++){const n=t.constraints[s];let r=!1;for(let l=0;l<this.constraints.length;l++)if(this.constraints[l]==n){r=!0;break}r||this.constraints.push(n)}const e=t.getAttachments();for(let s=0;s<e.length;s++){const n=e[s];n.attachment&&(n.attachment instanceof Io?(n.attachment=n.attachment.newLinkedMesh(),this.setAttachment(n.slotIndex,n.name,n.attachment)):(n.attachment=n.attachment.copy(),this.setAttachment(n.slotIndex,n.name,n.attachment)))}}getAttachment(t,e){const s=this.attachments[t];return s?s[e]:null}removeAttachment(t,e){const s=this.attachments[t];s&&delete s[e]}getAttachments(){const t=new Array;for(let e=0;e<this.attachments.length;e++){const s=this.attachments[e];if(s)for(const n in s){const r=s[n];r&&t.push(new fx(e,n,r))}}return t}getAttachmentsForSlot(t,e){const s=this.attachments[t];if(s)for(const n in s){const r=s[n];r&&e.push(new fx(t,n,r))}}clear(){this.attachments.length=0,this.bones.length=0,this.constraints.length=0}attachAll(t,e){let s=0;for(let n=0;n<t.slots.length;n++){const r=t.slots[n],l=r.getAttachment();if(l&&s<e.attachments.length){const h=e.attachments[s];for(const i in h){const a=h[i];if(l==a){const o=this.getAttachment(s,i);o&&r.setAttachment(o);break}}}s++}}}class UT{constructor(t,e=new Array,s=0,n=new DataView(t.buffer)){this.strings=e,this.index=s,this.buffer=n}readByte(){return this.buffer.getInt8(this.index++)}readUnsignedByte(){return this.buffer.getUint8(this.index++)}readShort(){const t=this.buffer.getInt16(this.index);return this.index+=2,t}readInt32(){const t=this.buffer.getInt32(this.index);return this.index+=4,t}readInt(t){let e=this.readByte(),s=e&127;return(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<7,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<14,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<21,(e&128)!=0&&(e=this.readByte(),s|=(e&127)<<28)))),t?s:s>>>1^-(s&1)}readStringRef(){const t=this.readInt(!0);return t==0?null:this.strings[t-1]}readString(){let t=this.readInt(!0);switch(t){case 0:return null;case 1:return""}t--;let e="";for(let s=0;s<t;){const n=this.readUnsignedByte();switch(n>>4){case 12:case 13:e+=String.fromCharCode((n&31)<<6|this.readByte()&63),s+=2;break;case 14:e+=String.fromCharCode((n&15)<<12|(this.readByte()&63)<<6|this.readByte()&63),s+=3;break;default:e+=String.fromCharCode(n),s++}}return e}readFloat(){const t=this.buffer.getFloat32(this.index);return this.index+=4,t}readBoolean(){return this.readByte()!=0}}var qT=Object.defineProperty,zT=(f,t,e)=>t in f?qT(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,Zr=(f,t,e)=>zT(f,typeof t!="symbol"?t+"":t,e);class GT{constructor(t){Zr(this,"ver40",!1),Zr(this,"scale",1),Zr(this,"attachmentLoader"),Zr(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new cx;s.name="";const n=new UT(t),r=n.readInt32(),l=n.readInt32();s.hash=l==0&&r==0?null:l.toString(16)+r.toString(16),s.version=n.readString();const h=s.version.substr(0,3);if(h!=="4.0"&&h!=="4.1"){const d=`Spine 4.1 loader cant load version ${s.version}. Please configure your pixi-spine bundle`;console.error(d)}this.ver40=h==="4.0",s.x=n.readFloat(),s.y=n.readFloat(),s.width=n.readFloat(),s.height=n.readFloat();const i=n.readBoolean();i&&(s.fps=n.readFloat(),s.imagesPath=n.readString(),s.audioPath=n.readString());let a=0;a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readString();if(!u)throw new Error("String in string table must not be null.");n.strings.push(u)}a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readString();if(!u)throw new Error("Bone name must not be null.");const m=d==0?null:s.bones[n.readInt(!0)],c=new rx(d,u,m);c.rotation=n.readFloat(),c.x=n.readFloat()*e,c.y=n.readFloat()*e,c.scaleX=n.readFloat(),c.scaleY=n.readFloat(),c.shearX=n.readFloat(),c.shearY=n.readFloat(),c.length=n.readFloat()*e,c.transformMode=n.readInt(!0),c.skinRequired=n.readBoolean(),i&&Ot.rgba8888ToColor(c.color,n.readInt32()),s.bones.push(c)}a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readString();if(!u)throw new Error("Slot name must not be null.");const m=s.bones[n.readInt(!0)],c=new dx(d,u,m);Ot.rgba8888ToColor(c.color,n.readInt32());const g=n.readInt32();g!=-1&&Ot.rgb888ToColor(c.darkColor=new Ot,g),c.attachmentName=n.readStringRef(),c.blendMode=n.readInt(!0),s.slots.push(c)}a=n.readInt(!0);for(let d=0,u;d<a;d++){const m=n.readString();if(!m)throw new Error("IK constraint data name must not be null.");const c=new ox(m);c.order=n.readInt(!0),c.skinRequired=n.readBoolean(),u=n.readInt(!0);for(let g=0;g<u;g++)c.bones.push(s.bones[n.readInt(!0)]);c.target=s.bones[n.readInt(!0)],c.mix=n.readFloat(),c.softness=n.readFloat()*e,c.bendDirection=n.readByte(),c.compress=n.readBoolean(),c.stretch=n.readBoolean(),c.uniform=n.readBoolean(),s.ikConstraints.push(c)}a=n.readInt(!0);for(let d=0,u;d<a;d++){const m=n.readString();if(!m)throw new Error("Transform constraint data name must not be null.");const c=new ux(m);c.order=n.readInt(!0),c.skinRequired=n.readBoolean(),u=n.readInt(!0);for(let g=0;g<u;g++)c.bones.push(s.bones[n.readInt(!0)]);c.target=s.bones[n.readInt(!0)],c.local=n.readBoolean(),c.relative=n.readBoolean(),c.offsetRotation=n.readFloat(),c.offsetX=n.readFloat()*e,c.offsetY=n.readFloat()*e,c.offsetScaleX=n.readFloat(),c.offsetScaleY=n.readFloat(),c.offsetShearY=n.readFloat(),c.mixRotate=n.readFloat(),c.mixX=n.readFloat(),c.mixY=n.readFloat(),c.mixScaleX=n.readFloat(),c.mixScaleY=n.readFloat(),c.mixShearY=n.readFloat(),s.transformConstraints.push(c)}a=n.readInt(!0);for(let d=0,u;d<a;d++){const m=n.readString();if(!m)throw new Error("Path constraint data name must not be null.");const c=new lx(m);c.order=n.readInt(!0),c.skinRequired=n.readBoolean(),u=n.readInt(!0);for(let g=0;g<u;g++)c.bones.push(s.bones[n.readInt(!0)]);c.target=s.slots[n.readInt(!0)],c.positionMode=n.readInt(!0),c.spacingMode=n.readInt(!0),c.rotateMode=n.readInt(!0),c.offsetRotation=n.readFloat(),c.position=n.readFloat(),c.positionMode==bi.Fixed&&(c.position*=e),c.spacing=n.readFloat(),(c.spacingMode==_s.Length||c.spacingMode==_s.Fixed)&&(c.spacing*=e),c.mixRotate=n.readFloat(),c.mixX=n.readFloat(),c.mixY=n.readFloat(),s.pathConstraints.push(c)}const o=this.readSkin(n,s,!0,i);o&&(s.defaultSkin=o,s.skins.push(o));{let d=s.skins.length;for(pt.setArraySize(s.skins,a=d+n.readInt(!0));d<a;d++){const u=this.readSkin(n,s,!1,i);if(!u)throw new Error("readSkin() should not have returned null.");s.skins[d]=u}}a=this.linkedMeshes.length;for(let d=0;d<a;d++){const u=this.linkedMeshes[d],m=u.skin?s.findSkin(u.skin):s.defaultSkin;if(!m)throw new Error("Not skin found for linked mesh.");if(!u.parent)throw new Error("Linked mesh parent must not be null");const c=m.getAttachment(u.slotIndex,u.parent);if(!c)throw new Error(`Parent mesh not found: ${u.parent}`);u.mesh.timelineAttachment=u.inheritTimeline?c:u.mesh,u.mesh.setParentMesh(c)}this.linkedMeshes.length=0,a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readStringRef();if(!u)throw new Error;const m=new ax(u);m.intValue=n.readInt(!1),m.floatValue=n.readFloat(),m.stringValue=n.readString(),m.audioPath=n.readString(),m.audioPath&&(m.volume=n.readFloat(),m.balance=n.readFloat()),s.events.push(m)}a=n.readInt(!0);for(let d=0;d<a;d++){const u=n.readString();if(!u)throw new Error("Animatio name must not be null.");s.animations.push(this.readAnimation(n,u,s))}return s}readSkin(t,e,s,n){let r=null,l=0;if(s){if(l=t.readInt(!0),l==0)return null;r=new Cf("default")}else{const h=t.readStringRef();if(!h)throw new Error("Skin name must not be null.");r=new Cf(h),r.bones.length=t.readInt(!0);for(let i=0,a=r.bones.length;i<a;i++)r.bones[i]=e.bones[t.readInt(!0)];for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.ikConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.transformConstraints[t.readInt(!0)]);for(let i=0,a=t.readInt(!0);i<a;i++)r.constraints.push(e.pathConstraints[t.readInt(!0)]);l=t.readInt(!0)}for(let h=0;h<l;h++){const i=t.readInt(!0);for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readStringRef();if(!d)throw new Error("Attachment name must not be null");const u=this.readAttachment(t,e,r,i,d,n);u&&r.setAttachment(i,d,u)}}return r}readAttachment(t,e,s,n,r,l){const h=this.scale;let i=t.readStringRef();switch(i||(i=r),t.readByte()){case Le.Region:{let a=t.readStringRef();const o=t.readFloat(),d=t.readFloat(),u=t.readFloat(),m=t.readFloat(),c=t.readFloat(),g=t.readFloat(),p=t.readFloat(),y=t.readInt32(),w=this.readSequence(t);a||(a=i);const x=this.attachmentLoader.newRegionAttachment(s,i,a,w);return x?(x.path=a,x.x=d*h,x.y=u*h,x.scaleX=m,x.scaleY=c,x.rotation=o,x.width=g*h,x.height=p*h,Ot.rgba8888ToColor(x.color,y),x.sequence=w,w==null&&x.updateRegion(),x):null}case Le.BoundingBox:{const a=t.readInt(!0),o=this.readVertices(t,a),d=l?t.readInt32():0,u=this.attachmentLoader.newBoundingBoxAttachment(s,i);return u?(u.worldVerticesLength=a<<1,u.vertices=o.vertices,u.bones=o.bones,l&&Ot.rgba8888ToColor(u.color,d),u):null}case Le.Mesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readInt(!0),u=this.readFloatArray(t,d<<1,1),m=this.readShortArray(t),c=this.readVertices(t,d),g=t.readInt(!0),p=this.readSequence(t);let y=[],w=0,x=0;l&&(y=this.readShortArray(t),w=t.readFloat(),x=t.readFloat()),a||(a=i);const b=this.attachmentLoader.newMeshAttachment(s,i,a,p);return b?(b.path=a,Ot.rgba8888ToColor(b.color,o),b.bones=c.bones,b.vertices=c.vertices,b.worldVerticesLength=d<<1,b.triangles=m,b.regionUVs=new Float32Array(u),b.hullLength=g<<1,b.sequence=p,l&&(b.edges=y,b.width=w*h,b.height=x*h),b):null}case Le.LinkedMesh:{let a=t.readStringRef();const o=t.readInt32(),d=t.readStringRef(),u=t.readStringRef(),m=t.readBoolean(),c=this.readSequence(t);let g=0,p=0;l&&(g=t.readFloat(),p=t.readFloat()),a||(a=i);const y=this.attachmentLoader.newMeshAttachment(s,i,a,c);return y?(y.path=a,Ot.rgba8888ToColor(y.color,o),y.sequence=c,l&&(y.width=g*h,y.height=p*h),this.linkedMeshes.push(new HT(y,d,n,u,m)),y):null}case Le.Path:{const a=t.readBoolean(),o=t.readBoolean(),d=t.readInt(!0),u=this.readVertices(t,d),m=pt.newArray(d/3,0);for(let p=0,y=m.length;p<y;p++)m[p]=t.readFloat()*h;const c=l?t.readInt32():0,g=this.attachmentLoader.newPathAttachment(s,i);return g?(g.closed=a,g.constantSpeed=o,g.worldVerticesLength=d<<1,g.vertices=u.vertices,g.bones=u.bones,g.lengths=m,l&&Ot.rgba8888ToColor(g.color,c),g):null}case Le.Point:{const a=t.readFloat(),o=t.readFloat(),d=t.readFloat(),u=l?t.readInt32():0,m=this.attachmentLoader.newPointAttachment(s,i);return m?(m.x=o*h,m.y=d*h,m.rotation=a,l&&Ot.rgba8888ToColor(m.color,u),m):null}case Le.Clipping:{const a=t.readInt(!0),o=t.readInt(!0),d=this.readVertices(t,o),u=l?t.readInt32():0,m=this.attachmentLoader.newClippingAttachment(s,i);return m?(m.endSlot=e.slots[a],m.worldVerticesLength=o<<1,m.vertices=d.vertices,m.bones=d.bones,l&&Ot.rgba8888ToColor(m.color,u),m):null}}return null}readSequence(t){if(this.ver40||!t.readBoolean())return null;const e=new k0(t.readInt(!0));return e.start=t.readInt(!0),e.digits=t.readInt(!0),e.setupIndex=t.readInt(!0),e}readDeformTimelineType(t){return this.ver40?mx:t.readByte()}readVertices(t,e){const s=this.scale,n=e<<1,r=new KT;if(!t.readBoolean())return r.vertices=this.readFloatArray(t,n,s),r;const l=new Array,h=new Array;for(let i=0;i<e;i++){const a=t.readInt(!0);h.push(a);for(let o=0;o<a;o++)h.push(t.readInt(!0)),l.push(t.readFloat()*s),l.push(t.readFloat()*s),l.push(t.readFloat())}return r.vertices=pt.toFloatArray(l),r.bones=h,r}readFloatArray(t,e,s){const n=new Array(e);if(s==1)for(let r=0;r<e;r++)n[r]=t.readFloat();else for(let r=0;r<e;r++)n[r]=t.readFloat()*s;return n}readShortArray(t){const e=t.readInt(!0),s=new Array(e);for(let n=0;n<e;n++)s[n]=t.readShort();return s}readAnimation(t,e,s){t.readInt(!0);const n=new Array,r=this.scale;for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readByte(),g=t.readInt(!0),p=g-1;switch(c){case aE:{const y=new Ro(g,d);for(let w=0;w<g;w++)y.setFrame(w,t.readFloat(),t.readStringRef());n.push(y);break}case oE:{const y=t.readInt(!0),w=new D0(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255;for(let A=0,M=0;w.setFrame(A,x,b,S,C,v),A!=p;A++){const I=t.readFloat(),E=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255,R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255;switch(t.readByte()){case vr:w.setStepped(A);break;case Ar:Gt(t,w,M++,A,0,x,I,b,E,1),Gt(t,w,M++,A,1,x,I,S,P,1),Gt(t,w,M++,A,2,x,I,C,R,1),Gt(t,w,M++,A,3,x,I,v,k,1)}x=I,b=E,S=P,C=R,v=k}n.push(w);break}case lE:{const y=t.readInt(!0),w=new L0(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255;for(let v=0,A=0;w.setFrame(v,x,b,S,C),v!=p;v++){const M=t.readFloat(),I=t.readUnsignedByte()/255,E=t.readUnsignedByte()/255,P=t.readUnsignedByte()/255;switch(t.readByte()){case vr:w.setStepped(v);break;case Ar:Gt(t,w,A++,v,0,x,M,b,I,1),Gt(t,w,A++,v,1,x,M,S,E,1),Gt(t,w,A++,v,2,x,M,C,P,1)}x=M,b=I,S=E,C=P}n.push(w);break}case hE:{const y=t.readInt(!0),w=new W0(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255,I=t.readUnsignedByte()/255;for(let E=0,P=0;w.setFrame(E,x,b,S,C,v,A,M,I),E!=p;E++){const R=t.readFloat(),k=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255,B=t.readUnsignedByte()/255,N=t.readUnsignedByte()/255;switch(t.readByte()){case vr:w.setStepped(E);break;case Ar:Gt(t,w,P++,E,0,x,R,b,k,1),Gt(t,w,P++,E,1,x,R,S,Y,1),Gt(t,w,P++,E,2,x,R,C,F,1),Gt(t,w,P++,E,3,x,R,v,X,1),Gt(t,w,P++,E,4,x,R,A,W,1),Gt(t,w,P++,E,5,x,R,M,B,1),Gt(t,w,P++,E,6,x,R,I,N,1)}x=R,b=k,S=Y,C=F,v=X,A=W,M=B,I=N}n.push(w);break}case cE:{const y=t.readInt(!0),w=new U0(g,y,d);let x=t.readFloat(),b=t.readUnsignedByte()/255,S=t.readUnsignedByte()/255,C=t.readUnsignedByte()/255,v=t.readUnsignedByte()/255,A=t.readUnsignedByte()/255,M=t.readUnsignedByte()/255;for(let I=0,E=0;w.setFrame(I,x,b,S,C,v,A,M),I!=p;I++){const P=t.readFloat(),R=t.readUnsignedByte()/255,k=t.readUnsignedByte()/255,Y=t.readUnsignedByte()/255,F=t.readUnsignedByte()/255,X=t.readUnsignedByte()/255,W=t.readUnsignedByte()/255;switch(t.readByte()){case vr:w.setStepped(I);break;case Ar:Gt(t,w,E++,I,0,x,P,b,R,1),Gt(t,w,E++,I,1,x,P,S,k,1),Gt(t,w,E++,I,2,x,P,C,Y,1),Gt(t,w,E++,I,3,x,P,v,F,1),Gt(t,w,E++,I,4,x,P,A,X,1),Gt(t,w,E++,I,5,x,P,M,W,1)}x=P,b=R,S=k,C=Y,v=F,A=X,M=W}n.push(w);break}case dE:{const y=new O0(g,t.readInt(!0),d);let w=t.readFloat(),x=t.readUnsignedByte()/255;for(let b=0,S=0;y.setFrame(b,w,x),b!=p;b++){const C=t.readFloat(),v=t.readUnsignedByte()/255;switch(t.readByte()){case vr:y.setStepped(b);break;case Ar:Gt(t,y,S++,b,0,w,C,x,v,1)}w=C,x=v}n.push(y)}}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0);for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readByte(),g=t.readInt(!0),p=t.readInt(!0);switch(c){case ZT:n.push(yi(t,new $h(g,p,d),1));break;case JT:n.push(vf(t,new R0(g,p,d),r));break;case QT:n.push(yi(t,new Y0(g,p,d),r));break;case jT:n.push(yi(t,new F0(g,p,d),r));break;case tE:n.push(vf(t,new B0(g,p,d),1));break;case eE:n.push(yi(t,new X0(g,p,d),1));break;case sE:n.push(yi(t,new $0(g,p,d),1));break;case nE:n.push(vf(t,new N0(g,p,d),1));break;case rE:n.push(yi(t,new V0(g,p,d),1));break;case iE:n.push(yi(t,new _0(g,p,d),1))}}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),u=t.readInt(!0),m=u-1,c=new H0(u,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat()*r;for(let w=0,x=0;c.setFrame(w,g,p,y,t.readByte(),t.readBoolean(),t.readBoolean()),w!=m;w++){const b=t.readFloat(),S=t.readFloat(),C=t.readFloat()*r;switch(t.readByte()){case vr:c.setStepped(w);break;case Ar:Gt(t,c,x++,w,0,g,b,p,S,1),Gt(t,c,x++,w,1,g,b,y,C,r)}g=b,p=S,y=C}n.push(c)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),u=t.readInt(!0),m=u-1,c=new K0(u,t.readInt(!0),d);let g=t.readFloat(),p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),x=t.readFloat(),b=t.readFloat(),S=t.readFloat();for(let C=0,v=0;c.setFrame(C,g,p,y,w,x,b,S),C!=m;C++){const A=t.readFloat(),M=t.readFloat(),I=t.readFloat(),E=t.readFloat(),P=t.readFloat(),R=t.readFloat(),k=t.readFloat();switch(t.readByte()){case vr:c.setStepped(C);break;case Ar:Gt(t,c,v++,C,0,g,A,p,M,1),Gt(t,c,v++,C,1,g,A,y,I,1),Gt(t,c,v++,C,2,g,A,w,E,1),Gt(t,c,v++,C,3,g,A,x,P,1),Gt(t,c,v++,C,4,g,A,b,R,1),Gt(t,c,v++,C,5,g,A,S,k,1)}g=A,p=M,y=I,w=E,x=P,b=R,S=k}n.push(c)}for(let a=0,o=t.readInt(!0);a<o;a++){const d=t.readInt(!0),u=s.pathConstraints[d];for(let m=0,c=t.readInt(!0);m<c;m++)switch(t.readByte()){case fE:n.push(yi(t,new Z0(t.readInt(!0),t.readInt(!0),d),u.positionMode==bi.Fixed?r:1));break;case mE:n.push(yi(t,new J0(t.readInt(!0),t.readInt(!0),d),u.spacingMode==_s.Length||u.spacingMode==_s.Fixed?r:1));break;case gE:const g=new Q0(t.readInt(!0),t.readInt(!0),d);let p=t.readFloat(),y=t.readFloat(),w=t.readFloat(),x=t.readFloat();for(let b=0,S=0,C=g.getFrameCount()-1;g.setFrame(b,p,y,w,x),b!=C;b++){const v=t.readFloat(),A=t.readFloat(),M=t.readFloat(),I=t.readFloat();switch(t.readByte()){case vr:g.setStepped(b);break;case Ar:Gt(t,g,S++,b,0,p,v,y,A,1),Gt(t,g,S++,b,1,p,v,w,M,1),Gt(t,g,S++,b,2,p,v,x,I,1)}p=v,y=A,w=M,x=I}n.push(g)}}for(let a=0,o=t.readInt(!0);a<o;a++){const d=s.skins[t.readInt(!0)];for(let u=0,m=t.readInt(!0);u<m;u++){const c=t.readInt(!0);for(let g=0,p=t.readInt(!0);g<p;g++){const y=t.readStringRef();if(!y)throw new Error("attachmentName must not be null.");const w=d.getAttachment(c,y),x=this.readDeformTimelineType(t),b=t.readInt(!0),S=b-1;switch(x){case mx:{const C=w,v=C.bones,A=C.vertices,M=v?A.length/3*2:A.length,I=t.readInt(!0),E=new q0(b,I,c,C);let P=t.readFloat();for(let R=0,k=0;;R++){let Y,F=t.readInt(!0);if(F==0)Y=v?pt.newFloatArray(M):A;else{Y=pt.newFloatArray(M);const W=t.readInt(!0);if(F+=W,r==1)for(let B=W;B<F;B++)Y[B]=t.readFloat();else for(let B=W;B<F;B++)Y[B]=t.readFloat()*r;if(!v)for(let B=0,N=Y.length;B<N;B++)Y[B]+=A[B]}if(E.setFrame(R,P,Y),R==S)break;const X=t.readFloat();switch(t.readByte()){case vr:E.setStepped(R);break;case Ar:Gt(t,E,k++,R,0,P,X,0,1,1)}P=X}n.push(E);break}case uE:{const C=new j0(b,c,w);for(let v=0;v<b;v++){const A=t.readFloat(),M=t.readInt32();C.setFrame(v,A,P0[M&15],M>>4,t.readFloat())}n.push(C);break}}}}}const l=t.readInt(!0);if(l>0){const a=new _l(l),o=s.slots.length;for(let d=0;d<l;d++){const u=t.readFloat(),m=t.readInt(!0),c=pt.newArray(o,0);for(let w=o-1;w>=0;w--)c[w]=-1;const g=pt.newArray(o-m,0);let p=0,y=0;for(let w=0;w<m;w++){const x=t.readInt(!0);for(;p!=x;)g[y++]=p++;c[p+t.readInt(!0)]=p++}for(;p<o;)g[y++]=p++;for(let w=o-1;w>=0;w--)c[w]==-1&&(c[w]=g[--y]);a.setFrame(d,u,c)}n.push(a)}const h=t.readInt(!0);if(h>0){const a=new pf(h);for(let o=0;o<h;o++){const d=t.readFloat(),u=s.events[t.readInt(!0)],m=new ix(d,u);m.intValue=t.readInt(!1),m.floatValue=t.readFloat(),m.stringValue=t.readBoolean()?t.readString():u.stringValue,m.data.audioPath&&(m.volume=t.readFloat(),m.balance=t.readFloat()),a.setFrame(o,m)}n.push(a)}let i=0;for(let a=0,o=n.length;a<o;a++)i=Math.max(i,n[a].getDuration());return new mf(e,n,i)}}Zr(GT,"BlendModeValues",[V.BLEND_MODES.NORMAL,V.BLEND_MODES.ADD,V.BLEND_MODES.MULTIPLY,V.BLEND_MODES.SCREEN]);let HT=class{constructor(t,e,s,n,r){Zr(this,"parent"),Zr(this,"skin"),Zr(this,"slotIndex"),Zr(this,"mesh"),Zr(this,"inheritTimeline"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}};class KT{constructor(t=null,e=null){this.bones=t,this.vertices=e}}function yi(f,t,e){let s=f.readFloat(),n=f.readFloat()*e;for(let r=0,l=0,h=t.getFrameCount()-1;t.setFrame(r,s,n),r!=h;r++){const i=f.readFloat(),a=f.readFloat()*e;switch(f.readByte()){case vr:t.setStepped(r);break;case Ar:Gt(f,t,l++,r,0,s,i,n,a,e)}s=i,n=a}return t}function vf(f,t,e){let s=f.readFloat(),n=f.readFloat()*e,r=f.readFloat()*e;for(let l=0,h=0,i=t.getFrameCount()-1;t.setFrame(l,s,n,r),l!=i;l++){const a=f.readFloat(),o=f.readFloat()*e,d=f.readFloat()*e;switch(f.readByte()){case vr:t.setStepped(l);break;case Ar:Gt(f,t,h++,l,0,s,a,n,o,e),Gt(f,t,h++,l,1,s,a,r,d,e)}s=a,n=o,r=d}return t}function Gt(f,t,e,s,n,r,l,h,i,a){t.setBezier(e,s,n,r,h,f.readFloat(),f.readFloat()*a,f.readFloat(),f.readFloat()*a,l,i)}const ZT=0,JT=1,QT=2,jT=3,tE=4,eE=5,sE=6,nE=7,rE=8,iE=9,aE=0,oE=1,lE=2,hE=3,cE=4,dE=5,mx=0,uE=1,fE=0,mE=1,gE=2,vr=1,Ar=2;var pE=Object.defineProperty,xE=(f,t,e)=>t in f?pE(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,lo=(f,t,e)=>xE(f,typeof t!="symbol"?t+"":t,e);class bE{constructor(){lo(this,"minX",0),lo(this,"minY",0),lo(this,"maxX",0),lo(this,"maxY",0),lo(this,"boundingBoxes",new Array),lo(this,"polygons",new Array),lo(this,"polygonPool",new b0(()=>pt.newFloatArray(16)))}update(t,e){if(!t)throw new Error("skeleton cannot be null.");const s=this.boundingBoxes,n=this.polygons,r=this.polygonPool,l=t.slots,h=l.length;s.length=0,r.freeAll(n),n.length=0;for(let i=0;i<h;i++){const a=l[i];if(!a.bone.active)continue;const o=a.getAttachment();if(o!=null&&o.type===Le.BoundingBox){const d=o;s.push(d);let u=r.obtain();u.length!=d.worldVerticesLength&&(u=pt.newFloatArray(d.worldVerticesLength)),n.push(u),d.computeWorldVertices(a,0,d.worldVerticesLength,u,0,2)}}e?this.aabbCompute():(this.minX=Number.POSITIVE_INFINITY,this.minY=Number.POSITIVE_INFINITY,this.maxX=Number.NEGATIVE_INFINITY,this.maxY=Number.NEGATIVE_INFINITY)}aabbCompute(){let t=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY,n=Number.NEGATIVE_INFINITY;const r=this.polygons;for(let l=0,h=r.length;l<h;l++){const i=r[l],a=i;for(let o=0,d=i.length;o<d;o+=2){const u=a[o],m=a[o+1];t=Math.min(t,u),e=Math.min(e,m),s=Math.max(s,u),n=Math.max(n,m)}}this.minX=t,this.minY=e,this.maxX=s,this.maxY=n}aabbContainsPoint(t,e){return t>=this.minX&&t<=this.maxX&&e>=this.minY&&e<=this.maxY}aabbIntersectsSegment(t,e,s,n){const r=this.minX,l=this.minY,h=this.maxX,i=this.maxY;if(t<=r&&s<=r||e<=l&&n<=l||t>=h&&s>=h||e>=i&&n>=i)return!1;const a=(n-e)/(s-t);let o=a*(r-t)+e;if(o>l&&o<i||(o=a*(h-t)+e,o>l&&o<i))return!0;let d=(l-e)/a+t;return d>r&&d<h||(d=(i-e)/a+t,d>r&&d<h)}aabbIntersectsSkeleton(t){return this.minX<t.maxX&&this.maxX>t.minX&&this.minY<t.maxY&&this.maxY>t.minY}containsPoint(t,e){const s=this.polygons;for(let n=0,r=s.length;n<r;n++)if(this.containsPointPolygon(s[n],t,e))return this.boundingBoxes[n];return null}containsPointPolygon(t,e,s){const n=t,r=t.length;let l=r-2,h=!1;for(let i=0;i<r;i+=2){const a=n[i+1],o=n[l+1];if(a<s&&o>=s||o<s&&a>=s){const d=n[i];d+(s-a)/(o-a)*(n[l]-d)<e&&(h=!h)}l=i}return h}intersectsSegment(t,e,s,n){const r=this.polygons;for(let l=0,h=r.length;l<h;l++)if(this.intersectsSegmentPolygon(r[l],t,e,s,n))return this.boundingBoxes[l];return null}intersectsSegmentPolygon(t,e,s,n,r){const l=t,h=t.length,i=e-n,a=s-r,o=e*r-s*n;let d=l[h-2],u=l[h-1];for(let m=0;m<h;m+=2){const c=l[m],g=l[m+1],p=d*g-u*c,y=d-c,w=u-g,x=i*w-a*y,b=(o*y-i*p)/x;if((b>=d&&b<=c||b>=c&&b<=d)&&(b>=e&&b<=n||b>=n&&b<=e)){const S=(o*w-a*p)/x;if((S>=u&&S<=g||S>=g&&S<=u)&&(S>=s&&S<=r||S>=r&&S<=s))return!0}d=c,u=g}return!1}getPolygon(t){if(!t)throw new Error("boundingBox cannot be null.");const e=this.boundingBoxes.indexOf(t);return e==-1?null:this.polygons[e]}getWidth(){return this.maxX-this.minX}getHeight(){return this.maxY-this.minY}}class wE extends bE{}var yE=Object.defineProperty,SE=(f,t,e)=>t in f?yE(f,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):f[t]=e,ha=(f,t,e)=>SE(f,typeof t!="symbol"?t+"":t,e);class gx{constructor(t){ha(this,"attachmentLoader"),ha(this,"scale",1),ha(this,"linkedMeshes",new Array),this.attachmentLoader=t}readSkeletonData(t){const e=this.scale,s=new cx,n=typeof t=="string"?JSON.parse(t):t,r=n.skeleton;if(r){s.hash=r.hash,s.version=r.spine;const l=s.version.substr(0,3);if(l!=="4.0"&&l!=="4.1"){const h=`Spine 4.1 loader cant load version ${r.spine}. Please configure your pixi-spine bundle`;console.error(h)}s.x=r.x,s.y=r.y,s.width=r.width,s.height=r.height,s.fps=r.fps,s.imagesPath=r.images}if(n.bones)for(let l=0;l<n.bones.length;l++){const h=n.bones[l];let i=null;const a=q(h,"parent",null);if(a!=null&&(i=s.findBone(a),i==null))throw new Error(`Parent bone not found: ${a}`);const o=new rx(s.bones.length,h.name,i);o.length=q(h,"length",0)*e,o.x=q(h,"x",0)*e,o.y=q(h,"y",0)*e,o.rotation=q(h,"rotation",0),o.scaleX=q(h,"scaleX",1),o.scaleY=q(h,"scaleY",1),o.shearX=q(h,"shearX",0),o.shearY=q(h,"shearY",0),o.transformMode=pt.enumValue($n,q(h,"transform","Normal")),o.skinRequired=q(h,"skin",!1);const d=q(h,"color",null);d&&o.color.setFromString(d),s.bones.push(o)}if(n.slots)for(let l=0;l<n.slots.length;l++){const h=n.slots[l],i=s.findBone(h.bone);if(!i)throw new Error(`Couldn't find bone ${h.bone} for slot ${h.name}`);const a=new dx(s.slots.length,h.name,i),o=q(h,"color",null);o&&a.color.setFromString(o);const d=q(h,"dark",null);d&&(a.darkColor=Ot.fromString(d)),a.attachmentName=q(h,"attachment",null),a.blendMode=gx.blendModeFromString(q(h,"blend","normal")),s.slots.push(a)}if(n.ik)for(let l=0;l<n.ik.length;l++){const h=n.ik[l],i=new ox(h.name);i.order=q(h,"order",0),i.skinRequired=q(h,"skin",!1);for(let a=0;a<h.bones.length;a++){const o=h.bones[a],d=s.findBone(o);if(d==null)throw new Error(`IK bone not found: ${o}`);i.bones.push(d)}i.target=s.findBone(h.target),i.mix=q(h,"mix",1),i.softness=q(h,"softness",0)*e,i.bendDirection=q(h,"bendPositive",!0)?1:-1,i.compress=q(h,"compress",!1),i.stretch=q(h,"stretch",!1),i.uniform=q(h,"uniform",!1),s.ikConstraints.push(i)}if(n.transform)for(let l=0;l<n.transform.length;l++){const h=n.transform[l],i=new ux(h.name);i.order=q(h,"order",0),i.skinRequired=q(h,"skin",!1);for(let d=0;d<h.bones.length;d++){const u=h.bones[d],m=s.findBone(u);if(!m)throw new Error(`Couldn't find bone ${u} for transform constraint ${h.name}.`);i.bones.push(m)}const a=h.target,o=s.findBone(a);if(!o)throw new Error(`Couldn't find target bone ${a} for transform constraint ${h.name}.`);i.target=o,i.local=q(h,"local",!1),i.relative=q(h,"relative",!1),i.offsetRotation=q(h,"rotation",0),i.offsetX=q(h,"x",0)*e,i.offsetY=q(h,"y",0)*e,i.offsetScaleX=q(h,"scaleX",0),i.offsetScaleY=q(h,"scaleY",0),i.offsetShearY=q(h,"shearY",0),i.mixRotate=q(h,"mixRotate",1),i.mixX=q(h,"mixX",1),i.mixY=q(h,"mixY",i.mixX),i.mixScaleX=q(h,"mixScaleX",1),i.mixScaleY=q(h,"mixScaleY",i.mixScaleX),i.mixShearY=q(h,"mixShearY",1),s.transformConstraints.push(i)}if(n.path)for(let l=0;l<n.path.length;l++){const h=n.path[l],i=new lx(h.name);i.order=q(h,"order",0),i.skinRequired=q(h,"skin",!1);for(let d=0;d<h.bones.length;d++){const u=h.bones[d],m=s.findBone(u);if(!m)throw new Error(`Couldn't find bone ${u} for path constraint ${h.name}.`);i.bones.push(m)}const a=h.target,o=s.findSlot(a);if(!o)throw new Error(`Couldn't find target slot ${a} for path constraint ${h.name}.`);i.target=o,i.positionMode=pt.enumValue(bi,q(h,"positionMode","Percent")),i.spacingMode=pt.enumValue(_s,q(h,"spacingMode","Length")),i.rotateMode=pt.enumValue(Yo,q(h,"rotateMode","Tangent")),i.offsetRotation=q(h,"rotation",0),i.position=q(h,"position",0),i.positionMode==bi.Fixed&&(i.position*=e),i.spacing=q(h,"spacing",0),(i.spacingMode==_s.Length||i.spacingMode==_s.Fixed)&&(i.spacing*=e),i.mixRotate=q(h,"mixRotate",1),i.mixX=q(h,"mixX",1),i.mixY=q(h,"mixY",i.mixX),s.pathConstraints.push(i)}if(n.skins)for(let l=0;l<n.skins.length;l++){const h=n.skins[l],i=new Cf(h.name);if(h.bones)for(let a=0;a<h.bones.length;a++){const o=h.bones[a],d=s.findBone(o);if(!d)throw new Error(`Couldn't find bone ${o} for skin ${h.name}.`);i.bones.push(d)}if(h.ik)for(let a=0;a<h.ik.length;a++){const o=h.ik[a],d=s.findIkConstraint(o);if(!d)throw new Error(`Couldn't find IK constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}if(h.transform)for(let a=0;a<h.transform.length;a++){const o=h.transform[a],d=s.findTransformConstraint(o);if(!d)throw new Error(`Couldn't find transform constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}if(h.path)for(let a=0;a<h.path.length;a++){const o=h.path[a],d=s.findPathConstraint(o);if(!d)throw new Error(`Couldn't find path constraint ${o} for skin ${h.name}.`);i.constraints.push(d)}for(const a in h.attachments){const o=s.findSlot(a);if(!o)throw new Error(`Couldn't find slot ${a} for skin ${h.name}.`);const d=h.attachments[a];for(const u in d){const m=this.readAttachment(d[u],i,o.index,u,s);m&&i.setAttachment(o.index,u,m)}}s.skins.push(i),i.name=="default"&&(s.defaultSkin=i)}for(let l=0,h=this.linkedMeshes.length;l<h;l++){const i=this.linkedMeshes[l],a=i.skin?s.findSkin(i.skin):s.defaultSkin;if(!a)throw new Error(`Skin not found: ${i.skin}`);const o=a.getAttachment(i.slotIndex,i.parent);if(!o)throw new Error(`Parent mesh not found: ${i.parent}`);i.mesh.timelineAttachment=i.inheritTimeline?o:i.mesh,i.mesh.setParentMesh(o)}if(this.linkedMeshes.length=0,n.events)for(const l in n.events){const h=n.events[l],i=new ax(l);i.intValue=q(h,"int",0),i.floatValue=q(h,"float",0),i.stringValue=q(h,"string",""),i.audioPath=q(h,"audio",null),i.audioPath&&(i.volume=q(h,"volume",1),i.balance=q(h,"balance",0)),s.events.push(i)}if(n.animations)for(const l in n.animations){const h=n.animations[l];this.readAnimation(h,l,s)}return s}readAttachment(t,e,s,n,r){const l=this.scale;switch(n=q(t,"name",n),q(t,"type","region")){case"region":{const h=q(t,"path",n),i=this.readSequence(q(t,"sequence",null)),a=this.attachmentLoader.newRegionAttachment(e,n,h,i);if(!a)return null;a.path=h,a.x=q(t,"x",0)*l,a.y=q(t,"y",0)*l,a.scaleX=q(t,"scaleX",1),a.scaleY=q(t,"scaleY",1),a.rotation=q(t,"rotation",0),a.width=t.width*l,a.height=t.height*l,a.sequence=i;const o=q(t,"color",null);return o&&a.color.setFromString(o),a}case"boundingbox":{const h=this.attachmentLoader.newBoundingBoxAttachment(e,n);if(!h)return null;this.readVertices(t,h,t.vertexCount<<1);const i=q(t,"color",null);return i&&h.color.setFromString(i),h}case"mesh":case"linkedmesh":{const h=q(t,"path",n),i=this.readSequence(q(t,"sequence",null)),a=this.attachmentLoader.newMeshAttachment(e,n,h,i);if(!a)return null;a.path=h;const o=q(t,"color",null);o&&a.color.setFromString(o),a.width=q(t,"width",0)*l,a.height=q(t,"height",0)*l,a.sequence=i;const d=q(t,"parent",null);if(d)return this.linkedMeshes.push(new CE(a,q(t,"skin",null),s,d,q(t,"timelines",!0))),a;const u=t.uvs;return this.readVertices(t,a,u.length),a.triangles=t.triangles,a.regionUVs=new Float32Array(u),a.edges=q(t,"edges",null),a.hullLength=q(t,"hull",0)*2,a}case"path":{const h=this.attachmentLoader.newPathAttachment(e,n);if(!h)return null;h.closed=q(t,"closed",!1),h.constantSpeed=q(t,"constantSpeed",!0);const i=t.vertexCount;this.readVertices(t,h,i<<1);const a=pt.newArray(i/3,0);for(let d=0;d<t.lengths.length;d++)a[d]=t.lengths[d]*l;h.lengths=a;const o=q(t,"color",null);return o&&h.color.setFromString(o),h}case"point":{const h=this.attachmentLoader.newPointAttachment(e,n);if(!h)return null;h.x=q(t,"x",0)*l,h.y=q(t,"y",0)*l,h.rotation=q(t,"rotation",0);const i=q(t,"color",null);return i&&h.color.setFromString(i),h}case"clipping":{const h=this.attachmentLoader.newClippingAttachment(e,n);if(!h)return null;const i=q(t,"end",null);if(i!=null){const d=r.findSlot(i);if(d==null)throw new Error(`Clipping end slot not found: ${i}`);h.endSlot=d}const a=t.vertexCount;this.readVertices(t,h,a<<1);const o=q(t,"color",null);return o&&h.color.setFromString(o),h}}return null}readSequence(t){if(t==null)return null;const e=new k0(q(t,"count",0));return e.start=q(t,"start",1),e.digits=q(t,"digits",0),e.setupIndex=q(t,"setup",0),e}readVertices(t,e,s){const n=this.scale;e.worldVerticesLength=s;const r=t.vertices;if(s==r.length){const i=pt.toFloatArray(r);if(n!=1)for(let a=0,o=r.length;a<o;a++)i[a]*=n;e.vertices=i;return}const l=new Array,h=new Array;for(let i=0,a=r.length;i<a;){const o=r[i++];h.push(o);for(let d=i+o*4;i<d;i+=4)h.push(r[i]),l.push(r[i+1]*n),l.push(r[i+2]*n),l.push(r[i+3])}e.bones=h,e.vertices=pt.toFloatArray(l)}readAnimation(t,e,s){const n=this.scale,r=new Array;if(t.slots)for(const h in t.slots){const i=t.slots[h],a=s.findSlot(h);if(!a)throw new Error(`Slot not found: ${h}`);const o=a.index;for(const d in i){const u=i[d];if(!u)continue;const m=u.length;if(d=="attachment"){const c=new Ro(m,o);for(let g=0;g<m;g++){const p=u[g];c.setFrame(g,q(p,"time",0),q(p,"name",null))}r.push(c)}else if(d=="rgba"){const c=new D0(m,m<<2,o);let g=u[0],p=q(g,"time",0),y=Ot.fromString(g.color);for(let w=0,x=0;;w++){c.setFrame(w,p,y.r,y.g,y.b,y.a);const b=u[w+1];if(!b){c.shrink(x);break}const S=q(b,"time",0),C=Ot.fromString(b.color),v=g.curve;v&&(x=jt(v,c,x,w,0,p,S,y.r,C.r,1),x=jt(v,c,x,w,1,p,S,y.g,C.g,1),x=jt(v,c,x,w,2,p,S,y.b,C.b,1),x=jt(v,c,x,w,3,p,S,y.a,C.a,1)),p=S,y=C,g=b}r.push(c)}else if(d=="rgb"){const c=new L0(m,m*3,o);let g=u[0],p=q(g,"time",0),y=Ot.fromString(g.color);for(let w=0,x=0;;w++){c.setFrame(w,p,y.r,y.g,y.b);const b=u[w+1];if(!b){c.shrink(x);break}const S=q(b,"time",0),C=Ot.fromString(b.color),v=g.curve;v&&(x=jt(v,c,x,w,0,p,S,y.r,C.r,1),x=jt(v,c,x,w,1,p,S,y.g,C.g,1),x=jt(v,c,x,w,2,p,S,y.b,C.b,1)),p=S,y=C,g=b}r.push(c)}else if(d=="alpha")r.push(Jr(u,new O0(m,m,o),0,1));else if(d=="rgba2"){const c=new W0(m,m*7,o);let g=u[0],p=q(g,"time",0),y=Ot.fromString(g.light),w=Ot.fromString(g.dark);for(let x=0,b=0;;x++){c.setFrame(x,p,y.r,y.g,y.b,y.a,w.r,w.g,w.b);const S=u[x+1];if(!S){c.shrink(b);break}const C=q(S,"time",0),v=Ot.fromString(S.light),A=Ot.fromString(S.dark),M=g.curve;M&&(b=jt(M,c,b,x,0,p,C,y.r,v.r,1),b=jt(M,c,b,x,1,p,C,y.g,v.g,1),b=jt(M,c,b,x,2,p,C,y.b,v.b,1),b=jt(M,c,b,x,3,p,C,y.a,v.a,1),b=jt(M,c,b,x,4,p,C,w.r,A.r,1),b=jt(M,c,b,x,5,p,C,w.g,A.g,1),b=jt(M,c,b,x,6,p,C,w.b,A.b,1)),p=C,y=v,w=A,g=S}r.push(c)}else if(d=="rgb2"){const c=new U0(m,m*6,o);let g=u[0],p=q(g,"time",0),y=Ot.fromString(g.light),w=Ot.fromString(g.dark);for(let x=0,b=0;;x++){c.setFrame(x,p,y.r,y.g,y.b,w.r,w.g,w.b);const S=u[x+1];if(!S){c.shrink(b);break}const C=q(S,"time",0),v=Ot.fromString(S.light),A=Ot.fromString(S.dark),M=g.curve;M&&(b=jt(M,c,b,x,0,p,C,y.r,v.r,1),b=jt(M,c,b,x,1,p,C,y.g,v.g,1),b=jt(M,c,b,x,2,p,C,y.b,v.b,1),b=jt(M,c,b,x,3,p,C,w.r,A.r,1),b=jt(M,c,b,x,4,p,C,w.g,A.g,1),b=jt(M,c,b,x,5,p,C,w.b,A.b,1)),p=C,y=v,w=A,g=S}r.push(c)}}}if(t.bones)for(const h in t.bones){const i=t.bones[h],a=s.findBone(h);if(!a)throw new Error(`Bone not found: ${h}`);const o=a.index;for(const d in i){const u=i[d],m=u.length;if(m!=0){if(d==="rotate")r.push(Jr(u,new $h(m,m,o),0,1));else if(d==="translate"){const c=new R0(m,m<<1,o);r.push(Af(u,c,"x","y",0,n))}else if(d==="translatex"){const c=new Y0(m,m,o);r.push(Jr(u,c,0,n))}else if(d==="translatey"){const c=new F0(m,m,o);r.push(Jr(u,c,0,n))}else if(d==="scale"){const c=new B0(m,m<<1,o);r.push(Af(u,c,"x","y",1,1))}else if(d==="scalex"){const c=new X0(m,m,o);r.push(Jr(u,c,1,1))}else if(d==="scaley"){const c=new $0(m,m,o);r.push(Jr(u,c,1,1))}else if(d==="shear"){const c=new N0(m,m<<1,o);r.push(Af(u,c,"x","y",0,1))}else if(d==="shearx"){const c=new V0(m,m,o);r.push(Jr(u,c,0,1))}else if(d==="sheary"){const c=new _0(m,m,o);r.push(Jr(u,c,0,1))}}}}if(t.ik)for(const h in t.ik){const i=t.ik[h];let a=i[0];if(!a)continue;const o=s.findIkConstraint(h);if(!o)throw new Error(`IK Constraint not found: ${h}`);const d=s.ikConstraints.indexOf(o),u=new H0(i.length,i.length<<1,d);let m=q(a,"time",0),c=q(a,"mix",1),g=q(a,"softness",0)*n;for(let p=0,y=0;;p++){u.setFrame(p,m,c,g,q(a,"bendPositive",!0)?1:-1,q(a,"compress",!1),q(a,"stretch",!1));const w=i[p+1];if(!w){u.shrink(y);break}const x=q(w,"time",0),b=q(w,"mix",1),S=q(w,"softness",0)*n,C=a.curve;C&&(y=jt(C,u,y,p,0,m,x,c,b,1),y=jt(C,u,y,p,1,m,x,g,S,n)),m=x,c=b,g=S,a=w}r.push(u)}if(t.transform)for(const h in t.transform){const i=t.transform[h];let a=i[0];if(!a)continue;const o=s.findTransformConstraint(h);if(!o)throw new Error(`Transform constraint not found: ${h}`);const d=s.transformConstraints.indexOf(o),u=new K0(i.length,i.length*6,d);let m=q(a,"time",0),c=q(a,"mixRotate",1),g=q(a,"mixX",1),p=q(a,"mixY",g),y=q(a,"mixScaleX",1),w=q(a,"mixScaleY",y);const x=q(a,"mixShearY",1);for(let b=0,S=0;;b++){u.setFrame(b,m,c,g,p,y,w,x);const C=i[b+1];if(!C){u.shrink(S);break}const v=q(C,"time",0),A=q(C,"mixRotate",1),M=q(C,"mixX",1),I=q(C,"mixY",M),E=q(C,"mixScaleX",1),P=q(C,"mixScaleY",E),R=q(C,"mixShearY",1),k=a.curve;k&&(S=jt(k,u,S,b,0,m,v,c,A,1),S=jt(k,u,S,b,1,m,v,g,M,1),S=jt(k,u,S,b,2,m,v,p,I,1),S=jt(k,u,S,b,3,m,v,y,E,1),S=jt(k,u,S,b,4,m,v,w,P,1),S=jt(k,u,S,b,5,m,v,x,R,1)),m=v,c=A,g=M,p=I,y=E,w=P,y=E,a=C}r.push(u)}if(t.path)for(const h in t.path){const i=t.path[h],a=s.findPathConstraint(h);if(!a)throw new Error(`Path constraint not found: ${h}`);const o=s.pathConstraints.indexOf(a);for(const d in i){const u=i[d];let m=u[0];if(!m)continue;const c=u.length;if(d==="position"){const g=new Z0(c,c,o);r.push(Jr(u,g,0,a.positionMode==bi.Fixed?n:1))}else if(d==="spacing"){const g=new J0(c,c,o);r.push(Jr(u,g,0,a.spacingMode==_s.Length||a.spacingMode==_s.Fixed?n:1))}else if(d==="mix"){const g=new Q0(c,c*3,o);let p=q(m,"time",0),y=q(m,"mixRotate",1),w=q(m,"mixX",1),x=q(m,"mixY",w);for(let b=0,S=0;;b++){g.setFrame(b,p,y,w,x);const C=u[b+1];if(!C){g.shrink(S);break}const v=q(C,"time",0),A=q(C,"mixRotate",1),M=q(C,"mixX",1),I=q(C,"mixY",M),E=m.curve;E&&(S=jt(E,g,S,b,0,p,v,y,A,1),S=jt(E,g,S,b,1,p,v,w,M,1),S=jt(E,g,S,b,2,p,v,x,I,1)),p=v,y=A,w=M,x=I,m=C}r.push(g)}}}if(t.deform){t.attachments={};for(const h in t.deform){const i=t.deform[h],a=t.attachments[h]={};for(const o in i){const d=i[o],u=a[o]={};for(const m in d)u[m]={deform:d[m]}}}}if(t.attachments)for(const h in t.attachments){const i=t.attachments[h],a=s.findSkin(h);if(a!=null)for(const o in i){const d=i[o],u=s.findSlot(o);if(!u)throw new Error(`Slot not found: ${o}`);const m=u.index;for(const c in d){const g=d[c],p=a.getAttachment(m,c);for(const y in g){const w=g[y];let x=w[0];if(x){if(y=="deform"){const b=p.bones,S=p.vertices,C=b?S.length/3*2:S.length,v=new q0(w.length,w.length,m,p);let A=q(x,"time",0);for(let M=0,I=0;;M++){let E;const P=q(x,"vertices",null);if(!P)E=b?pt.newFloatArray(C):S;else{E=pt.newFloatArray(C);const F=q(x,"offset",0);if(pt.arrayCopy(P,0,E,F,P.length),n!=1)for(let X=F,W=X+P.length;X<W;X++)E[X]*=n;if(!b)for(let X=0;X<C;X++)E[X]+=S[X]}v.setFrame(M,A,E);const R=w[M+1];if(!R){v.shrink(I);break}const k=q(R,"time",0),Y=x.curve;Y&&(I=jt(Y,v,I,M,0,A,k,0,1,1)),A=k,x=R}r.push(v)}else if(y=="sequence"){const b=new j0(w.length,m,p);let S=0;for(let C=0;C<w.length;C++){const v=q(x,"delay",S),A=q(x,"time",0),M=pi[q(x,"mode","hold")],I=q(x,"index",0);b.setFrame(C,A,M,I,v),S=v,x=w[C+1]}r.push(b)}}}}}}if(t.drawOrder){const h=new _l(t.drawOrder.length),i=s.slots.length;let a=0;for(let o=0;o<t.drawOrder.length;o++,a++){const d=t.drawOrder[o];let u=null;const m=q(d,"offsets",null);if(m){u=pt.newArray(i,-1);const c=pt.newArray(i-m.length,0);let g=0,p=0;for(let y=0;y<m.length;y++){const w=m[y],x=s.findSlot(w.slot);if(!x)throw new Error(`Slot not found: ${x}`);const b=x.index;for(;g!=b;)c[p++]=g++;u[g+w.offset]=g++}for(;g<i;)c[p++]=g++;for(let y=i-1;y>=0;y--)u[y]==-1&&(u[y]=c[--p])}h.setFrame(a,q(d,"time",0),u)}r.push(h)}if(t.events){const h=new pf(t.events.length);let i=0;for(let a=0;a<t.events.length;a++,i++){const o=t.events[a],d=s.findEvent(o.name);if(!d)throw new Error(`Event not found: ${o.name}`);const u=new ix(pt.toSinglePrecision(q(o,"time",0)),d);u.intValue=q(o,"int",d.intValue),u.floatValue=q(o,"float",d.floatValue),u.stringValue=q(o,"string",d.stringValue),u.data.audioPath&&(u.volume=q(o,"volume",1),u.balance=q(o,"balance",0)),h.setFrame(i,u)}r.push(h)}let l=0;for(let h=0,i=r.length;h<i;h++)l=Math.max(l,r[h].getDuration());if(isNaN(l))throw new Error("Error while parsing animation, duration is NaN");s.animations.push(new mf(e,r,l))}static blendModeFromString(t){if(t=t.toLowerCase(),t=="normal")return V.BLEND_MODES.NORMAL;if(t=="additive")return V.BLEND_MODES.ADD;if(t=="multiply")return V.BLEND_MODES.MULTIPLY;if(t=="screen")return V.BLEND_MODES.SCREEN;throw new Error(`Unknown blend mode: ${t}`)}}class CE{constructor(t,e,s,n,r){ha(this,"parent"),ha(this,"skin"),ha(this,"slotIndex"),ha(this,"mesh"),ha(this,"inheritTimeline"),this.mesh=t,this.skin=e,this.slotIndex=s,this.parent=n,this.inheritTimeline=r}}function Jr(f,t,e,s){let n=f[0],r=q(n,"time",0),l=q(n,"value",e)*s,h=0;for(let i=0;;i++){t.setFrame(i,r,l);const a=f[i+1];if(!a)return t.shrink(h),t;const o=q(a,"time",0),d=q(a,"value",e)*s;n.curve&&(h=jt(n.curve,t,h,i,0,r,o,l,d,s)),r=o,l=d,n=a}}function Af(f,t,e,s,n,r){let l=f[0],h=q(l,"time",0),i=q(l,e,n)*r,a=q(l,s,n)*r,o=0;for(let d=0;;d++){t.setFrame(d,h,i,a);const u=f[d+1];if(!u)return t.shrink(o),t;const m=q(u,"time",0),c=q(u,e,n)*r,g=q(u,s,n)*r,p=l.curve;p&&(o=jt(p,t,o,d,0,h,m,i,c,r),o=jt(p,t,o,d,1,h,m,a,g,r)),h=m,i=c,a=g,l=u}}function jt(f,t,e,s,n,r,l,h,i,a){if(f=="stepped")return t.setStepped(s),e;const o=n<<2,d=f[o],u=f[o+1]*a,m=f[o+2],c=f[o+3]*a;return t.setBezier(e,s,n,r,h,d,u,m,c,l,i),e+1}function q(f,t,e){return f[t]!==void 0?f[t]:e}class LE extends v0{createSkeleton(t){this.skeleton=new XT(t),this.skeleton.updateWorldTransform(),this.stateData=new iT(t),this.state=new JM(this.stateData)}}return St.AttachmentType=Xn,St.BinaryInput=K2,St.Color=tM,St.DebugUtils=sM,St.IntSet=Q2,St.Interpolation=a0,St.MathUtils=i0,St.MixBlend=t0,St.MixDirection=e0,St.Physics=ef,St.Pool=h0,St.PositionMode=s0,St.Pow=o0,St.PowOut=eM,St.RotateMode=n0,St.SPINE_VERSION=of,St.SkeletonBounds=wE,St.SkeletonBoundsBase=c0,St.Spine=H2,St.SpineBase=g0,St.SpineDebugRenderer=yM,St.SpineMesh=f0,St.SpineSprite=u0,St.StringSet=j2,St.TextureAtlas=mM,St.TextureAtlasPage=rf,St.TextureAtlasRegion=af,St.TextureFilter=na,St.TextureRegion=Xh,St.TextureWrap=ra,St.TimeKeeper=rM,St.TransformMode=r0,St.Utils=sf,St.Vector2=nM,St.WindowedMean=iM,St.detectSpineVersion=d0,St.filterFromString=nf,St.settings=lf,St.spine38=wp,St.spine40=Jp,St.spine41=jp,St.spine42=pp,St.wrapFromString=cM,St}({},PIXI,PIXI,PIXI,PIXI,PIXI,PIXI,PIXI,PIXI,PIXI);
//# sourceMappingURL=pixi-spine.js.map
